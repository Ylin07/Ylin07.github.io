<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/12/00-%E9%A6%96%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/12/00-%E9%A6%96%E9%A1%B5/" class="post-title-link" itemprop="url">Ylin's Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-12 14:53:29" itemprop="dateCreated datePublished" datetime="2025-03-12T14:53:29+08:00">2025-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-07 13:29:20" itemprop="dateModified" datetime="2025-05-07T13:29:20+08:00">2025-05-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="你好呀">你好呀！</h1>
<h1 id="这里记录我的学习经历和内容">这里记录我的学习经历和内容</h1>
<h1 id="希望能够帮到你们">希望能够帮到你们</h1>
<h1 id="section">: )</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/02/87-NJU-PA-STUDY-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/02/87-NJU-PA-STUDY-4/" class="post-title-link" itemprop="url">87:NJU_PA_STUDY(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-02 21:01:08" itemprop="dateCreated datePublished" datetime="2025-10-02T21:01:08+08:00">2025-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-19 12:19:08" itemprop="dateModified" datetime="2025-10-19T12:19:08+08:00">2025-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一篇博客中,我将完成PA1的收尾部分，我将完成完成对表达式求值的功能拓展，和程序监视点的实现，预计要花费较多的时间。可能很多内容也需要好好学习理解一下。</p>
<h1 id="pa1-监视点">PA1 监视点</h1>
<h2 id="扩展表达式求值的功能">扩展表达式求值的功能</h2>
<p>之前我们实现了算数表达式基本的求值（对整数的基本四则运算与结合律），但这些表达式都是常数组成的，他们的值不会发生变化，导致这样的表达式在监视点中没有任何意义，所以我们需要为我们的表达式拓展以下功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;    # 以&quot;0x&quot;开头</span><br><span class="line">  | &lt;reg_name&gt;              # 以&quot;$&quot;开头</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;==&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;</span><br><span class="line">  | &quot;*&quot; &lt;expr&gt;              # 指针解引用</span><br></pre></td></tr></table></figure>
<p>那么首先我们就需要向框架中添加对应的解析，即更新程序的正则匹配逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_NOTYPE = <span class="number">256</span>, </span><br><span class="line">  TK_EQ, TK_NEQ, TK_AND,</span><br><span class="line">  TK_HEX, TK_NUM, TK_REG,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *regex;</span><br><span class="line">  <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,                <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,                    <span class="comment">// equal</span></span><br><span class="line">  &#123;<span class="string">&quot;!=&quot;</span>, TK_NEQ&#125;,                   <span class="comment">// unequal</span></span><br><span class="line">  &#123;<span class="string">&quot;&amp;&amp;&quot;</span>, TK_AND&#125;,                   <span class="comment">// and</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,                     <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,                       <span class="comment">// minus</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,                     <span class="comment">// multi</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,                       <span class="comment">// div</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,                     <span class="comment">// left brace</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,                     <span class="comment">// right brace</span></span><br><span class="line">  &#123;<span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span>, TK_HEX&#125;,    <span class="comment">// hex number</span></span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_NUM&#125;,               <span class="comment">// number</span></span><br><span class="line">  &#123;<span class="string">&quot;\\$(zero|ra|sp|gp|tp|t[0-6]|s[0-9]|s1[0-1]|a[0-7])&quot;</span>, TK_REG&#125;,   <span class="comment">// reg</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意两个问题：</p>
<ul>
<li><p>一是
对于reg值得获取，框架代码在<code>/src/isa/$ISA/reg.c</code>中提供了<code>isa_reg_str2val()</code>作为接口，它将返回名字为s的寄存器的值，且设置success用于指示是否匹配成功。</p></li>
<li><p>二是
我们需要注意到对指针解引用的识别，对于符号<code>*</code>它可能是乘号，也可能是对地址的解引用。实际上我们可以通过看其前一个标识的类型，我们就可以判断它的用法，所以可以给出框架代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">  *success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Implement code to evaluate the expression. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_token; i ++) &#123;						<span class="comment">// certain type 视具体情况而定</span></span><br><span class="line">  <span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tokens[i - <span class="number">1</span>].type == certain type) ) &#123;</span><br><span class="line">    tokens[i].type = DEREF;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> eval(?, ?);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现在我们开始进一步的拓展我们的表达式的能力：</p>
<h3 id="寄存器接口完善">寄存器接口完善</h3>
<p>我们需要根据<code>$</code>后的寄存器名，来获取对应的寄存器的值，并设置success:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_reg_str2val</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  *success = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(s,<span class="string">&quot;zero&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(s,regs[i])) <span class="keyword">return</span> cpu.gpr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发现寄存器返回值为-1时，则说明寄存器名称错误，我们要停止计算</p>
<h3 id="表达式计算拓展">表达式计算拓展</h3>
<p>我们添加的功能有十六进制数的解析、寄存器的解析、还有部分简单逻辑运算的解析，我们依次分析，需要在哪些地方添加哪些功能：</p>
<p>首先是token的解析存储阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> TK_HEX:</span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j];</span><br><span class="line">            tokens[nr_token].str[substr_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TK_NUM:  </span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j];</span><br><span class="line">            tokens[nr_token].str[substr_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TK_REG:</span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len<span class="number">-1</span>;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j+<span class="number">1</span>];</span><br><span class="line">            tokens[nr_token].str[substr_len<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们添加了对十六进制标识符和寄存器的存储。</p>
<p>同时我们也要注意在<code>eval()</code>，由于我们引入了十六进制和寄存器进入表达式解析中，所以对于最小的子表达式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;   </span><br><span class="line">  | &lt;reg_name&gt;      </span><br></pre></td></tr></table></figure>
<p>我们的解析应该展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[start].type==TK_REG)&#123;</span><br><span class="line">      <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">word_t</span> val = isa_reg_str2val(tokens[start].str,&amp;success);</span><br><span class="line">      <span class="keyword">if</span>(success) <span class="keyword">return</span> val;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Invalid register name: %s\n&quot;</span>, tokens[start].str);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strtol(tokens[start].str,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由于我们添加了逻辑表达式，所以我们还需要更新其对表达式的拆分和运算，首先是运算部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TK_EQ: <span class="keyword">return</span> (val1==val2);</span><br><span class="line">      <span class="keyword">case</span> TK_NEQ: <span class="keyword">return</span> (val1!=val2);</span><br><span class="line">      <span class="keyword">case</span> TK_AND: <span class="keyword">return</span> (val1&amp;&amp;val2);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>与之而来的问题是，在引入逻辑表达式之后，我们该怎么拆分我们的表达式呢？我们知道对于目前已有的运算符，我们有<code>* / &gt; + - &gt;逻辑运算</code>的优先级关系，所以我们可以根据上一节中的规则来更新我们的主运算符号的选择：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_token</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> token = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> par = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> min_priority = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=tokens[i].type;</span><br><span class="line">    <span class="keyword">if</span>(tmp==TK_NUM) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="string">&#x27;(&#x27;</span>) par++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      par--;</span><br><span class="line">      <span class="keyword">if</span>(par&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(par!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> TK_EQ: <span class="keyword">case</span> TK_NEQ: <span class="keyword">case</span> TK_AND:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">3</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(token != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Main operator: %c at position %d\n&quot;, tokens[token].type, token);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No operator found in range [%d, %d]\n&quot;</span>, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了对于运算符的解析和拓展。</p>
<h3 id="解引用分析">解引用分析</h3>
<p>最后我们还需要解决的一个问题就是对于指针的解引用，我们根据框架代码，对负号和解引用的标识符进行替换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nr_token;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((tokens[i].type==<span class="string">&#x27;*&#x27;</span>||tokens[i].type==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;</span><br><span class="line">        (i==<span class="number">0</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;+&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;-&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;*&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;/&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;(&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_AND||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_EQ||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_NEQ)</span><br><span class="line">      )&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i].type == <span class="string">&#x27;*&#x27;</span>) tokens[i].type = DEREF;</span><br><span class="line">        <span class="keyword">else</span> tokens[i].type = NEGATIVE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">word_t</span> val = eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line">  *success = (val!=<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于他们都是一元运算符，在计算的过程中拥有最高的优先级，所以我们需要更新搜索主运算符的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> DEREF: <span class="keyword">case</span> NEGATIVE:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">0</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TK_EQ: <span class="keyword">case</span> TK_NEQ: <span class="keyword">case</span> TK_AND:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">3</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后再最终的对表达式的整合中优先处理一元运算符号，再处理二元运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tokens[op].type == DEREF || tokens[op].type == NEGATIVE) &#123;</span><br><span class="line">      <span class="type">word_t</span> val = eval(op+<span class="number">1</span>, end);</span><br><span class="line">      <span class="keyword">if</span>(val == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(tokens[op].type == DEREF) <span class="keyword">return</span> vaddr_read(val, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TK_EQ: <span class="keyword">return</span> (val1==val2);</span><br><span class="line">      <span class="keyword">case</span> TK_NEQ: <span class="keyword">return</span> (val1!=val2);</span><br><span class="line">      <span class="keyword">case</span> TK_AND: <span class="keyword">return</span> (val1&amp;&amp;val2);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>至此我们完成了对表达式运算符的拓展。</p>
<h2 id="实现监视点">实现监视点</h2>
<p>监视器允许我们设置监视点，当监视点中的表达式满足时，<code>nemu</code>就将<code>nemu_state</code>设置成<code>NEMU_STOP</code>，此时我们就可以对程序状态进行观察。</p>
<p>不过首先我们需要能够将所有监视点管理组织起来，在框架代码中已经定义好了监视点的结构和监视点池的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> NO;	<span class="comment">// 监视器的编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line"></span><br><span class="line">&#125; WP;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> WP wp_pool[NR_WP] = &#123;&#125;;</span><br><span class="line"><span class="type">static</span> WP *head = <span class="literal">NULL</span>, *free_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>我们需要管理两个链表<code>head</code>和<code>free_</code>。<code>head</code>用于存放使用中的监视点结构，<code>free_</code>用于组织空闲的监视点结构，我们可以使用<code>init_wp_pool()</code>函数，对两个链表进行初始化。</p>
<p>为了进一步的管理监视点池，我们需要两个函数：</p>
<ul>
<li><code>WP* new_wp()</code>：用于从空闲的监视点池中选择一个监视点进行使用，同时也要对剩余监视点的数量进行判断</li>
<li><code>void free_wp(WP* wp)</code>：
用于将正在使用中的监视点存回空闲链表中</li>
</ul>
<p>实现了对监视点池的管理之后，我们就需要实现监视点的相关功能了（以下是需要完成的要求）：</p>
<ul>
<li>当用户给出一个待监视表达式时,
你需要通过<code>new_wp()</code>申请一个空闲的监视点结构,
并将表达式记录下来.
然后在<code>trace_and_difftest()</code>函数(在<code>nemu/src/cpu/cpu-exec.c</code>中定义)的最后扫描所有的监视点,
每当<code>cpu_exec()</code>的循环执行完一条指令,
都会调用一次<code>trace_and_difftest()</code>函数. 在扫描监视点的过程中,
你需要对监视点的相应表达式进行求值(你之前已经实现表达式求值的功能了),
并比较它们的值有没有发生变化, 若发生了变化,
程序就因触发了监视点而暂停下来,
你需要将<code>nemu_state.state</code>变量设置为<code>NEMU_STOP</code>来达到暂停的效果.
最后输出一句话提示用户触发了监视点,
并返回到<code>sdb_mainloop()</code>循环中等待用户的命令.</li>
<li>使用<code>info w</code>命令来打印使用中的监视点信息, 至于要打印什么,
你可以参考GDB中<code>info watchpoints</code>的运行结果.</li>
<li>使用<code>d</code>命令来删除监视点,
你只需要释放相应的监视点结构即可.</li>
</ul>
<h3 id="监视点池的管理">监视点池的管理</h3>
<p>这里我想监视点的结构中添加了一个<code>used</code>属性，用来判断当前监视点是否被启用，据此，我们就可以实现对监视点池中的监视点的使用和空闲的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">WP* <span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(free_==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No free watchpoint avilable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WP* wp = free_;</span><br><span class="line">  free_ = free_-&gt;next;</span><br><span class="line">  wp-&gt;used = <span class="number">1</span>;</span><br><span class="line">  wp-&gt;next = head;</span><br><span class="line">  head = wp;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Create watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">  <span class="keyword">return</span> wp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP* wp)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(wp==<span class="literal">NULL</span>||!wp-&gt;used) <span class="built_in">printf</span>(<span class="string">&quot;Invalid watchpoint to free\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(head==wp)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    WP* prev = head;</span><br><span class="line">    <span class="keyword">while</span>(prev!=<span class="literal">NULL</span>&amp;&amp;prev-&gt;next!=wp) prev = prev-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="literal">NULL</span>) prev-&gt;next = wp-&gt;next;</span><br><span class="line">    wp-&gt;used=<span class="number">0</span>;</span><br><span class="line">    wp-&gt;next = free_;</span><br><span class="line">    free_ = wp;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Free watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要进一步的完成监视点的功能，以及用于调用的接口</p>
<h3 id="监视点功能实现">监视点功能实现</h3>
<p>监视点的功能实际上就是在每一次执行之后，遍历一遍监视点链表，如果设置的表达式发生了改变，那么我们说监视点被触发了。所以我们要做的事情很简单，遍历计算表达式的值是否发生改变，如果是，则触发监视点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wp_diff</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* wp = head;</span><br><span class="line">  <span class="keyword">while</span>(wp)&#123;</span><br><span class="line">    <span class="type">bool</span> _;</span><br><span class="line">    <span class="type">word_t</span> new = expr(wp-&gt;expr,&amp;_);</span><br><span class="line">    <span class="keyword">if</span>(wp-&gt;val!=new)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Watchpoint #%d: %s\n Old value = 0x%08x\n New value = 0x%08x\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO,wp-&gt;expr,wp-&gt;val,new);</span><br><span class="line">      wp-&gt;val = new;</span><br><span class="line">      nemu_state.state = NEMU_STOP;</span><br><span class="line">    &#125;</span><br><span class="line">    wp = wp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于NEMU在每次执行时都会在<code>execute()</code>中调用<code>trace_and_difftest()</code>我们在这个程序中加入每次对监视点的判断<code>wp_diff()</code></p>
<p>现在我们只需要进一步完成监视点的接口，使得我们可以方便的创建销毁查看他们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">P* <span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(free_==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No free watchpoint avilable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WP* wp = free_;</span><br><span class="line">  free_ = free_-&gt;next;</span><br><span class="line">  wp-&gt;used = <span class="number">1</span>;</span><br><span class="line">  wp-&gt;next = head;</span><br><span class="line">  head = wp;</span><br><span class="line">  <span class="keyword">return</span> wp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WP* <span class="title function_">NO2wp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;wp_pool[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP* wp)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(wp==<span class="literal">NULL</span>||!wp-&gt;used)&#123;<span class="built_in">printf</span>(<span class="string">&quot;Invalid watchpoint to free\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">if</span>(head==wp)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    WP* prev = head;</span><br><span class="line">    <span class="keyword">while</span>(prev!=<span class="literal">NULL</span>&amp;&amp;prev-&gt;next!=wp) prev = prev-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="literal">NULL</span>) prev-&gt;next = wp-&gt;next;</span><br><span class="line">    wp-&gt;used=<span class="number">0</span>;</span><br><span class="line">    wp-&gt;next = free_;</span><br><span class="line">    free_ = wp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Free watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_set</span><span class="params">(<span class="type">char</span>* expr,<span class="type">word_t</span> val)</span>&#123;</span><br><span class="line">  WP* wp = new_wp();</span><br><span class="line">  <span class="built_in">strcpy</span>(wp-&gt;expr,expr);</span><br><span class="line">  wp-&gt;val = val;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Create watchpoint #%d: %s\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO,wp-&gt;expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_display</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* tmp = head;</span><br><span class="line">  <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在终端进行调用，实现<code>info w</code>，<code>d NO</code>，<code>w EXPR</code>等功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_w</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">word_t</span> val = expr(args,&amp;success);</span><br><span class="line">  <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid expression: %s\n&quot;</span>,args);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wp_set(args,val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_d</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">int</span> NO = atoi(args);</span><br><span class="line">  free_wp(NO2wp(NO));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_display</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* tmp = head;</span><br><span class="line">  <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Watchpoint #%d -&gt; %s\n&quot;</span>,tmp-&gt;NO,tmp-&gt;expr);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们就实现了监视点的功能。</p>
<p>对于断点我们可以通过<code>w $pc=？</code>的方式来让程序停止</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/29/86-NJU-PA-STUDY-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/29/86-NJU-PA-STUDY-3/" class="post-title-link" itemprop="url">86:NJU_PA_STUDY(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-29 12:14:57" itemprop="dateCreated datePublished" datetime="2025-09-29T12:14:57+08:00">2025-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 13:57:29" itemprop="dateModified" datetime="2025-10-02T13:57:29+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们先前反复提到了一个式子<code>EXPR</code>，它代表着表达式含义，常见的表达式是通过操作符连接的。这里我们需要为我们的框架实现一个表达式求值的功能。我们要解决的问题是求值一个字符串表示的表达式。</p>
<h1 id="pa1-表达式求值">PA1 表达式求值</h1>
<p>为了简单起见，我们先从数学表达式求值实现开始。</p>
<h2 id="数学表达式求值">数学表达式求值</h2>
<p>如下的一个表达式的字符串：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;5 + 4 * 3 / 2 - 1&quot;</span><br></pre></td></tr></table></figure>
<p>我们应该怎么求出它的值？我们可以分成两个简单的步骤：</p>
<ul>
<li>首先识别出表达式中的单元</li>
<li>根据表达式的归纳定义进行递归求值</li>
</ul>
<h3 id="词法分析">词法分析</h3>
<p>词法分析要做的事情就是识别出表达式中的单元，这里的单元指的就是有着独立含义的子串，我们称之为token。具体而言我们需要将表达式中所有的单元都赋予一个标签，方便之后根据标签来对表达式进行处理。这里我们使用正则表达式来对<code>token</code>进行处理。</p>
<p>出于简单起见，这里我们暂时只对以下的<code>token</code>类型进行处理：</p>
<ul>
<li>十进制整数</li>
<li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code></li>
<li><code>(</code>，<code>)</code></li>
<li>空格串（一个或者多个空格）</li>
</ul>
<p>首先我们需要使用正则表达式来编写用于识别这些<code>token</code>类型的规则，框架中演示了怎么对其进行匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *regex;</span><br><span class="line">  <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">   * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,    <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,         <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,        <span class="comment">// equal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些规则，在<code>init_sdb()</code>时调用了<code>init_regex()</code>来将其编译成正则结构体并存储在<code>re</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_regex</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> error_msg[<span class="number">128</span>];</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">    ret = regcomp(&amp;re[i], rules[i].regex, REG_EXTENDED);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      regerror(ret, &amp;re[i], error_msg, <span class="number">128</span>);</span><br><span class="line">      panic(<span class="string">&quot;regex compilation failed: %s\n%s&quot;</span>, error_msg, rules[i].regex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果编译不通过，可能是你编写的<code>token</code>匹配的规则不符合正则表达式的语法。现在，我们可以给出一个待匹配的表达式，我们利用<code>make_token()</code>来识别出其中的token。用<code>position</code>变量指示当前待匹配的位置，然后按顺序对当前位置的字符串进行匹配。当一个规则匹配成功，并且匹配出的字串属于position指出的位置时，我们就成功的识别出了一个token。我们则使用Token结构体来将它的内容记录下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">32</span>];</span><br><span class="line">&#125; Token;</span><br><span class="line"><span class="type">static</span> Token tokens[<span class="number">32</span>] __attribute__((used)) = &#123;&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_token __attribute__((used))  = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>type</code>成员用于记录<code>token</code>的类型，然后<code>str</code>用来保存<code>token</code>相应的字串。<code>tokens</code>数组用来保存识别出的<code>token</code>信息，而<code>nr_token</code>则用来指示被识别出的<code>token</code>数目。</p>
<p>现在我们需要向算数表达式中的各种<code>tokens</code>类型添加规则，在成功识别出<code>token</code>hi后，将token的信息一次记录到<code>tokens</code>数组之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules[] = &#123;</span><br><span class="line">  <span class="comment">// 这里需要注意对这些内容的匹配是有优先顺序的，从上到下</span></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,    <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,        <span class="comment">// equal</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,         <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,           <span class="comment">// minus</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,         <span class="comment">// multi</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,       	<span class="comment">// div</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,         <span class="comment">// left brace</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,         <span class="comment">// right brace</span></span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_NUM&#125;,   <span class="comment">// number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们就需要将匹配到的token放入tokens中，并对它的各个字段进行赋值。对于大多数类型，我们只需要简单的保存它的类型就行了，但是对于有数据内容的token，我们需要保存它的<code>data</code>，在这里既是保存它的子串内容信息，方便我们进行进一步的计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">make_token</span><span class="params">(<span class="type">char</span> *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">  <span class="type">regmatch_t</span> pmatch;</span><br><span class="line">  nr_token = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e[position] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">/* Try all rules one by one. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (regexec(&amp;re[i], e + position, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; pmatch.rm_so == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *substr_start = e + position;</span><br><span class="line">        <span class="type">int</span> substr_len = pmatch.rm_eo;</span><br><span class="line">        Log(<span class="string">&quot;match rules[%d] = \&quot;%s\&quot; at position %d with len %d: %.*s&quot;</span>,</span><br><span class="line">            i, rules[i].regex, position, substr_len, substr_len, substr_start);</span><br><span class="line">        position += substr_len;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Now a new token is recognized with rules[i]. Add codes</span></span><br><span class="line"><span class="comment">         * to record the token in the array `tokens&#x27;. For certain types</span></span><br><span class="line"><span class="comment">         * of tokens, some extra actions should be performed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> TK_NUM:  </span><br><span class="line">            tokens[index].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[index].str[j] = substr_start[j];</span><br><span class="line">            <span class="comment">// printf(&quot;The num is %s\n&quot;,tokens[index].str);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            tokens[index].type = rules[i].token_type;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NR_REGEX) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;no match at position %d\n%s\n%*.s^\n&quot;</span>, position, e, position, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到整个识别token的过程，每当我们获取一个<code>token</code>时，我们都会使用<code>Log()</code>将它的匹配规则，子串下标，子串长度，和对应的子串信息打印出来。便于我们观察标识符匹配的中间过程。对于未匹配到的类型，我们也会将其内容进行返回。</p>
<p>中间部分则是我们对token信息的存储过程，目前我们只对十进制整数的内容进行了保存，对于其他的标识符号，则是简单的保存类型。现在我们可以进一步的进行表达式求值了。</p>
<h3 id="递归求值">递归求值</h3>
<p>我们现在将求值表达式的<code>token</code>识别出来之后就可以进行求值了。我们现在是对<code>token</code>数组进行处理，方便起见，我们称其为<code>token</code>表达式。（将空格忽略）</p>
<p>接下来，根据表达式的归纳定义特性，我们可以使用递归来进行求值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;number&gt;    # 一个数是表达式</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;     # 在表达式两边加个括号也是表达式</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;  # 两个表达式相加也是表达式</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;  # 接下来你全懂了</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>这种表示方法就是我们常说的BNF，我们可以这里理解，长表达式是由短表达式构成的，那么我们可以先对短表达式进行求值，然后再进一步的对长表达式进行求值。</p>
<p>为了在token表达式中指示一个子表达式，我么可以使用两个整数<code>p</code>和<code>q</code>来指示子表达式的开始和结束位置，现在我们就可以写出一个求值函数的框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">    <span class="comment">/* Bad expression */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">    <span class="comment">/* Single token.</span></span><br><span class="line"><span class="comment">     * For now this token should be a number.</span></span><br><span class="line"><span class="comment">     * Return the value of the number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (check_parentheses(p, q) == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* The expression is surrounded by a matched pair of parentheses.</span></span><br><span class="line"><span class="comment">     * If that is the case, just throw away the parentheses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> eval(p + <span class="number">1</span>, q - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* We should do more things here. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>check_parentheses()</code>用于判断表达式是否被一堆匹配的括号所包围，同时检查表达式左右的括号是否匹配，如果不匹配，那么这个表达式就是非法的。我们以此来尝试实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_parentheses</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> cond=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(tokens[start].type!=<span class="string">&#x27;(&#x27;</span>||tokens[end].type!=<span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[i].type==<span class="string">&#x27;(&#x27;</span>) cond++;</span><br><span class="line">    <span class="keyword">if</span>(tokens[i].type==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      cond--;</span><br><span class="line">      <span class="keyword">if</span>(cond&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cond==<span class="number">0</span>) <span class="keyword">return</span> (i == end) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (cond==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们的框架代码，已经可以处理BNF的开始两种情况啦。像现在我们需要进一步的考虑剩下的情况，即四则运算的处理。但是问题在于，我们怎么对一个长表达式处理，将其分解为各个小的短表达式，并保证语法的正确呢？</p>
<p>我们以下为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;4 + 3 * ( 2 - 1 )&quot;</span></span><br><span class="line"><span class="comment">/*********************/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="string">&quot;+&quot;</span></span><br><span class="line">   /   \</span><br><span class="line"><span class="string">&quot;4&quot;</span>     <span class="string">&quot;3 * ( 2 - 1 )&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">       /   \</span><br><span class="line"><span class="string">&quot;4 + 3&quot;</span>     <span class="string">&quot;( 2 - 1 )&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="string">&quot;-&quot;</span></span><br><span class="line">             /   \</span><br><span class="line"><span class="string">&quot;4 + 3 * ( 2&quot;</span>     <span class="string">&quot;1 )&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到只有第一种情况是正确的，第二种情况违背了算术符号的优先级，而第三种情况则使得表达式的括号不再匹配。通过以上的例子，我们就可以总结出寻找主运算符（可以将一个长表达式分解成两个短表达式的运算符号）的逻辑了：</p>
<ul>
<li>非运算符的<code>token</code>不是主运算符</li>
<li>出现在一对括号中的<code>token</code>不是主运算符号</li>
<li>主运算符的优先级在表达式中应该是最低的</li>
<li>有多个运算符的优先级最低时，根据结合性，最后被结合的运算符为主运算符号</li>
</ul>
<p>现在我们根据以上规则来扫描出每个表达式中的主运算符号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_token</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> token = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> par = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> min_priority = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=tokens[i].type;</span><br><span class="line">    <span class="keyword">if</span>(tmp==TK_NUM) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="string">&#x27;(&#x27;</span>) par++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      par--;</span><br><span class="line">      <span class="keyword">if</span>(par&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(par!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(token != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Main operator: %c at position %d\n&quot;, tokens[token].type, token);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No operator found in range [%d, %d]\n&quot;</span>, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到表达式的主运算符之后，事情就变得简单了，我们先对两个分裂出来的子表达式进行递归求值，然后根据主运算符号的两个子表达式进行计算即可，现在我们的框架代码更新如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">    <span class="comment">/* Bad expression */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">    <span class="comment">/* Single token.</span></span><br><span class="line"><span class="comment">     * For now this token should be a number.</span></span><br><span class="line"><span class="comment">     * Return the value of the number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (check_parentheses(p, q) == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* The expression is surrounded by a matched pair of parentheses.</span></span><br><span class="line"><span class="comment">     * If that is the case, just throw away the parentheses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> eval(p + <span class="number">1</span>, q - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    op = the position of 主运算符 in the token expression;</span><br><span class="line">    val1 = eval(p, op - <span class="number">1</span>);</span><br><span class="line">    val2 = eval(op + <span class="number">1</span>, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1 + val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们需要利用现有的规则和函数来填补实现我们的求值函数<code>eval()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown expression.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">    <span class="keyword">return</span> atoi(tokens[start].str);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(check_parentheses(start,end)==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> eval(start+<span class="number">1</span>,end<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(check_parentheses(start,end)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parenthese mismatch error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，基本可以处理大多数情况了。我们现在可以将其封装在<code>expr()</code>中，然后实现<code>p</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">word_t</span> val = eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line">  *success = (val!=<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_p</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">bool</span> success;</span><br><span class="line">  <span class="type">word_t</span> val=expr(args,&amp;success);</span><br><span class="line">  <span class="keyword">if</span>(success==<span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于限制，我们只使用<code>uint32_t</code>作为我们的返回类型。</p>
<h3 id="测试代码">测试代码</h3>
<p>按照PA的要求，我们现在应该测试一下我们这个函数，但是我就跳过这一部分了，因为赶时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/28/85-NJU-PA-STUDY-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/28/85-NJU-PA-STUDY-2/" class="post-title-link" itemprop="url">85:NJU_PA_STUDY(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-28 09:34:21 / 修改时间：13:13:00" itemprop="dateCreated datePublished" datetime="2025-09-28T09:34:21+08:00">2025-09-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>NEME是一个用于执行其他用户程序的虚拟计算机，对于运行在NEMU中的应用程序，外部的调试器难以获取其详细的信息，往往需要对引用程序内部下断点的方法来观察程序运行。</p>
<p>但是对于NEMU而言，应用程序的状态是可见的，因此我们需要一个简单有效的方法来观察并调试应用程序的内部状态，所以我们需要设计简易调试器，作为NEMU的基础设施，方便日后的进一步处理。</p>
<h1 id="pa1-基础设施">PA1 基础设施</h1>
<p>我们需要在monitor中实现一个简单的sdb。相关的框架代码存放在<code>src\monitor\sdb</code>中，我们可以在cmd_table中查看目前已有的指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *description;</span><br><span class="line">  <span class="type">int</span> (*handler) (<span class="type">char</span> *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display information about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在PA1中我们要实现的功能还有：</p>
<figure>
<img src="https://s2.loli.net/2025/09/28/dQbZXDc6zxEKeNS.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>今天则从最基本的三个功能开始实现：</p>
<ul>
<li>单步执行</li>
<li>打印寄存器状态</li>
<li>扫描内存状态</li>
</ul>
<h2 id="解析命令">解析命令</h2>
<p>NEMU通过<readline>库对命令行输入进行处理。我们可以在函数<code>rl_gets()</code>中看到对<code>readline()</code>函数的包装。然后在<code>sdb_mainloop()</code>中通过调用其获取，命令行内容。后续对获取的命令行内容进行解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> *str; (str = rl_gets()) != <span class="literal">NULL</span>; ) &#123;</span><br><span class="line">    <span class="type">char</span> *str_end = str + <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* extract the first token as the command */</span></span><br><span class="line">    <span class="type">char</span> *cmd = strtok(str, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="literal">NULL</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* treat the remaining string as the arguments,</span></span><br><span class="line"><span class="comment">     * which may need further parsing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *args = cmd + <span class="built_in">strlen</span>(cmd) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (args &gt;= str_end) &#123;</span><br><span class="line">      args = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里程序将命令行内容解析为命令<code>cmd</code>和命令行参数<code>args</code>，我们接受cmd和args的指针，然后根据cmd调用对应的指令。不过这里需要注意。对于多参数的指令，我们需要对<code>args</code>进行额外的处理。</p>
<h2 id="单步执行">单步执行</h2>
<p>现在我们开始进行单步执行的操作，首先我们需要向<code>cmd_table</code>中添加我们的指令和对应的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;si&quot;</span>, <span class="string">&quot;si [N]&quot;</span>, cmd_si&#125;,</span><br></pre></td></tr></table></figure>
<p>然后对于<code>si</code>的执行逻辑我们写在处理函数<code>cmd_si</code>中。</p>
<p>对于单步执行的实现，我们希望CPU一次只执行一条指令，我们自然会想到先前的负责CPU执行的函数<code>cpu_exec()</code>，我们可以参考<code>c/continue</code>的实现来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(args==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    cpu_exec(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> step = strtol(args,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  cpu_exec(step);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用<code>si</code>是默认步进一条指令，当给出指定参数时，不仅指定的步数。</p>
<h2 id="显示寄存器">显示寄存器</h2>
<p>寄存器和ISA架构是相关的，所以框架中为我们在<code>src/isa/$ISA/reg.c</code>中设置了相应的接口<code>isa_regs_display()</code>，我们只需要完善这个接口。然后在处理函数中调用它就好了。</p>
<p>我们先向<code>cmd_tale</code>中添加对应的功能:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;info&quot;</span>, <span class="string">&quot;info [r/w]&quot;</span>, cmd_info&#125;,</span><br></pre></td></tr></table></figure>
<p>使用<code>cmd_info()</code>作为命令的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;r\0&quot;</span>,<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown arguments &#x27;%s&#x27;\n&quot;</span>,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    isa_reg_display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于之后还要拓展所以需要对<code>info</code>的参数进行匹配。这里我们调用了框架提供的接口进行使用<code>isa_regs_display()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isa_reg_display</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i],cpu.gpr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i+<span class="number">1</span>],cpu.gpr[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i+<span class="number">2</span>],cpu.gpr[i+<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x\n&quot;</span>,regs[i+<span class="number">3</span>],cpu.gpr[i+<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过对应的格式打印<code>cpu</code>结构中的通用寄存器的值即可。</p>
<h2 id="扫描内存">扫描内存</h2>
<p>由于我们还没有实现对表达式的求值和解析，所以在指定内存时，我们暂时只支持十六进制。至于扫描内存，我们只需要从指定的位置起始，使用内存接口打印指定长度的字节即可。我们可以在<code>src\memory\vaddr.c</code>中找到我们可使用的接口。</p>
<p>由于我们的应用程序是运行在虚拟空间中的，所以我们使用的是虚拟内存读取<code>vaddr_read()</code>。现在我们可以尝试开始实现这个功能，首先我们需要向<code>cmd_table()</code>，添加功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;x&quot;</span>, <span class="string">&quot;x [N] EXPR&quot;</span>, cmd_x&#125;</span><br></pre></td></tr></table></figure>
<p>由于这一部分我们需要使用两个参数，所以我们还需要对<code>args</code>进行预处理，用于为内存扫描提供参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* arg1=strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(arg1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No argument1 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  len = strtol(arg1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* arg2=strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(arg2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No argument2 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  addr = strtol(arg2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>strtol</code>来划分参数，然后使用strtol将参数转换为对应的数值，作为接口的参数，然后我们就可以通过访问接口，遍历打印指定位置的内存数数据了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">char</span>* arg1=strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(arg1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No argument1 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    len = strtol(arg1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>* arg2=strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(arg2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No argument2 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    addr = strtol(arg2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;0x%08x:  &quot;</span>,ANSI_FG_BLUE),addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;len&amp;&amp;j&lt;<span class="number">4</span>;i++,j++)&#123;</span><br><span class="line">      <span class="type">uint32_t</span> data = vaddr_read(addr, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0x%08x  &quot;</span>,data);</span><br><span class="line">      addr += <span class="number">4</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了PA1中的基础设施。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/27/84-%E4%B9%9D%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/84-%E4%B9%9D%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">84:九月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-27 19:56:50 / 修改时间：20:19:59" itemprop="dateCreated datePublished" datetime="2025-09-27T19:56:50+08:00">2025-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">日常总结</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>793</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个月发生了各种各样的事情，我特别累也特别疲惫。对于上次以后的总结，我几乎记不得中间都做了哪些事情。我不想对这一个月的经历过多谈论，我心里是十分难过的。</p>
<p>接下来一段时间会很忙，忙在哪些地方呢？</p>
<ul>
<li>NJU PA实验，我要坚持写下去</li>
<li>操作系统真象还原，我也要坚持看下去，我希望能通过这本书的指引，实现一个自己的操作系统。之后我想仿写xv6的源代码，实现一个基本的操作系统内核。</li>
<li>最近新接的科研训练项目，主题是<code>基于动态欺骗的主动网络防护技术</code>，现在还在写文档阶段，非常无聊和痛苦</li>
<li>这个学期冗杂的课程，还有各种活动</li>
</ul>
<p>直白的说，我这个月是感情失利了。我和在一起四年的一个女生分开了。感觉就是很难过，不知道怎么用语言描述，我一开始天天躺着，天天打游戏来麻痹自己，但是感觉都没什么用。我不知道怎么办，我想各种办法去转移自己的注意力，但是无论做什么都没办法集中自己，这几天睡得也很晚，总之就是精神状态很差。</p>
<p>但是我也不该，也不愿意一直这么下去，我找各种各样得事情给自己，不知不觉就这么多事情了。现在已经过去了大半个月了，不想刚开始一样一想到就会好难过，但是偶尔还是会难过。我觉得生活还得继续，不能一直自暴自弃，继续走下去，也许我会遇到更好的女生，也许我会以更好的状态遇见她。我这么想着，慢慢开始忙碌起来，身体还是很疲惫，依然需要时间去习惯与适应。</p>
<p>可能十月份会非常忙吧，各种各样的事情，所以国庆也不能闲着，要抓紧时间。可能这个学期能玩游戏的时间会越来越少，但还是要坚持住。这也是我第一次参加科研训练，我对科研学习的过程也一直很感兴趣，我想好好体验一下这个过程。</p>
<p>还有PA实验和操作系统，本来操作系统是想跟着JYY老师的课程学习的，现在看来是没什么时间了。还要概率论、离散数学、密码学应用基础，这些课基本还没听过，也不知道怎么办。这个学期的408课程也是牢的没边，也不知道怎么办。</p>
<p>这么看了这个学期还真是坎坷，和我暑假时预想的一点也不一样。当然我也没想到会和她分手QAQ，不过现在她还是愿意陪我聊天的，说不定以后还有机会。事到如今只能，继续坚持下去。希望以后会越来越好，也希望我能在这段时间里慢慢获得成长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/27/83-NJU-PA-STUDY-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/83-NJU-PA-STUDY-1/" class="post-title-link" itemprop="url">83:NJU_PA_STUDY(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-27 07:37:21 / 修改时间：10:54:09" itemprop="dateCreated datePublished" datetime="2025-09-27T07:37:21+08:00">2025-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pa1-rtfsc">PA1 RTFSC</h1>
<h2 id="框架代码">框架代码</h2>
<p>由于NEMU-PA是一个很庞大的框架系统，所以要在其基础之上开发需要对框架代码进行熟悉。所以最重要的一步应该是阅读程序的源代码。在课件中，已经给出了相关代码的简要结构说明，按照标题简单理解即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── configs                    # 预先提供的一些配置文件</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── cpu.h</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   ├── difftest.h</span><br><span class="line">│   │   └── ifetch.h           # 取指相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── difftest-def.h</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏</span><br><span class="line">│   ├── isa.h                  # ISA相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   └── utils.h</span><br><span class="line">├── Kconfig                    # 配置信息管理的规则</span><br><span class="line">├── Makefile                   # Makefile构建脚本</span><br><span class="line">├── README.md</span><br><span class="line">├── resource                   # 一些辅助资源</span><br><span class="line">├── scripts                    # Makefile构建脚本</span><br><span class="line">│   ├── build.mk</span><br><span class="line">│   ├── config.mk</span><br><span class="line">│   ├── git.mk                 # git版本控制相关</span><br><span class="line">│   └── native.mk</span><br><span class="line">├── src                        # 源文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   └── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── engine</span><br><span class="line">│   │   └── interpreter        # 解释器的实现</span><br><span class="line">│   ├── filelist.mk</span><br><span class="line">│   ├── isa                    # ISA相关的实现</span><br><span class="line">│   │   ├── mips32</span><br><span class="line">│   │   ├── riscv32</span><br><span class="line">│   │   ├── riscv64</span><br><span class="line">│   │   └── x86</span><br><span class="line">│   ├── memory                 # 内存访问的实现</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── monitor.c</span><br><span class="line">│   │   └── sdb                # 简易调试器</span><br><span class="line">│   │       ├── expr.c         # 表达式求值的实现</span><br><span class="line">│   │       ├── sdb.c          # 简易调试器的命令处理</span><br><span class="line">│   │       └── watchpoint.c   # 监视点的实现</span><br><span class="line">│   ├── nemu-main.c            # 你知道的...</span><br><span class="line">│   └── utils                  # 一些公共的功能</span><br><span class="line">│       ├── log.c              # 日志文件相关</span><br><span class="line">│       ├── rand.c</span><br><span class="line">│       ├── state.c</span><br><span class="line">│       └── timer.c</span><br><span class="line">└── tools                      # 一些工具</span><br><span class="line">    ├── fixdep                 # 依赖修复, 配合配置系统进行使用</span><br><span class="line">    ├── gen-expr</span><br><span class="line">    ├── kconfig                # 配置系统</span><br><span class="line">    ├── kvm-diff</span><br><span class="line">    ├── qemu-diff</span><br><span class="line">    └── spike-diff</span><br></pre></td></tr></table></figure>
<p>为了支持不同的ISA形式。框架代码将NEMU分成两部分：ISA的相关实现和ISA无关的框架代码。其中不同的ISA被存放在<code>src/isa</code>目录下，用于提供接口，其余部分框架则是相同的实现。这里我们选择RISCV作为我们的ISA，现在我们就可以对整个框架代码进行分析了。</p>
<h2 id="配置系统和项目构建">配置系统和项目构建</h2>
<p>系统的主要配置文件存放在主目录下的<code>Kconfig</code>文件中，当我们运行<code>make memuconfig</code>时，会弹出一个可视化的编辑界面，程序会将我们的选择对应的添加到<code>include\generate\autoconf.h</code>中，用于编译时设置。从而实现对框架代码的简易配置。</p>
<p>对于更复杂的过程，涉及到<code>makefile</code>的编写，这里暂时忽略。</p>
<h2 id="准备第一个客户应用">准备第一个客户应用</h2>
<p>NEMU作为一个模拟的计算机系统，主要的功能就是运行客户程序。我们可以从头观察NEMU的项目框架，来查看，NEMU是怎么进行初始化，并且将客户应用加载到内存中运行的。</p>
<p>首先是进入<code>nemu-main.c</code>中，可以看到形如<code>CONFIG_XX</code>的宏定义字样，我们可以在<code>autoconf.h</code>中找到相关的宏定义，根据部分宏的配置，可能会编译时忽略或是开启部分功能。</p>
<p>NEMU的框架代码主要通过函数进行包装，进入<code>nemu-main.c</code>中，首先执行的是<code>init_moniter()</code>,步进程序可以看到monitor的初始化过程，对于<code>mem</code>和<code>seed</code>都是简单的设置，可以之间看源代码</p>
<p>其中<code>init_isa()</code>的代码比较特殊，也比较关键：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* Set the initial program counter. */</span></span><br><span class="line">  cpu.pc = RESET_VECTOR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The zero register is always 0. */</span></span><br><span class="line">  cpu.gpr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_isa</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* Load built-in image. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(guest_to_host(RESET_VECTOR), img, <span class="keyword">sizeof</span>(img));</span><br><span class="line">  <span class="comment">/* Initialize this virtual computer system. */</span></span><br><span class="line">  restart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先将<code>img</code>（这里是初始程序，加载到主机的起始地址），具体的内容可以在<code>isa\risc32\init.c</code>中查看看，<code>restart()</code>的作用是将CPU复位成初始状态，这里主要是将pc置0，并将riscv的第一个寄存器设置为0，作为零寄存器。</p>
<p>通过查看<code>memory</code>目录我们可以知道，NEMU为客户计算机提供了<code>128MB</code>的物理内存，同时我们将客户程序读入到内存的固定内存位置<code>RESET_VECTOR</code>。</p>
<p>在这里我们需要分清楚主机和客户机的区别，主机就是运行NEMU的物理计算机，客户机就是在NEMU上运行的计算机程序。我们使用<code>guest_to_host()</code>和<code>host_to_guest()</code>进行主机和客户机地址的相互转换。<code>guest_to_host()</code>将我们在客户机的物理地址转换成在NEMU内存中的数组地址，<code>host_to_guest()</code>则将内存中的数组地址转换成客户机的物理地址。</p>
<p>我们可以在<code>include\memory\paddr.h</code>中找到对<code>RESET_VECTOR</code>的定义，由于这里我们没有设置<code>CONFIG_PC_RESET_OFFSET</code>所以内存的加载从<code>pmem[0]</code>开始。</p>
<p>接着程序调用<code>load_image()</code>用于向内存中加载程序，如果没有给出img参数，则NEMU使用内置的初始化程序，我们可以在<code>isa/risc32/init.c</code>中看到。</p>
<p>然后程序调用<code>welcome()</code>,我们编译运行时看到的信息就是来自这里。</p>
<h2 id="运行第一个客户运用">运行第一个客户运用</h2>
<p>在monitor完成初始化之后，<code>nemu-main.c</code>会进入下一个程序<code>engine_start</code>中的<code>sdb_mainloop()</code>，并输出提示符指示输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nemu)</span><br></pre></td></tr></table></figure>
<p>在<code>src\monitor\sdb\sdb.c</code>中，程序预设了一个<code>cnd_table</code>，设置在sdb中支持的指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd_table [] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display information about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于参数的处理和选择执行可以通过阅读<code>sdb_mainloop</code>理解，这里我们主要将注意力放到<code>cmd_c()</code>的调用函数<code>cpu_exec()</code>上，它是我们模拟器运行程序的cpu执行的核心，这里传入了一个参数<code>-1</code>但由于是<code>uint64_t</code>表示，所以实际上的数值是<code>0xFFFFFFFFFFFFFFFF</code>，即持续执行，这里我们进一步的步入追踪，最终查看到<code>exec_once()</code>，他负责将pc设置成下一条指令执行的位置。</p>
<p>现在NEMU会不断的进行执行，首先它执行的便是我们的内置程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> img [] = &#123;</span><br><span class="line">  <span class="number">0x00000297</span>,  <span class="comment">// auipc t0,0</span></span><br><span class="line">  <span class="number">0x00028823</span>,  <span class="comment">// sb  zero,16(t0)</span></span><br><span class="line">  <span class="number">0x0102c503</span>,  <span class="comment">// lbu a0,16(t0)</span></span><br><span class="line">  <span class="number">0x00100073</span>,  <span class="comment">// ebreak (used as nemu_trap)</span></span><br><span class="line">  <span class="number">0xdeadbeef</span>,  <span class="comment">// some data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在NEMU中我们将<code>ebreak</code>的语义设置成，接受a0的数据作为退出状态。同时为了检测客户程序的退出，设置了以下三种状态：</p>
<ul>
<li><code>HIT GOOD TRAP</code> - 客户程序正确地结束执行</li>
<li><code>HIT BAD TRAP</code> - 客户程序错误地结束执行</li>
<li><code>ABORT</code> - 客户程序意外终止, 并未结束执行</li>
</ul>
<p>我们在nemu中使用<code>c</code>就可以获得以下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nemu: HIT GOOD TRAP at pc = 0x8000000c</span><br></pre></td></tr></table></figure>
<p>即nemu的客户程序在<code>pc = 0x8000000c</code>处成功退出。退出<code>cpu_exec()</code>之后，我们再使用<code>q</code>退出nemu程序。</p>
<h2 id="优美的退出">优美的退出</h2>
<p>我们运行NEMU后直接使用<code>q</code>会产生报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/ics2025/nemu$ make run</span><br><span class="line">/home/ylin/ics2025/nemu/build/riscv32-nemu-interpreter --log=/home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/utils/log.c:30 init_log] Log is written to /home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff]</span><br><span class="line">[src/monitor/monitor.c:51 load_img] No image is given. Use the default build-in image.</span><br><span class="line">[src/monitor/monitor.c:28 welcome] Trace: ON</span><br><span class="line">[src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig</span><br><span class="line">[src/monitor/monitor.c:32 welcome] Build time: 20:11:21, Sep 26 2025</span><br><span class="line">Welcome to riscv32-NEMU!</span><br><span class="line">For help, type &quot;help&quot;</span><br><span class="line">(nemu) q</span><br><span class="line">make: *** [/home/ylin/ics2025/nemu/scripts/native.mk:38: run] Error 1</span><br></pre></td></tr></table></figure>
<p>我们需要找出原因并解决这个问题。</p>
<p>这是<code>cmd_q</code>的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们输入q后会因为<code>sdb_mainloop</code>的判断逻辑退出到<code>nemu_main</code>执行<code>is_exit_status_bad()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_exit_status_bad</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.halt_ret == <span class="number">0</span>) ||</span><br><span class="line">    (nemu_state.state == NEMU_QUIT);</span><br><span class="line">  <span class="keyword">return</span> !good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会检测nemu的状态而决定以什么情况退出，我们之前的报错则是因为，我们没有为NEMU设置任何状态，NEMU以默认状态退出，因此返回错误。想要优雅的退出，我们只需要再退出前设置好NEMU的状态。因此我们对<code>cmd_q()</code>函数进行重写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  nemu_state.state = NEMU_QUIT;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/26/82-NJU-PA-STUDY-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/26/82-NJU-PA-STUDY-0/" class="post-title-link" itemprop="url">83:NJU_PA_STUDY(0)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-26 19:33:39 / 修改时间：20:21:55" itemprop="dateCreated datePublished" datetime="2025-09-26T19:33:39+08:00">2025-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个学期抽取一部分课余时间用来完成NJU的PA实验，争取能做多少做多少。</p>
<p>第一篇先从环境配置开始，这里我使用的程序环境是WSL+Vscode。</p>
<h1 id="pa0-getting-source-code-for-pas">PA0 Getting Source Code For
PAs</h1>
<h2 id="拉取源码">拉取源码</h2>
<p>由于我的git环境已经配置好了，所以直接在我的主目录下面<code>clone</code>文件内容就行了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 2025 git@github.com:NJU-ProjectN/ics-pa.git ics2025</span><br></pre></td></tr></table></figure>
<p>然后<code>cd ics2025</code>，以后这个目录就是项目的工程目录了。由于我不需要追踪进度，所以就不用提交信息啥的，直接进行初始化就行了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master</span><br><span class="line">bash init.sh nemu</span><br></pre></td></tr></table></figure>
<p>为了方便子项目的编译，<code>init.sh</code>会向环境变量中添加部分环境变量，这里可以通过</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $NEMU_HOME</span><br><span class="line">cd $NEMU_HOME</span><br></pre></td></tr></table></figure>
<p>来验证环境变量是否正确设置，如果没有的话，使用<code>source /.bashrc</code>来激活cd</p>
<h2 id="分支创建">分支创建</h2>
<p>现在我们需要创建一个新的分支，作为<code>pa0</code>的工作分支，之后每个阶段的PA都会单独设置一个分支，再进行合并，我们可以使用<code>git branch</code>来查看现有分支，然后我们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ git checkout -b pa0</span><br><span class="line">Switched to a new branch &#x27;pa0&#x27;</span><br><span class="line">❯ git branch</span><br><span class="line">  master</span><br><span class="line">* pa0</span><br></pre></td></tr></table></figure>
<p>从而创建并跳转到一个新的分支上，然后我们修改一下makefile（因为我们不需要跟踪进度）</p>
<h2 id="编译运行nemu">编译运行NEMU</h2>
<p>通过<code>make menuconfig</code>进行文件的编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/ics2025/nemu$ make menuconfig</span><br><span class="line">/home/ylin/ics2025/nemu/scripts/config.mk:20: Warning: .config does not exist!</span><br><span class="line">/home/ylin/ics2025/nemu/scripts/config.mk:21: To build the project, first run &#x27;make menuconfig&#x27;.</span><br><span class="line">+ CC confdata.c</span><br><span class="line">+ CC expr.c</span><br><span class="line">+ CC preprocess.c</span><br><span class="line">+ CC symbol.c</span><br><span class="line">+ CC util.c</span><br><span class="line">+ YACC build/parser.tab.h</span><br><span class="line">+ LEX build/lexer.lex.c</span><br><span class="line">+ CC build/lexer.lex.c</span><br><span class="line">+ CC build/parser.tab.c</span><br><span class="line">+ CC mconf.c</span><br><span class="line">+ CC lxdialog/inputbox.c</span><br><span class="line">+ CC lxdialog/yesno.c</span><br><span class="line">+ CC lxdialog/textbox.c</span><br><span class="line">+ CC lxdialog/checklist.c</span><br><span class="line">+ CC lxdialog/util.c</span><br><span class="line">+ CC lxdialog/menubox.c</span><br><span class="line">+ LD /home/ylin/ics2025/nemu/tools/kconfig/build/mconf</span><br><span class="line">+ CC confdata.c</span><br><span class="line">+ CC expr.c</span><br><span class="line">+ CC preprocess.c</span><br><span class="line">+ CC symbol.c</span><br><span class="line">+ CC util.c</span><br><span class="line">+ CC build/lexer.lex.c</span><br><span class="line">+ CC build/parser.tab.c</span><br><span class="line">+ CC conf.c</span><br><span class="line">+ LD /home/ylin/ics2025/nemu/tools/kconfig/build/conf</span><br><span class="line">+ CC fixdep.c</span><br><span class="line">+ LD /home/ylin/ics2025/nemu/tools/fixdep/build/fixdep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** End of the configuration.</span><br><span class="line">*** Execute &#x27;make&#x27; to start the build or try &#x27;make help&#x27;.</span><br></pre></td></tr></table></figure>
<p>实际上这是再设置<code>make</code>的配置文件，会跳出一个可视化界面，按照自己的需求选择即可，这里我选择了DEBUG的信息。第一次编译的时候有报错，缺少了几个程序，安装即可正常运行。然后<code>make</code>即可。如果编译有误，可以通过<code>make clean</code>删除内容再进行编译。</p>
<p>现在可以通过<code>make run</code>来运行这个项目，可以得到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/ics2025/nemu$ make run</span><br><span class="line">/home/ylin/ics2025/nemu/build/riscv32-nemu-interpreter --log=/home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/utils/log.c:30 init_log] Log is written to /home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff]</span><br><span class="line">[src/monitor/monitor.c:51 load_img] No image is given. Use the default build-in image.</span><br><span class="line">[src/monitor/monitor.c:28 welcome] Trace: ON</span><br><span class="line">[src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig</span><br><span class="line">[src/monitor/monitor.c:32 welcome] Build time: 20:05:51, Sep 26 2025</span><br><span class="line">Welcome to riscv32-NEMU!</span><br><span class="line">For help, type &quot;help&quot;</span><br><span class="line">[src/monitor/monitor.c:35 welcome] Exercise: Please remove me in the source code and compile NEMU again.</span><br><span class="line">riscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0&#x27; failed.</span><br><span class="line">make: *** [/home/ylin/ics2025/nemu/scripts/native.mk:38: run] Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<p>这里可以看到一段报错<code>riscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion</code>0’
failed.`，这个是实验的第一个简单测试，我们到源码处，注释掉指定的错误语句即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">  Log(<span class="string">&quot;Trace: %s&quot;</span>, MUXDEF(CONFIG_TRACE, ANSI_FMT(<span class="string">&quot;ON&quot;</span>, ANSI_FG_GREEN), ANSI_FMT(<span class="string">&quot;OFF&quot;</span>, ANSI_FG_RED)));</span><br><span class="line">  IFDEF(CONFIG_TRACE, Log(<span class="string">&quot;If trace is enabled, a log file will be generated &quot;</span></span><br><span class="line">        <span class="string">&quot;to record the trace. This may lead to a large log file. &quot;</span></span><br><span class="line">        <span class="string">&quot;If it is not necessary, you can disable it in menuconfig&quot;</span>));</span><br><span class="line">  Log(<span class="string">&quot;Build time: %s, %s&quot;</span>, __TIME__, __DATE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to %s-NEMU!\n&quot;</span>, ANSI_FMT(str(__GUEST_ISA__), ANSI_FG_YELLOW ANSI_BG_RED));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;For help, type \&quot;help\&quot;\n&quot;</span>);</span><br><span class="line"> <span class="comment">// Log(&quot;Exercise: Please remove me in the source code and compile NEMU again.&quot;);</span></span><br><span class="line"> <span class="comment">// assert(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了一个断言，让我们再运行时必定停止在这里。</p>
<p>现在我们可以正常的使用我们的程序了，同时我们也可以使用<code>make gdb</code>来进行对NEMU的调试。</p>
<h1 id="pa1-开天辟地的篇章">PA1 开天辟地的篇章</h1>
<p>计算机的本质就是状态机，从CPU出发，我们可以简单的将CPU的行为总结为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的计算机实际上是从一个初始状态开始（就是硬件所指定的通电后的复位状态），计算机有一个程序计数器，始终指向下一段要执行的指令地址，当我们从地址取出要执行的指令，当我们对指令进行执行。程序的状态就发生了改变，我们称之为状态的迁移。</p>
<p>所以计算机的一切行为对我们而言都是可溯源的，我们只需要理解状态机的规则，与进行的动作，我们就可以还原任意时刻计算机内存的状态。我们就可以知道每一个动作背后的原理和现象。</p>
<p>PA实验则是通过对NEMU的设计，还原和理解真实计算机的各种功能和实现。所以对于计算机系统的学习是十分有帮助的。希望自己能坚持做下去吧。最近还挺忙的，但还是要加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/30/81-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/30/81-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-3/" class="post-title-link" itemprop="url">81:虚拟内存(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-30 09:11:03" itemprop="dateCreated datePublished" datetime="2025-08-30T09:11:03+08:00">2025-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-18 00:09:53" itemprop="dateModified" datetime="2025-09-18T00:09:53+08:00">2025-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">虚拟内存</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇中我们研究了虚拟内存在理想状态下的工作模式，现在我们要结合实际案例，来进一步了解虚拟内存在具体环境下是怎么工作的：</p>
<h2 id="intel-core7linux内存系统">Intel Core7/Linux内存系统</h2>
<h3 id="core-i7地址翻译">Core i7地址翻译</h3>
<p>我们的系统是一个运行Linux的Intel Core
i7。下图是其处理器的一个封装结构：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/rs3UFV2QJAC6Nxc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>包括四个核，一个大的所有核共享的L3高速缓存，以及一个DDR3内存控制器。每个核中都有L1L2的高速缓存，还有TLB条目缓存。其中L1、L2、L3高速缓存都是物理寻址的，块大小为64字节。L1和L2是8路组相联，L3是16路组相联。页大小可以在启动时配置为4KB或4MB大小。这里Linux使用的是4KB的页。</p>
<p>下图则展示了Core i7地址翻译的概况：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/twyMrV1jNqslhf4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>由于不同层级的页表中存储的条目不同，所以对于第一级、第二级、第三级的条目格式和第四级的条目格式。其地址字段结构略有不同：</p>
<p>对于第一级、第二级、第三级的条目格式。当P=1时（Linux中总是P=1），地址字段包含一个40位的物理页号（PPN），它指向下一级页表的开始处。（注：由于物理页面是4KB对齐的，所以起始地址应该是4096的倍数）：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/sBxqL1nA3oyClkv.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于第四级页表中条目的格式。当P=1，地址字段包括一个40位的PPN，指向物理内存中某一页的基地址。同样的，需要4KB对齐：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/j98GbwsZrY7km1J.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以看到，PTE有三个权限位，用来控制对页的访问：</p>
<ul>
<li><code>R/W</code>位确定页的内容是可读的还是只读的</li>
<li><code>U/S</code>位确定是否能在用户模式中访问该页，从而保护内核中的代码和数据不被用户程序访问</li>
<li><code>XD</code>位用来禁止从某些内存页取指令。通过限制只能执行只读代码段，从而避免溢出攻击</li>
</ul>
<p>下图则反映了通过四级页表将虚拟地址翻译成物理地址的过程：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/E6mqlPLi8I2FT4j.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>通常情况下，我们将地址翻译的分为两步：</p>
<ol type="1">
<li>MMU将虚拟地址翻译成物理地址</li>
<li>将物理地址传送到L1高速缓存</li>
</ol>
<p>然而，实际的硬件实现优化了地址翻译的过程，允许这两个步骤一定程度上的重叠进行。例如Core
i7系统上的一个虚拟地址有12位的VPO，这些位和相应的物理地址的PPO相同。且有八路相联的、64个组和大小为63字节的缓存块的物理寻址的L1高速缓存。</p>
<p>因此每个物理地址有6个缓存偏移位和6个索引位。这12个位刚好和VPO相对应。当CPU翻译一个虚拟地址的时候，它发送VPN到MMU，发送VPO到L1。当MMU查找PTE的时候，L1高速缓存正在利用VPO位查找相应的组合块偏移，读出组中的8个标记的数据字。当MMU得到PPN时，缓存可以直接对这8个标记进行匹配。这样就极大程度的优化了地址翻译的过程。</p>
<h3 id="linux虚拟内存系统">Linux虚拟内存系统</h3>
<p>我们现在需要对LInux的虚拟内存系统做一个简单的描述，以能够大致的了解一个实际的操作系统是怎么组织虚拟内存，并处理缺页的。</p>
<p>我们知道linux为每个进程维护了一个单独的虚拟地址空间，如下图所示：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/4M9ksL18UH5himO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在此之前我们从来没有讨论过，内核部分的虚拟内存，这一部分位于用户栈之上，现在我们需要进一步的去了解它。</p>
<p>内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存中的某些区域被映射到所有进程共享的物理页面。例如，每个进程都共享内核的代码和数据结构。同时，内核将一片连续的虚拟地址空间映射到一片相同大小的物理地址空间，从而实现对虚拟内存的线性直接映射。这样对指定虚拟地址空间的访问，就可以通过固定的偏移映射来进行访问，而无需页表查找的模式。</p>
<p>内核虚拟内存的的其他区域则存储着每个进程都不相同的数据。如页表、内核在进程的上下文中执行代码时所用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h4 id="虚拟内存区域">虚拟内存区域</h4>
<p>Linux将虚拟内存组织成一些区域（也叫做段）。区域实际上就是一片连续的已分配的虚拟内存页，往往不同的区域负责不同的内容。例如代码段、数据段、堆、共享库段、用户栈都是不同的区域。大大小小的区域有不同的意义，所以每个存在的虚拟页面一定是属于某个区域的。区域的概念使得虚拟地址空间之间可以有间隙，且不用记录（不用分配）那些不被使用的虚拟内核空间。</p>
<p>下图就是一个用于记录进程中虚拟内存区域的内核数据结构：</p>
<figure>
<img src="https://s2.loli.net/2025/09/01/DcdnCMRAbKQrma2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>内核为系统中的每个进程维护了一个独立的任务结构(task_struct)，任务结构中的元素包含或者指向内核运行这个进程所需要的所有信息（PID，指向用户栈的指针，可执行目标文件的名字，程序计数器…）</p>
<p><code>task_struct</code>中的一个条目指向mm_struct，它描述了虚拟内存的当前状态。其中有两个我们感兴趣的字段：</p>
<ul>
<li>pgd：指向第一级页表的基址，运行时该值被存放在CR3控制寄存器中</li>
<li>mmap指向一个<code>vm_area_structs</code>（区域结构）的链表，其中每个<code>vm_area_structs</code>都描述了当前虚拟地址空间的一个区域。一个具体的区域结构包含以下字段：
<ul>
<li>vm_start：指向这个区域的起始处</li>
<li>vm_end：指向这个区域的结束处</li>
<li>vm_prot：描述这个区域内包含的所有页的读写许可权限</li>
<li>vm_flags：描述这个区域内的页面是与其他进程共享的，还是私有的（以及一些其他信息）</li>
<li>vm_next：指向链表中的下一个区域结构</li>
</ul></li>
</ul>
<h4 id="linux缺页异常处理">Linux缺页异常处理</h4>
<p>假设MMU在翻译某个虚拟地址A的时候，触发了一个缺页。这个异常会触发缺页处理程序，处理程序会执行下面的步骤：</p>
<ul>
<li><p><strong>虚拟地址A是否合法？</strong></p>
<p>换句话说就是A是否在某个区域结构定义的区域内吗？缺页处理程序会搜索区域结构的链表，把和每个区域结构中的<code>vm_start</code>和<code>vm_end</code>作比较。如果该指令不合法，就会触发一个段错误，从而终止这个进程。既图中”1”</p></li>
<li><p><strong>试图进行的内存访问是否合法？</strong></p>
<p>换句话说就是进程是否有读、写或者执行这个区域内页面的权限？如果试图进行的操作是违法的，那么缺页处理程序就会触发一个保护异常，从而终止这个进程。既图中”2”</p></li>
<li><p><strong>正常缺页</strong></p>
<p>排除以上的可能，那么这个缺页就是对合法的虚拟地址进行合法的操作造成的。处理程序会选择有一个牺牲页面，如果这个这个牺牲页面被修改过，就将其交换出去，换入新的页面并更新页表。当缺页处理程序返回时，重新启动引起缺页的指令，这次便可以正常的进行。既图中”3”</p></li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/09/01/PWfUsgJ1Gbwu395.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="内存映射">内存映射</h2>
<p>Linux通过将一个虚拟内存区域和一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程，我们就称之为<strong>内存映射</strong>。虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li><p><strong>Linux文件系统中的普通文件</strong></p>
<p>一个区域可以映射到一个普通的磁盘文件的连续部分。文件区被分成页大小的片，每一片的包含一个虚拟页面的初始内容。由于系统按需进行页面调度，所以这些虚拟页面美亚由实际交换进入物理内存，直到CPU第一次引用这个页面时，才会调入。对于区域大小大于文件的部分，用0填充余下部分。</p></li>
<li><p><strong>匿名文件</strong></p>
<p>一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，内容全部为二进制0填充。CPU第一次引用这样一个区域内的虚拟页面时，内核在物理内存中查找，如果有空闲的物理页框，就用二进制0填充初始化，再建立虚拟页到物理页的映射；如果没有，就挑选一个合适的牺牲页，如果这个页面被修改过，就将其内容写回交换空间，并用二进制0覆盖这个物理页框，建立新的映射关系</p></li>
</ul>
<p>这里我们还要知道，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换空间(swap
file)之间换来换去。它相当于一个物理内存的页面的一个临时存储处，被替换的牺牲页被暂时的保存在这里。因此，交换空间限制着当前运行的进程能够分配的虚拟页面的总数。</p>
<h3 id="共享对象">共享对象</h3>
<p>本章暂时结束。之后再回头搞一下，接下来要做一些实验和一些项目了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/28/80-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/28/80-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-2/" class="post-title-link" itemprop="url">80:虚拟内存(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-28 12:30:27" itemprop="dateCreated datePublished" datetime="2025-08-28T12:30:27+08:00">2025-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-29 13:44:39" itemprop="dateModified" datetime="2025-08-29T13:44:39+08:00">2025-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">虚拟内存</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们已经学习了虚拟内存的作用和虚拟内存的基本使用过程，为了进一步的深入的理解虚拟内存的机制，我们需要要深入理解虚拟内存的基本原理。</p>
<h2 id="地址翻译">地址翻译</h2>
<p>现在我们将从底层除出发，理解硬件在虚拟内存中的角色。为了简化之后的说明，这里提前展示我们所要用到的符号以参考：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/w1YmzSBy2MpVWer.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实际上，地址翻译就是一个N元素的虚拟地址空间(VAS)中的元素和一个M元素的物理地址空间(PAS)中元素的映射：
<span class="math display">$$
\begin{align*}
MAP&amp;:VAS \to PAS \cup \varnothing \\
MAP(A) &amp;= \begin{cases}
A' \text{ 如果虚拟地址A处的数据在PAS的物理地址A'处} \\
\varnothing \text{ 如果虚拟地址A处的数据不在物理内存中}
\end{cases}
\end{align*}
$$</span> 下图演示了MMU如何利用页表来实现这种映射：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/tpHq1JOUC3rojW6.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>控制寄存器——页表基址寄存器（PTBR）指向当前页表。对于n位的虚拟地址，包含两个部分：</p>
<ul>
<li>一个p位的虚拟页面偏移(VPO)</li>
<li>一个n-p位的虚拟页号(VPN)，作为页表的索引</li>
</ul>
<p>MMU通过VPN选择对应的PTE，同时PTE中的内容实际上就是物理页号(PPN)，这样就可以通过虚拟页号访问到对应的物理页。至于偏移量，由于虚拟页和物理页的大小相同，所以虚拟页偏移量和物理页偏移量(PPO)是是相同的。</p>
<p>现在我们可以分析CPU硬件的执行步骤了：</p>
<p>当页面命中时：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/WqiRlNCVASMmg6J.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li>处理器生成一个虚拟地址VA并发送到MMU中</li>
<li>MMU生成PTE地址(将VA拆分成VPN和VPO，VPN作为PTE地址)，从内存中请求它</li>
<li>内存向MMU返回PTE</li>
<li>MMU构造物理地址(返回的PTE就是PPN，物理地址=PPN+(PPO=VPO))发送给内存</li>
<li>内存通过物理地址找到数据字节返回给CPU</li>
</ol>
<p>当缺页时：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/vKj3YZi5JsBTfwM.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li>前三步同上</li>
<li>返回的PTE有效位为0，MMU触发异常，CPU控制传递到内核中的缺页异常处理程序</li>
<li>缺页处理程序调入新的页面，并更新内存中的PTE</li>
<li>缺页处理程序返回原来的进程，再次执行导致缺页的指令。此时页面命中</li>
</ol>
<h3 id="结合高速缓存和虚拟内存">结合高速缓存和虚拟内存</h3>
<p>我们的系统一般既有虚拟内存的机制又有SRAM高速缓存，那么对于SRAM高速缓存，我们是应该使用物理地址访问还是虚拟地址访问呢？下图是一个将其结合起来的方案：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/2tZcq38gRUAPN9E.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们使用物理寻址的方案，先将VA转换为PTEA然后在L1中检索，如果命中就直接返回PTE，未命中则再取一次。拿到PTE后构造出PA再对L1进行检索，如果命中就返回PA，未命中就再取一次。L1的存在可以帮我们节省数据传送的时间。页表条目本质上也是数据字，所以也可以被缓存在L1中。</p>
<h3 id="利用tlb加速地址翻译">利用TLB加速地址翻译</h3>
<p>CPU每次产生一个虚拟地址都需要查阅一个PTE，以便于将虚拟地址进行翻译。每次从内存取数据都需要花费几十到几百的周期，为了解决这个问题，我们引入了高速缓存，在命中的情况下，将开销降到了1到2周期。为了尽可能的减少开销，我们在MMU中引入了一个关于PTE的小缓存，即翻译后备缓冲器(TLB)</p>
<p>TLB是一个小的缓存，其每一行都保存有一个由单个PTE组成的块。其结构如下：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/ldcVmZgx9f53LaA.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>用于组选择和行匹配的索引和标记字段都是从VPN提取出来的。如果TLB有<code>T=2^t</code>个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的（用来行匹配）。</p>
<p>下图展示了TLB的工作过程：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/hkUIDiX5fcmr1tG.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当TLB命中时：</p>
<ul>
<li>CPU产生VA</li>
<li>MMU从TLB中取出相应的PTE</li>
<li>MMU构造物理地址，发送到缓存</li>
<li>缓存返回数据字到CPU</li>
</ul>
<p>当不命中时，MMU必须从L1中取出相应的PTE。新取出的PTE会覆盖TLB中的一个条目。</p>
<p>由于所有的地址翻译步骤都是在MMU中完成的，所以速度很快。</p>
<h3 id="多级页表">多级页表</h3>
<p>到此为止，我们一直假设系统只使用一个单独的页表来进行地址翻译。如果我们有一个32位的地址空间、4KB的页面和一个4字节的PTE，那么即使我们只使用虚拟空间中很小的一部分，我们也需要一个4MB的页表驻留在内存中。对于64位的地址空间，这个问题更加明显，我们甚至需要4PB的页表常驻内存，这荒谬。为了解决这个问题，我们引入多级页表，用过层次结构来压缩。</p>
<p>我们以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/B1f5t2nGwiJ9a6D.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于32位的地址空间，我们有4GB的地址空间，空间被分为4KB的页，每个页有一个4字节的页表条目。假设此时，虚拟空间有以下形式：内存的前2K个页面被分配给了代码和数据，接下来的6K个页面没有被分配，再接下里的1K个页面中有1023个未分配的页和一个分配作为栈的页面。</p>
<p>我们用一级页表中的每个PTE负责映射虚拟空间中一个4MB的片，这里的每一片都是由1024个连续的页面组成的。所以我们只需要1024个一级页表条目就可以指向4G大小的片。</p>
<p>如果片i中的每个页面都没有被分配，那么对应的一级页表条目i就是空的。反之，如果片i中至少有一个页是分配了的，那么一级PTEi就需要指向有一个二级页表的基址。每个二级页表的结构和一级页表都是一样的。</p>
<p>这种方法减少了内存的需求：</p>
<ul>
<li>如果一级页表中的一个PTE是空的，那么对应的二级页表都不需要要存在，这样极大的节省了内存空间，因为虚拟地址空间大部分时候都是未分配的</li>
<li>只有一级页表才需要总是在主存中，VM系统在需要时创建、页面调入或调出二级表，进一步减少了主存的压力，只有常用的二级表才需要缓存在主存中</li>
</ul>
<p>对于一个k级的页表层次结构的地址翻译。虚拟地址被分隔成k个VPN和一个VPO:</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/eEwhlUGs7bfCap9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>每个VPNi都是一个到第i个级页表的索引，第j级的每个页表中都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或一个磁盘块的地址。最终构造物理地址。</p>
<p>为了构造物理地址，MMU必须访问k个PTE。看上去开销很大，实际上TLB在这里会起到重要的作用，通过将不同层次上页表的PTE缓存起来，效率很不错。</p>
<h3 id="端到端的地址翻译">端到端的地址翻译</h3>
<p>讲了很多原理和过程，只有自己动手实践才是最真实的，我们用下面的的环境——在一个有TLB和L1
d-cache的系统上：</p>
<ul>
<li>内存是按字节寻址的</li>
<li>内存访问是针对1字节的字</li>
<li>虚拟地址是14为长的(n=14)</li>
<li>物理地址是12位长的(m=12)</li>
<li>页面大小为64字节(P=64)</li>
<li>TLB是四路组相联的，共有16个条目</li>
<li>L1 d-cache是物理寻址、直接映射的，行大小4个字节16个组</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/08/29/gFIJBoKmOy6QkHt.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>然后是对于TLB和高速缓存，访问这些设备时，我们通过以下方法对位进行划分：</p>
<ul>
<li><strong>TLB</strong>
因为TLB有四个组，所以VPN的低2位用来做TLBI，高6位作为TLBT</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/08/29/DspQodRxmIbCegv.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><strong>页表</strong>
这是一个单级设计，一共有256个页面，这里我们只关注前16个。为了方便，我们直接令VPN来标识PTE</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/08/29/VwlgKTdEzW3M4GX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><strong>高速缓存</strong>
每个块都是4字节，所以用低2位作为块偏移(CO)。因为有16组，所以接下来的4位做组索引(CI)。剩下的6位做标记(CT)</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/08/29/CLomsbBcd8OekDW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>现在，假设CPU执行一条读地址<code>0x3d4</code>处字节的加载指令会发生什么？</p>
<p>首先MMU会对VA进行解析，并在TLB中查找是否有缓存的PTE:</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/Bt3SX2Yd567NpIx.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们根据索引找到，获取了TLB中缓存的PPN<code>0x0D</code>，从而和VPO构造出物理地址<code>0x0354</code>。现在MMU将物理地址发送到缓存。我们对地址进行解析，查看L1是否缓存了我们需要的数据：</p>
<figure>
<img src="https://s2.loli.net/2025/08/29/4uHY1ncCbmp8LZP.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们根据标记，行索引，块偏移，得到了数据<code>0x36</code>，并将其返回到MMU，随后MMU又将数据返回到CPU。至此，我们就完成了一次虚拟内存的使用。</p>
<p>当然以上的演示，都是理想状态下简化的情况。实际上我们可能会遇到不命中的问题。如果TLB不命中，那么MMU必须从页表PTE中取出PPN。如果得到的PTE是无效的，那么就产生缺页，那么就调用缺页异常处理程序；如果是有效的，但是缓存不命中。那么则又需要进行取用…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/27/79-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/27/79-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1/" class="post-title-link" itemprop="url">79:虚拟内存(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-27 16:50:33" itemprop="dateCreated datePublished" datetime="2025-08-27T16:50:33+08:00">2025-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-28 11:14:28" itemprop="dateModified" datetime="2025-08-28T11:14:28+08:00">2025-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">虚拟内存</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总是听到诸如页表，分页机制一类的词汇，听起来让人感到十分的复杂。实际上这些都是涉及到虚拟内存相关的只是。一直以来对这一部分的知识都是望而生畏，现在好好来理解一下它：</p>
<h2 id="物理和虚拟寻址">物理和虚拟寻址</h2>
<p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的<strong>物理地址</strong>，物理地址从0开始依次设置。这是最简单自然的结构，我们把CPU以这个结构用来访问地址的方式称为<strong>物理寻址</strong>。早期的计算机和一些数字处理器和嵌入式设备仍然使用这种方式，</p>
<p>现代处理器则是使用一种被称为<strong>虚拟寻址</strong>的方式来进行寻址。使用虚拟寻址，CPU会生成一个虚拟地址(VA)来访问主存，VA被送到内存之前会先转换为适当的物理地址，这个过程叫做<strong>地址翻译</strong>。有一个专门的硬件单元来完成这个任务——<strong>内存管理单元</strong>(MMU)。原理是利用存放在主存中的查询表来动态翻译虚拟地址，这个表中的内容由操作系统管理。</p>
<h2 id="地址空间">地址空间</h2>
<p>地址空间是非负整数地址的有序集合。如果地址空间中的整数时连续的，我们说它是一个<strong>线性地址空间</strong>，我们假定之后用到的所有地址空间都是线性的。在一个带虚拟内存的系统中，CPU从有一个有N=2^n个地址的地址空间中生成虚拟地址，则这个地址口空间称为<strong>虚拟地址空间</strong>。</p>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。对于一个包含N=2^n个地址的虚拟地址空间，我们可以将其叫做为一个n位的地址空间。一个系统还带有一个物理地址空间，对应于系统中的物理内存的M个字节。</p>
<p>地址空间的概念实际上区分了两个概念：</p>
<ul>
<li>数据对象(字节)</li>
<li>属性(地址)</li>
</ul>
<p>所以我们应该意识到数据对象实际上可以有多个地址，只不过每一个地址都选自一个不同的地址空间，这就是我们虚拟空间所用到的概念。例如主存中的每一个字节都有有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="虚拟内存作为缓存工具">虚拟内存作为缓存工具</h2>
<p>虚拟地址实际上就是一个由存放在磁盘上的N个连续的字节大小的单元组成数组，每一个字节都有着一个对应的虚拟地址，作为对这个数组的索引。磁盘上数组的内容被缓存在主存中。和其他的缓存一样，磁盘上的数据被分隔成块，这些快作为磁盘和主存之间的传输单元。</p>
<p>VM系统将虚拟内存分割为<strong>虚拟页</strong>的大小固定的块，每个虚拟页的大小为<code>P=2^p</code>字节。物理内存也被分隔为同样大小的<strong>物理页</strong>，也称页帧。</p>
<p>在任意时刻，虚拟页处于以下中的一种状态：</p>
<ul>
<li><strong>未分配：</strong>VM系统还没有创建的页。未分配的块不会有任何数据关联，不占用磁盘空间</li>
<li><strong>已缓存：</strong>当前已缓存在物理内存中的已分配页</li>
<li><strong>已分配：</strong>未缓存在物理内存中的已分配页</li>
</ul>
<h3 id="页表">页表</h3>
<p>在这里需要用到DRAM和SRAM的关系，可以查看存储器层次架构进行回顾。</p>
<p>和任何缓存一样，VM系统需要要一种方法来判定一个虚拟页是否被缓存在物理内存中的某个地方。如果命中，怎么确定这个虚拟页被存放在那个物理页中。如果不命中，系统需要判断虚拟页存放在磁盘的哪个位置，并在物理内存中选择有一个牺牲页，将虚拟页复制到这里，替换这个牺牲页。</p>
<p>通过操作系统软件、MMU和存放在物理内存中的页表，软硬联合，从而将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为一个物理地址的时候，都会读取页表。操作系统则负责维护页表中的内容，在磁盘和主存间来回传送页。页表的结构大致如下：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/nIDLxybfH6TXhq4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们认识一下页表的基本数据结构，页表就是一个页表条目(PTE)的数组。虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE（也就是说PTE的大小是固定的）。根据上面的这个简化模型，每个PTE实际上是由一个有效位和一个n位地址字段组成的：</p>
<ul>
<li>有效位表明该虚拟也当前是否被缓存在主存中。</li>
<li>n位地址字段，在有效位被设置的情况下，表示主存中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么这个地址指向该虚拟页在磁盘中的起始位置。</li>
</ul>
<p>在上图中我们就可以看到虚拟页的三种状态：未分配、未缓存、已缓存。</p>
<h3 id="页命中">页命中</h3>
<p>当CPU想要读取包含在VP2中的虚拟内存的一个字时，地址翻译硬件会将虚拟地址作为一个索引来定位PTE2，然后再页表（内存）中读取它。因为设置了有效位，地址翻译硬件就会知道VP2被缓存在内存中，然后就会使用PTE中存储的物理内存地址，构造出这个字的物理地址。</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/LNcFv8UT5wEyRVn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="缺页">缺页</h3>
<p>缺页实际上就是缓存不命中，同上图。CPU引用了VP3中的一个字，地址翻译硬件根据有效位发现VP3并没有被缓存在内存中，于是触发一个缺页异常。这个异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。程序将牺牲页复制回硬盘中，并将VP3覆盖牺牲页。并修改页表中它们的状态。然后返回，并将导致缺页的虚拟地址重新发送给地址翻译硬件，此时页命中，可以被正确处理：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/E3GubmVq1HlvFWY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个在磁盘和内存之间传送页的活动叫做<strong>页面调度</strong>，仅在不命中的情况下才进行调度的策略是<strong>按需页面调度</strong>，我们之后都会使用这个策略。</p>
<h3 id="分配页面">分配页面</h3>
<figure>
<img src="https://s2.loli.net/2025/08/28/eXsFdkTt5cBQ68D.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个过程展示了当操作系统分配一个新的虚拟内存页时，对我们的示例页表产生的影响。在这个过程中，系统在磁盘上创建了一个空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p>
<h3 id="局部性分析">局部性分析</h3>
<p>对于虚拟内存的策略，我们可能会认为这是一个效率极低的方案，因为它的不命中惩罚很大。但是实际上，它有着良好的<strong>局部性</strong>。局部性保证了，在任意时刻中，程序将趋于一个较小的活动页面上工作，例如空间局部性，较大的页空间确保了很好的空间局部性，因为对于数据结构，程序是按序访问的；对于时间局部性，一段内存往往会被反复利用，所以有着良好的时间局部性。</p>
<p>当然如果出现了工作集大小超出内存大小的情况时，程序可能会发生<strong>抖动</strong>，页面会不停的换进换出，带来严重的不命中开销。</p>
<h2 id="虚拟内存作为内存管理的工具">虚拟内存作为内存管理的工具</h2>
<p>虚拟内存不仅有着很好的缓存性能，同时它也很好的简化了内存管理，为我们提供了一个很好的内存保护机制。</p>
<p>实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟空间，下图很好的展示了这一点：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/l57NgTqRbkWKtz3.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>注意，这里可以看到多个虚拟页面实际上是可以映射到同一个共享物理页面上。</p>
<p>通过按需页面调度和独立的虚拟地址空间的结合，系统对内存的使用和管理被极大的简化，VM系统简化了链接和加载、代码和数据共享、以及应用程序的内存分配…</p>
<h3 id="简化链接">简化链接</h3>
<p>独立的地址空间也允许每个进程的内存映像使用相同的基本格式，而不用考虑代码和数据实际上被存储在哪里。这样的一致性简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/mxfuyZFswWo1kbQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="简化加载">简化加载</h3>
<p>虚拟内存简化了向内存中加载可执行文件和共享对象文件的过程。要把目标文件中<code>.text</code>和<code>.data</code>节加载到一个新创建的进程中，Linux加载器会为代码段和数据段分配虚拟页，然后将其标为无效的（即未缓存）。而不是将其进行缓存，只有当页被引用到时，虚拟内存会按需调度这些页面。</p>
<p>将一组连续的虚拟页映射到任意一个文件的任意位置的表示法叫做<strong>内存映射</strong>我们会在之后涉及这些内容。</p>
<h3 id="简化共享">简化共享</h3>
<p>一般而言，每个进程都有自己私有的代码，数据，堆栈等区域，这个其他进程是不共享的。操作系统为每个进程提供页表，将相应的虚拟页映射到不同的物理页面。也就是说，对于不同进程来说，尽管是同一个虚拟地址，但是实际上映射的是不同的物理地址。极大程度上简化了进程间私有的问题。</p>
<p>当然有时候进程间有也需要共享代码和数据，例如每个进程都调用相同的操作系统内核代码，操作系统会将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是为每个进程都分配一个副本。</p>
<h3 id="简化内存分配">简化内存分配</h3>
<p>虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求有一个额外的堆空间时，操作系统只需要分配适当的连续的虚拟内存页面，并将其映射到物理内存中的物理页面就行了。通过页表，操作系统也不用分配连续的物理页。使得页面可以随机的分布在物理内存中，提高了碎片空间的可用性。</p>
<h2 id="虚拟内存作为内存保护的工具">虚拟内存作为内存保护的工具</h2>
<p>操作系统需要有手段来控制对内存系统的访问，不应该允许用户进程对其只读代码段进行修改，也不应该允许它修改内核中的代码和数据结构，不应该允许它读写其他进程的私有内存或是修改和其他进程共享的虚拟原页面。而虚拟内存能够很好的实现这个机制：</p>
<p>当每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，我们可以通过有效位来判断这个页面的状态。我们也可以通过添加额外的许可页来控制对一个虚拟页面内容的访问。</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/MYLDidmhXo6Kgtc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>例如图中的，SUP位表示进程是否必须在内核模式下才能访问此页。READ和WRITE位则控制对原页面的读写访问。不同进程的页表中对同一个页的访问权是不同的，以此可以实现对进程内存访问的控制。</p>
<p>如果一条指令违反了这些许可条件，那么CPU就会触发保护故障，将控制传递给异常处理程序。LInux
Shell一般将这个异常报告为<code>Segmentation fault</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">205k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:26</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
