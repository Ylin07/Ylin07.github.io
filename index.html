<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/12/00-%E9%A6%96%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/12/00-%E9%A6%96%E9%A1%B5/" class="post-title-link" itemprop="url">Ylin's Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-12 14:53:29" itemprop="dateCreated datePublished" datetime="2025-03-12T14:53:29+08:00">2025-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-07 13:29:20" itemprop="dateModified" datetime="2025-05-07T13:29:20+08:00">2025-05-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="你好呀">你好呀！</h1>
<h1 id="这里记录我的学习经历和内容">这里记录我的学习经历和内容</h1>
<h1 id="希望能够帮到你们">希望能够帮到你们</h1>
<h1 id="section">: )</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">96:十一月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-16 16:54:07 / 修改时间：17:10:36" itemprop="dateCreated datePublished" datetime="2025-11-16T16:54:07+08:00">2025-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">日常总结</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>928</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>十一月份已经过去了一半。回顾这个月我都做了什么，做到了什么呢？仔细一想是没有的，感觉时间过的好快，转眼间就过去了大半个学期，自己也是没什么收获，定下的很多目标都没有做到。</p>
<p>马上就要期中考试了，我希望能在各科都拿到一个比较好的成绩吧，因为这个学期对我的绩点来说是十分重要的。所以一定要好好加油，尤其是408相关的课程，一定要好好学，不能只是满足于书上的内容，不仅要掌握概念，也要会做题。要做好考研的准备吧，因为推免资格对我而言还是有点困难的，所以一定要好好加油。</p>
<p>这个月接触到了各种语言吧，学的很杂，接触到了Lua和他的游戏开发引擎，我之前说过想做一个游戏，但是思路上仍然是一头雾水，做一个什么样的游戏呢，要做哪些内容呢？我一点idea也没有，所以只能慢慢积累了，还有一些游戏开发相关的技术。所以我选择去了解一下星露谷物语的mod制作，它是用C#进行编写的，语法结构和Java差不多，所以我勉强能看懂一些，但是对于整个项目结构一点也不够了解。</p>
<p>我发现自己总是半途而废，我经常会突然想做什么，但是没办法一直做下去，我感觉要做的事情太多了，我不知道该怎么安排过来，所以也比较晕头转向的。接下来的一个月里，我打算好好夯实一下课内的知识吧，比如操作系统和数据结构，目前学习的过程中也明显感受到了清晰的需求。争取在这个学期把王道的课程也看掉一部分，感觉他讲的还是十分详细的。然后是概率论和离散数学，我也打算好好学一下了，每天坚持做一点题目，因为到现在为止，我对这两门科目都是不太了解。</p>
<p>还有的就是密码学 信息安全基础
程序设计一类的课程了，要想办法把平时分搞高一点，争取一下满绩吧。拉一拉我上上个学期拖得后腿。我发现密码学的很多知识还是比较有用的，因为会涉及到一些简单的数论和密码学体制。我以前总是抗拒听老师的课，但是其实我自己也不知道要做什么，何妨不听一听呢。</p>
<p>然后感觉最近心态好了很多吧，平时不会想那么多了。以后有空的话我也想试试出去旅游，然后玩一点剧情类的游戏。有空的话想拍一点游戏视频。尝试各种各样的事情。我想自己的人生开阔一点，可是我总是半途而废，总是做不到，但是既然有这样的想法就试一试吧。希望未来会越来越好，有很多开心的事在等着我。</p>
<p>我也想坚持锻炼身体，希望能健健康康的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/15/95-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/15/95-%E6%A0%91/" class="post-title-link" itemprop="url">95:树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-15 16:03:54" itemprop="dateCreated datePublished" datetime="2025-11-15T16:03:54+08:00">2025-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-16 16:44:14" itemprop="dateModified" datetime="2025-11-16T16:44:14+08:00">2025-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打算系统性的学一下数据结构与算法，这个就相当于笔记做一下记录了。 #
树</p>
<h2 id="二叉树">二叉树</h2>
<p>二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。我们可以用以下数据结构表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里每个节点都有两个引用，分别为左右子节点，中间的节点为这两个节点的父节点。左右子树的概念也可以类推。<strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。</strong></p>
<h3 id="二叉树常用的术语">二叉树常用的术语</h3>
<p>二叉树中的性质较为复杂，所以我们需要记住许多相关的术语：</p>
<ul>
<li>根节点：位于二叉树顶层的节点，没有父节点。</li>
<li>叶节点：没有子节点的节点，其两个指针均指向 None</li>
<li>边：连接两个节点的线段，即节点引用（指针）</li>
<li>节点所在的层：从顶至底递增，根节点所在层为1。</li>
<li>节点的度：节点的子节点的数量。在二叉树中，度的取值范围是0、1、2。</li>
<li>二叉树的高度：从根节点到最远叶节点所经过的边的数量</li>
<li>节点的深度：从根节点到该节点所经过的边的数量。</li>
<li>节点的高度：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/15/79N3evPGgUXx6fw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的基本操作">二叉树的基本操作</h3>
<ol type="1">
<li><strong>初始化二叉树</strong></li>
</ol>
<p>​ 初始化节点，并构造引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode* n1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode* n2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode* n3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode* n4 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n5 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    n1-&gt;left = n2;</span><br><span class="line">    n1-&gt;right = n3;</span><br><span class="line">    n2-&gt;left = n4;</span><br><span class="line">    n2-&gt;right = n5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入与删除节点</strong></li>
</ol>
<p>​ 二叉树中的插入与删除节点可以通过修改指针实现，效果见下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/OBCUobELsv2yVSk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的类型">二叉树的类型</h3>
<h4 id="完美二叉树">完美二叉树</h4>
<p>完美二叉树的所有层的节点都被完全填满。且在完美二叉树中，叶节点的度为0，其余所有节点的度都为2；若树的高度为ℎ，则节点总数为2ℎ+1−1，呈现标准的指数级关系：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/wm5xDqf234QTkIc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>关于完美二叉树，我们需要注意到它的几个性质：</p>
<ul>
<li><strong>第i层的节点数量：</strong> <span
class="math inline">2<sup><em>i</em> − 1</sup></span></li>
<li><strong>高度为h的树的叶节点数量：</strong><span
class="math inline">2<sup><em>h</em></sup></span></li>
<li><strong>高度为h的树的节点总数：</strong> <span
class="math inline">2<sup><em>h</em> + 1</sup> − 1</span></li>
<li><strong>节点总数为n的树的高度：</strong><span
class="math inline"><em>l</em><em>o</em><em>g</em><sub>2</sub>(<em>n</em> + 1) − 1</span></li>
</ul>
<h4 id="完全二叉树">完全二叉树</h4>
<p>完全二叉树只有最底层的节点未被填满，且最底层的节点尽量靠左边。</p>
<p>注：完美二叉树是一种特殊的完全二叉树</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/tMZBKs3xRLaXTcu.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="完满二叉树">完满二叉树</h4>
<p>完满二叉树除了叶子节点之外，其余所有节点都有两个子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/LoBGgVvxW4miF7N.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="平衡二叉树">平衡二叉树</h4>
<p>平衡二叉树中的任意节点的左子树和右子树的高度之差的绝对值不超过1，<code>|左子树高度-右子树高度|&lt;=1</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/15/Ev6t13Msx24lpIo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="二叉树遍历">二叉树遍历</h2>
<p>常见的二叉树遍历有：层序遍历、前序遍历、中序遍历和后序遍历</p>
<h3 id="层序遍历">层序遍历</h3>
<p>层序遍历是从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。这种遍历方式本质上属于广度优先遍历，我们也称之为广度优先搜索：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/xAbY8fXjeuOtnRQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;		<span class="comment">// 用于存放遍历序列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();			<span class="comment">// 将需要处理的节点出列</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前中后序遍历">前中后序遍历</h3>
<p>相应的这种遍历方式实际上是一种深度优先的遍历，我们称之为深度有限的搜索。这里我们有三种不同的遍历顺序，我们可以通过简单的递归来实现，具体实现如下。就不做过多的说明，因为很直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pastOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    pastOrder(root-&gt;left);</span><br><span class="line">    pastOrder(root-&gt;right);    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的数组表示">二叉树的数组表示</h2>
<p>我们先前对二叉树的实现是通过链表进行实现的，节点之间则通过指针连接。但是实际上我们也可以通过数组实现二叉树的结构。</p>
<h3 id="表示完美二叉树">表示完美二叉树</h3>
<p>对于一颗完美二叉树，我们可以将所有的节点按照层序遍历的顺序存储一个数组中，则每个节点都对应唯一的数组索引，根据层序遍历的特性，我们也可以推导出父子节点之间的索引关系：</p>
<p><strong>若某节点的索引为𝑖，
则该节点的左子节点索引为2𝑖+1，右子节点索引为2𝑖+2</strong></p>
<p>这里的映射关系就相当于先前的指针，我们只需要知道当前的索引，就能找到其对应的左右节点</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/nKbiCcQN3fhk4al.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="表示任意二叉树">表示任意二叉树</h3>
<p>完美二叉树是一个特例，在实际情况中，我们的二叉树中间层有很多<code>None</code>，如果层序遍历不包含这些<code>None</code>，那么我们就无法根据一个数组来还原二叉树的形态：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/MJ9KjoOWAIVvtG1.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>所以我们尝试在层序遍历的序列中显式的写出所有的<code>None</code>:</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/ZXafdEGv3RcoBOl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>就可以清晰的表示一个二叉树的结构。当然需要注意的是，完全二叉树十分适合用数组来表示，我们知道其<code>None</code>只会出现在最底层的右边，一定出现在层序遍历序列的末尾。这意味着当我们对完全二叉树进行存储时，我们可以忽略所有的<code>None</code></p>
<h3 id="二叉树的数组实现">二叉树的数组实现</h3>
<p>现在我们尝试用数组实现二叉树的结构，我们需要支持以下操作：</p>
<ul>
<li>给定某节点，获取其值、左右子节点、父节点</li>
<li>获取前序、中序、后序遍历、层序遍历序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayBinaryTree</span>(vector&lt;<span class="type">int</span>&gt; arr)&#123;</span><br><span class="line">        tree = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> tree[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">val</span>(i)!=<span class="number">-1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pastOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>如下图所示，二叉搜索树需要满足以下条件：</p>
<ul>
<li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt;
右子树所有节点的值</li>
<li>任意节点的左右子树也时二叉搜索树，满足上一个条件</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/EUbMoqiVmQJug8Z.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉搜索树的操作">二叉搜索树的操作</h3>
<p>我们将二叉搜索树封装为一个类<code>BinarySerchTree</code>，并声明一个成员变量<code>root</code>，指向树的节点。</p>
<ol type="1">
<li><strong>查找节点</strong></li>
</ol>
<p>给定一个目标节点值<code>num</code>，我们可以很快的根据二叉搜索树的性质来查找，我们可以声明一个节点<code>cur</code>，从二叉树的根节点<code>root</code>出发，循环比较值，知道找到对应的节点。</p>
<p>二叉搜索树的查找操作实际上和二分查找差不多，循环次数最多为树的高度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val &gt; num)</span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> cur;</span><br><span class="line">       &#125;  </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>给定一个等待插入的元素<code>num</code>，为了保持二叉树的性质，我们进行以下步骤：</p>
<ul>
<li>查找插入位置：和查找操作相似，从根节点出出发，直到越过叶节点时退出循环。</li>
<li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>none</code>的位置。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/8GEtkeaMZ6B1SbU.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在编写的过程中我们需要注意两点：</p>
<ul>
<li>如果插入的数值已经存在，那么则不插入。</li>
<li>使用<code>pre</code>节点保存<code>cur</code>的上一个位置，以为我们指定插入位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               pre = cur;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">           <span class="keyword">if</span>(num &gt; pre-&gt;val)</span><br><span class="line">               pre-&gt;right = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pre-&gt;left = node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>删除节点</strong></li>
</ol>
<p>在二叉树中查找到目标节点，并将其删除，和插入节点类似，我们需要保证在删除操作完成之后仍然保持着二叉树的性质。所以我们需要根据目标子节点的数量，分为<code>0\1\2</code>三种情况进行相应的处理。</p>
<p>对于度为0的情况，我们只需要简单的删除：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/cNCLRi7B2nJhqmM.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当度为1时，我们需要将待删除的节点替换成其子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/WlRGE2JQf8zK47s.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于度为2的节点，我们则需要谨慎处理。首先我们需要找到一个能替换它的节点（左子树的最大值或是右子树的最小值），并将其删除，覆盖待删除的节点：</p>
<ul>
<li>找到待删除节点在中序遍历序列中的下一个节点，记为<code>tmp</code></li>
<li>用<code>tmp</code>的值覆盖待删除节点的值，并在书中递归删除节点<code>tmp</code></li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/kltzjwHXGmpd2EI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 度为0/1</span></span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span> || cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        TreeNode* child = cur-&gt;left==<span class="literal">nullptr</span>?cur-&gt;right:cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(cur!=root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;left==cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode* tmp = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 寻找后继节点</span></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        <span class="comment">// 递归删除后继节点</span></span><br><span class="line">        <span class="built_in">remove</span>(tmp-&gt;val);</span><br><span class="line">        cur-&gt;val = tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>中序遍历有序</strong></li>
</ol>
<p>由于搜索二叉树的性质，当我们对其进行中序遍历时，总是会优先遍历下一个最小节点，所以我们知道：<strong>搜索二叉树的中序遍历时升序的</strong>。所以我们可以直接得到搜索二叉树的有序数据。</p>
<h2 id="avl树">AVL树</h2>
<p>之后单独开一篇讲 感觉比较复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/" class="post-title-link" itemprop="url">94:c4编译器回顾(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 15:23:50" itemprop="dateCreated datePublished" datetime="2025-11-04T15:23:50+08:00">2025-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-09 16:16:32" itemprop="dateModified" datetime="2025-11-09T16:16:32+08:00">2025-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一章中，我们完成了对函数体的解析，现在我们需要进一步解析函数体中的语句，还有程序中的表达式。我们需要将程序中的语句解析成我们的虚拟机能直接执行的语句，所以这一章中会有一点难度：</p>
<h2 id="语句">语句</h2>
<p>我们的编译器中识别以下六种语句：</p>
<ul>
<li><code>if(...) &lt;statement&gt;; [else &lt;statement&gt;;]</code></li>
<li><code>while (...) &lt;statement&gt;;</code></li>
<li><code>&#123;&lt;statement&gt;;&#125;</code></li>
<li><code>return xxx;</code></li>
<li><code>&lt;;(empty statement)&gt;</code></li>
<li><code>expression(这个我们稍后单独讨论)</code></li>
</ul>
<p>现在我们要将这些语句转换成对应的汇编代码：</p>
<h3 id="if语句">IF语句</h3>
<p>IF语句的作用是跳转，根据条件表达式决定跳转的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &lt;statement&gt; [<span class="keyword">else</span> &lt;statement&gt;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&lt;cond&gt;)                   &lt;cond&gt;</span><br><span class="line">JZ a</span><br><span class="line">&lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</span><br><span class="line"><span class="keyword">else</span>:                         JMP b</span><br><span class="line">a:                           a:</span><br><span class="line">&lt;false_statement&gt;           &lt;false_statement&gt;</span><br><span class="line">b:                           b:</span><br></pre></td></tr></table></figure>
<p>对应的流程就是：</p>
<ul>
<li>先执行条件表达式<code>&lt;cond&gt;</code></li>
<li>如果条件失败，则跳转到<code>a</code>的位置，执行<code>else</code>语句</li>
<li>如果条件成功，则在执行<code>&lt;true_statement&gt;</code>之后，无条件跳转到<code>b</code>，结束判断。</li>
</ul>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==If)&#123;</span><br><span class="line">       match(If);</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       <span class="keyword">if</span>(token==Else)&#123;</span><br><span class="line">           match(Else);</span><br><span class="line">           *b = (<span class="type">int</span>)(text + <span class="number">2</span>);</span><br><span class="line">           *++text = JMP;</span><br><span class="line">           b = ++text;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从栈的视角进行解释，text始终是指向下一条要执行的指令的。我们希望<code>JZ</code>后面跟着的是<code>else</code>的代码块的入口或是<code>if</code>判断之后的地址。</p>
<p>这里我们使用了延迟绑定地址的方式，我们来看看以下两种情况：</p>
<ul>
<li>只有<code>if</code>，我们将在执行完<code>if_statement</code>之后，将<code>JZ</code>之后的跳转地址设置成下一条指令的地址<code>text</code></li>
<li>有<code>else</code>，我们希望能够跳转到<code>else</code>的起始地址，我们需要在当前<code>text</code>指向的地址基础上<code>+2</code>，因为我们需要跳过<code>JMP</code>和<code>出口地址</code>所占用的指令空间。同时我们需要将<code>if_statement</code>之后的地址设置成判断的出口，即<code>else_statement</code>的后一条指令</li>
</ul>
<h3 id="while语句">While语句</h3>
<p>While语句的汇编代码更加简单，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:                     a:</span><br><span class="line"><span class="keyword">while</span> (&lt;cond&gt;)        &lt;cond&gt;</span><br><span class="line">JZ b</span><br><span class="line">&lt;statement&gt;          &lt;statement&gt;</span><br><span class="line">JMP a</span><br><span class="line">b:                     b:</span><br></pre></td></tr></table></figure>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==While)&#123;</span><br><span class="line">       match(While);</span><br><span class="line">       a = text;</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       *++text = JMP;</span><br><span class="line">       *++text = (<span class="type">int</span>)a;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在跳转之前用<code>a</code>保存<code>expression</code>开始的指令，用于重新计算<code>cond</code>。然后延迟绑定地址<code>b</code>，作为<code>while</code>逻辑的出口</p>
<h3 id="return-语句">Return 语句</h3>
<p>遇到Return语句则代表函数将要退出了，这一部分很简单，实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Return)&#123;</span><br><span class="line">        match(Return);</span><br><span class="line">        <span class="keyword">if</span>(token!=<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            expression();</span><br><span class="line">        &#125;</span><br><span class="line">        *++text = LEV;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他语句">其他语句</h3>
<p>其他语句并不生成汇编代码，所以简单的匹配消耗即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">       <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>
<h2 id="expresion">expresion</h2>
<p>我们已经完成了对语句的解释，现在我们需要实现对表达式的解释，在此之前我们要明确什么是表达式？怎么解析我们的表达式，并计算他们。</p>
<h3 id="怎么计算表达式">怎么计算表达式</h3>
<p>对于表达式中的运算符，每一个符号都有自己的优先级，在进行运算的时候，我们希望运算符优先级高的子式先被计算。例如在<code>2 + 3 * 4</code>中，我们希望<code>*</code>先被计算，然后再是<code>+</code>。对于我们生成的汇编代码而言，我们应该优先为优先级高的运算符生成目标代码，所以如何确定一个表达式的优先运算顺序十分重要。</p>
<p>这里我们使用递归下降的方法实现对表达式运算符的解析，我们在一开始定义标识符时，实际上就对运算符的优先级进行了排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">    Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">    Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先明确，一元运算符的优先级始终是高于二元运算符的，所以这里我们需要，首先完成对一元运算符的解析，这里先罗列几个较为特殊的：</p>
<ul>
<li><code>Num</code> 当我们遇到一个数字时 要返回它的数值</li>
<li><code>"..."</code> 当我们遇到一个字符串时 要返回它的指针</li>
<li><code>PTR</code> 当我们遇到一个指针类型时
我们要正确的解析它的解引用</li>
<li><code>Func</code>
当我们遇到一个函数调用时，我们要正确的执行它，并返回返回值</li>
<li><code>Id</code> 当我们遇到一个变量时，需要返回它的存储的值</li>
<li>…</li>
</ul>
<p>然后，对一元预算符的判断结束后，我们需要对二元运算符的解析，但是对于二元运算符，我们需要考虑运算符号的优先级。我们给每一个运算符都设置一个当前的<code>level</code>，每次只对高于/等于当前<code>level</code>的运算符进行解析，每次解析完一个运算符之后，都将当前的优先级提高。这样我们就实现了对运算符的递归下降分析，我们的框架代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">    <span class="comment">// 解析一元运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 解析顺序按一元运算符优先级进行解析</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析二元运算符</span></span><br><span class="line">    <span class="keyword">while</span>(token&gt;=level)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们给出具体的实现：</p>
<h3 id="常量">常量</h3>
<p><code>Num</code>用<code>IMM</code>指令将其加载到ax中即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==Num)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是字符串常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = PTR;</span><br><span class="line">        <span class="comment">// while(token==&#x27;&quot;&#x27;) match(&#x27;&quot;&#x27;);</span></span><br><span class="line">        <span class="comment">// 对data段进行地址对齐</span></span><br><span class="line">        data = (<span class="type">char</span>*)(((<span class="type">int</span>)(data) + <span class="keyword">sizeof</span>(<span class="type">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意，如果你想支持<code>"Hello""World" = "HelloWorld"</code>的语法，那么你要设置<code>while(token=='"') match('"');</code>，这里我不想支持就不开了。</p>
<p>然后是<code>data = (char*)(((int)(data) + sizeof(int)) &amp; (-sizeof(int)));</code>，这一部分的作用是将数据段进行对齐，我们希望每次的<code>data</code>指针都是四字节对齐的，这样可以方便我们进行索引，或是避免了字符串访问越界的可能。</p>
<h3 id="sizeof">sizeof</h3>
<p>这个关键字我们也将其作为一元运算符进行处理，我们需要根据后面参数的类型，并返回它的大小。这里我们只支持<code>Int Char Ptr</code>三种类型，其中<code>Ptr</code>类型的大小同<code>int</code></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Sizeof)&#123;</span><br><span class="line">        match(Sizeof);</span><br><span class="line">        match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">            match(Int);</span><br><span class="line">            expr_type = INT;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            expr_type = CHAR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            expr_type = expr_type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = (expr_type==CHAR) ? <span class="keyword">sizeof</span>(<span class="type">char</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量与函数调用">变量与函数调用</h3>
<p>由于我们将函数和变量的值的词法分析都是以<code>Id</code>开头，所以我们对他们的目标代码生成也放在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Id)&#123;</span><br><span class="line">           match(Id);</span><br><span class="line">           id = current_id;</span><br><span class="line">           <span class="comment">// 函数调用</span></span><br><span class="line">           <span class="keyword">if</span>(token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">               tmp = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                   expression(Assign);</span><br><span class="line">                   *++text = PUSH;</span><br><span class="line">                   tmp++;</span><br><span class="line">                   <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class==Sys)&#123;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class==Fun)&#123;</span><br><span class="line">                   *++text = CALL;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数调用\n&quot;</span>,line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 清除栈上的变量</span></span><br><span class="line">               <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   *++text = ADJ;</span><br><span class="line">                   *++text = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Num)&#123;</span><br><span class="line">               *++text = IMM;</span><br><span class="line">               *++text = id-&gt;value;</span><br><span class="line">               expr_type = INT;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class = Glo)&#123;</span><br><span class="line">                   *++text = IMM;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Loc)&#123;</span><br><span class="line">                   *++text = LEA;</span><br><span class="line">                   *++text = -id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 未知变量类型\n&quot;</span>, line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">               *++text = (expr_type==CHAR) ? LC : LI;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针取值">指针取值</h3>
<p>说实话有点写不下去了，最近有点忙，心情也不好，写这个的过程中断断续续的，所以先到此为止吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/" class="post-title-link" itemprop="url">93:c4编译器回顾(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-30 16:26:49" itemprop="dateCreated datePublished" datetime="2025-10-30T16:26:49+08:00">2025-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-06 10:52:43" itemprop="dateModified" datetime="2025-11-06T10:52:43+08:00">2025-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们完成了对词法分析的获取函数<code>next()</code>，现在我们尝试根据token分析，和我们的语法规则，进行简单的语法分析。</p>
<h2 id="解析变量">解析变量</h2>
<p>我们的解释器的语法结构，可以用下面的EBNF的表示法直观的体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">program ::= &#123;global_declaration&#125;+</span><br><span class="line"></span><br><span class="line">global_declaration ::= enum_decl | variable_decl | function_decl</span><br><span class="line"></span><br><span class="line">enum_decl ::= <span class="string">&#x27;enum&#x27;</span> [id] <span class="string">&#x27;&#123;&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>] &#123;<span class="string">&#x27;,&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>&#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">variable_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123; <span class="string">&#x27;,&#x27;</span> &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">function_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id <span class="string">&#x27;(&#x27;</span> parameter_decl <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> body_decl <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">parameter_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123;<span class="string">&#x27;,&#x27;</span> type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id&#125;</span><br><span class="line"></span><br><span class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</span><br><span class="line"></span><br><span class="line">statement ::= non_empty_statement | empty_statement</span><br><span class="line"></span><br><span class="line">non_empty_statement ::= if_statement | while_statement | <span class="string">&#x27;&#123;&#x27;</span> statement <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">| <span class="string">&#x27;return&#x27;</span> expression | expression <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">if_statement ::= <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> statement [<span class="string">&#x27;else&#x27;</span> non_empty_statement]</span><br><span class="line"></span><br><span class="line">while_statement ::= <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> non_empty_statement</span><br></pre></td></tr></table></figure>
<p>对于我们的程序而言，一切都是从对<code>global_delartion</code>开始：</p>
<ul>
<li>变量定义</li>
<li>类型定义（目前只支持enum）</li>
<li>函数定义</li>
</ul>
<p>我们的<code>program()</code>作为语法解析函数，框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">while</span>(token &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        global_declaration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="global_declaration">global_declaration</h3>
<p>即全局定义的语句，我们通过递归下降的方法，来判断当前的定义类型，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">global_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    basetype = INT;</span><br><span class="line">    <span class="keyword">if</span>(token == Enum)&#123;</span><br><span class="line">        match(Enum);</span><br><span class="line">        <span class="keyword">if</span>(token != <span class="string">&#x27;&#123;&#x27;</span>) match(Id);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            enum_declaration();</span><br><span class="line">            match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">        match(Int);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">        match(Char);</span><br><span class="line">        basetype = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        type = basetype;</span><br><span class="line">        <span class="comment">// 指针处理</span></span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: duplicate global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Fun;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(text);</span><br><span class="line">            function_declaration();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current_id-&gt;class = Glo;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(data);</span><br><span class="line">            data += <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用的依旧是<code>lookahead</code>的思想，我们无法根据一个<code>token</code>信息就实现对这一部分的语法功能解析，所以我们需要结合之后的信息，来对定义进行判断。</p>
<p>我们的解释器同时也支持指针类型，我们这里使用<code>type = type+PTR</code>的方式，来表示其包含指针的信息。</p>
<h3 id="enum_declaration">enum_declaration</h3>
<p>主要用来解析用<code>,</code>分隔的变量，这里我们需要注意编译器对枚举变量的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enum_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的枚举变量声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(token!=Num)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 枚举变量赋值错误\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i = token_val;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Num;</span><br><span class="line">        current_id-&gt;type = INT;</span><br><span class="line">        current_id-&gt;value = i++;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数match">辅助函数match</h3>
<p>这里我们使用<code>match</code>来匹配并获取下一个<code>token</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token == tk)&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: 语法错误, 缺少 %c\n&quot;</span>, line, tk);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数定义的解析">函数定义的解析</h3>
<p>我们在先前的函数Id判断中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">current_id[Class] = Fun;</span><br><span class="line">current_id[Value] = (<span class="type">int</span>)(text); </span><br><span class="line">function_declaration();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在确定是函数类型之后，我们开始对函数结构的解析，我们对函数体的解析结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    function_parameters();</span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    function_body();</span><br><span class="line">    <span class="comment">// match(&#x27;&#125;&#x27;);</span></span><br><span class="line">    <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_id-&gt;class==Loc)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span>=</span>current_id-&gt;Bclass;</span><br><span class="line">            current_id-&gt;type=current_id-&gt;Btype;</span><br><span class="line">            current_id-&gt;value=current_id-&gt;Bvalue;</span><br><span class="line">        &#125;</span><br><span class="line">        current_id++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意两个点：</p>
<ul>
<li>一是在对函数体的分析结束之后，不需要<code>match("&#125;")</code>，因为函数体解析的函数会匹配他</li>
<li>二是在函数解析完毕之后，我们需要将用到的token信息还原。这是因为在函数体解析的过程中，同名的局部变量会把原来定义的全局变量信息覆盖。</li>
</ul>
<p>进一步的实现，则分别是对参数和函数体的内容的解析，首先是对参数的解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_parameters</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> params = <span class="number">0</span>;</span><br><span class="line">    type = basetype = INT;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(token==Int) match(Int);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            type = CHAR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数参数声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line"></span><br><span class="line">        current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">        current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">        current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line">        current_id-&gt;value = ++params;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要注意两点，首先是<code>index_of_bp</code>，这个变量用于确定参数在栈上的偏移值，因为从<code>bp</code>到函数传参之间隔着一个返回地址，所以在计算时需要将<code>index_of_bp</code>加一。</p>
<p>其次是，当我们遇到一个Id类型的token，我们将其所有的信息都备份一遍，并且将值赋值为<code>参数的索引</code></p>
<p>然后是对函数体的解析，我们可以进一步分成局部变量声明和语句部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_body</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos_local = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token==Int||token==Char)&#123;</span><br><span class="line">        basetype = (token==Int ? INT : CHAR);</span><br><span class="line">        match(token);</span><br><span class="line">        <span class="keyword">while</span>(token!= <span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            type = basetype;</span><br><span class="line">            <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">                match(Mul);</span><br><span class="line">                type = type + PTR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的局部变量声明\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            match(Id);</span><br><span class="line">            current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">            current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">            current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">            current_id-&gt;type = type;</span><br><span class="line">            current_id-&gt;value = ++pos_local;</span><br><span class="line">            <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = ENT;  <span class="comment">// 函数入口指令</span></span><br><span class="line">    *++text = pos_local; <span class="comment">// 局部变量大小</span></span><br><span class="line">    <span class="comment">// 语句处理</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        statement();</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = LEV;  <span class="comment">// 函数返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分需要注意的就是<code>*++text</code>的含义，相当于我们在栈上为局部变量预留了空间，后面的<code>LEV</code>则是用来返回函数调用。</p>
<p>至此我们对全局变量和函数定义的解析完成了，之后我们将着重实现对语句的实现，并为他们生成可用的字节码指令。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/" class="post-title-link" itemprop="url">92:c4编译器回顾(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-29 12:59:29" itemprop="dateCreated datePublished" datetime="2025-10-29T12:59:29+08:00">2025-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-30 16:27:12" itemprop="dateModified" datetime="2025-10-30T16:27:12+08:00">2025-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一节中完成了对虚拟机的实现和初始化，还有指令集的定义，接下来就是对源文件的词法分析部分</p>
<h2 id="词法分析">词法分析</h2>
<h3 id="什么是词法分析">什么是词法分析</h3>
<p>源文件的内容对于我们的解释器而言，本质上就是一系列ASCII字符串，是毫无意义的，我们需要通过语法分析将其解析为简单的指令，然后再执行。可是这样一来，这就使得语法分析的部分十分庞大。所以编译器一般会对整个过程进行前后端的分离。前端负责对源文件进行预处理，将其解析为一系列标识符流，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span> * (<span class="number">4</span> - <span class="number">5</span>)</span><br><span class="line">=&gt;</span><br><span class="line">(Number, <span class="number">2</span>) Add (Number, <span class="number">3</span>) Multiply Left-Bracket (Number, <span class="number">4</span>) Subtract (Number, <span class="number">5</span>) Right-Bracket</span><br></pre></td></tr></table></figure>
<p>然后后端就可以根据直接对标识符流进行处理，就避免了中间处理过程臃肿的情况。</p>
<h3 id="词法分析和编译器">词法分析和编译器</h3>
<p>词法分析从某种意义上来讲，本质上也是一种编译器，它以源代码作为输入流，然后输出标识符流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+</span><br><span class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</span><br><span class="line">                   +-------+                      +--------+</span><br></pre></td></tr></table></figure>
<p>直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h3 id="词法分析器的实现">词法分析器的实现</h3>
<p>这里我们就不用现有的词法分析器了，我们手动的实现这一部分。当然我们需要注意，词法分析并不是一次性的将所有的源码转换成标记流。因为在代码中的大多数操作符，和字符关键字都是和代码有上下文关系的。</p>
<p>所以实际的做法是，提供一个<code>next()</code>函数，每次调用这个函数就返回下一个标识。</p>
<h4 id="支持的标识">支持的标识</h4>
<p>我们的编辑器支持以下标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">	Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">	Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里之所以让标识符从128开始，是为了避免和前面设置的指令枚举变量发生冲突。</p>
<p>上面的运算符的枚举变量是有顺序的，实际上他们是按优先级进行排列的，之后的语法分析过程中会用到。现在我们就要进行token的匹配了。例如将<code>==</code>匹配成<code>Eq</code>，将<code>=</code>匹配成<code>Assign</code>。在下面的实现中，我们会分析这些匹配是怎么实现的。</p>
<p>当然这里还需要注意一些字符，他们自己就构成了标记，如右方括号<code>]</code>和波浪号<code>~</code>等，我们不需要对他们做额外的处理，因为他们不属于多字符的共同标记，也不参与运算（没有优先级关系）</p>
<h4 id="框架">框架</h4>
<p>我们的<code>next()</code>的主体框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *last_pos;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        ++src;</span><br><span class="line">	<span class="comment">// 具体的匹配逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用whlie来跳过我们分析过程中的遇到的空白字符和未知的符号。下面我们先把几个比较特殊的标识符进行一下处理：</p>
<h4 id="换行符号">换行符号</h4>
<p>换行符也和空格类似，只不过遇到换行符号，我们需要将当前的行号+1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token == <span class="string">&#x27;\n&#x27;</span>) &#123;++line;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<p>我们的解释器不支持宏定义所以直接跳过<code>#</code>后面部分的内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="number">0</span> || *src == <span class="string">&#x27; &#x27;</span>) &#123;++src;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标识符和符号表">标识符和符号表</h4>
<p>标识符可以理解为变量名。对于语法分析而言，我们并不关心一个变量叫什么，而是在意这个变量的标识符，我们需要从它唯一的标识符中获取这个变量的信息。</p>
<p>基于这个理由，我们让词法分析器将扫描到的标识符保存在一张表中，每当我们遇到标识符，就去表中查找，如果标识符存在就返回它的唯一标识符，不存在则创建有一个新的标识符存放在表中。</p>
<p>我们用结构体来存放标识符的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识符信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">id</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> token;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> Bclass;</span><br><span class="line">    <span class="type">int</span> Btype;</span><br><span class="line">    <span class="type">int</span> Bvalue;</span><br><span class="line">&#125; ID;</span><br></pre></td></tr></table></figure>
<p>这里解释一下各个字段的具体含义：</p>
<ul>
<li><strong>token：</strong>该标识符返回的标记，这里主要是存储变量的信息，所以标记类型注意要是<code>Id</code></li>
<li><strong>hash：</strong> 这个标识符的hash值，用于快速比较标识</li>
<li><strong>name：</strong>存放标识符的变量名</li>
<li><strong>class：</strong>
存放标识符的类型，例如全局、局部、数字等</li>
<li><strong>type：</strong>
标识符的类型，如果是个变量，可能是指针、int或者char</li>
<li><strong>value：</strong>
存放这个标识符的值，如果标识符是函数的，则存放函数地址</li>
<li><strong>BXXX：</strong>
C语言的标识符中可能是全局的也是局部的，当我们局部标识符和全局标识符冲突时，这个字段用于保存全局变量的信息。</li>
</ul>
<p>上面这些信息用于我们在语法分析部分进行解析，更加方便快捷：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> token_val;          <span class="comment">// 当前标识符的值</span></span><br><span class="line">ID *Symbols;            <span class="comment">// 符号表</span></span><br><span class="line">ID *current_id;         <span class="comment">// 当前标识符</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;z&#x27;</span> || token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;Z&#x27;</span> || (*src &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *src &lt;= <span class="string">&#x27;9&#x27;</span>) || token==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 标识符处理</span></span><br><span class="line">            last_pos = src - <span class="number">1</span>; <span class="comment">// 标识符起始位置</span></span><br><span class="line">            <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;z&#x27;</span> || *src&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;Z&#x27;</span> || *src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span> || *src==<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">                hash = hash * <span class="number">147</span> + *(src++);</span><br><span class="line">            <span class="comment">// 查找符号表</span></span><br><span class="line">            current_id = Symbols;</span><br><span class="line">            <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">                <span class="keyword">if</span>(current_id-&gt;hash == hash &amp;&amp; !<span class="built_in">memcmp</span>(current_id-&gt;name, last_pos, src - last_pos))&#123;</span><br><span class="line">                    token = current_id-&gt;token;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current_id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新标识符</span></span><br><span class="line">            token = current_id-&gt;token = Id;</span><br><span class="line">            current_id-&gt;hash = hash;</span><br><span class="line">            current_id-&gt;name = (<span class="type">int</span>)last_pos;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们通过以上形式实现对标识符的识别。</p>
<h4 id="数字">数字</h4>
<p>当遇到数字时我们也需要，进行对应的解析，这一部分的难点在于不同进制的识别。然后将数字转换为对应的数据并求值，我们把它的值保存在<code>token_value</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">           <span class="comment">// 数字处理</span></span><br><span class="line">           token_val = token - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(token_val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                   token_val = token_val *<span class="number">10</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(*src == <span class="string">&#x27;x&#x27;</span> || *src == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                   token = *(++src);</span><br><span class="line">                   <span class="keyword">while</span>((token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>) || (token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;f&#x27;</span>) || (token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;F&#x27;</span>))&#123;</span><br><span class="line">                       token_val = token_val *<span class="number">16</span> + (token&amp;<span class="number">15</span>) + (token&gt;=<span class="string">&#x27;A&#x27;</span> ?<span class="number">9</span>:<span class="number">0</span>);</span><br><span class="line">                       token = *(++src);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">                       token_val = token_val *<span class="number">8</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           token = Num;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>在实际的分析过程中，当我们遇到字符串，我们需要将它的内容保存在<code>data</code>段中，然后返回它<code>data</code>段中的地址，之后我们对字符串的使用都指向这个地址。另一个特殊的地方在于，我们需要支持部分转义字符的实现，这里我们只对<code>\n</code>做一个支持，也支持<code>\x</code>表示字符<code>x</code>的语法。</p>
<p>在分析时，我们将单个字符<code>'a'</code>按<code>Num</code>的形式保存并返回，我们将<code>"a string"</code>按字符串的形式进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>||token==<span class="string">&#x27;\&#x27;&#x27;</span>)&#123;</span><br><span class="line">          last_pos = data;</span><br><span class="line">          <span class="keyword">while</span>(*src!=token &amp;&amp; *src!=<span class="number">0</span>)&#123;</span><br><span class="line">              token_val = *src++;</span><br><span class="line">              <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">                  token_val = *src++;</span><br><span class="line">                  <span class="keyword">if</span>(token_val==<span class="string">&#x27;n&#x27;</span>) token_val = <span class="number">10</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;t&#x27;</span>) token_val = <span class="number">9</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;r&#x27;</span>) token_val = <span class="number">13</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>) token_val = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                  *data++ = token_val;</span><br><span class="line">          &#125;</span><br><span class="line">          src++;  <span class="comment">// 跳过结束符</span></span><br><span class="line">          <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">              *data++ = <span class="number">0</span>;</span><br><span class="line">              token_val = (<span class="type">int</span>)last_pos;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;token = Num;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分可能比较难理解，首先就是判断这个是单字符还是多字符的字符串。然后分别做不同的处理即可。</p>
<h4 id="注释">注释</h4>
<p>在我们的C中，只支持<code>//</code>类型的注释，不支持多行<code>/**/</code>的注释方法。处理方式和前面对<code>#</code>的方式差不多，需要注意的是，这里要前瞻的观察下一位是什么<code>/</code>可能是除法，也可能是<code>//</code>注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">              <span class="keyword">while</span>(*src!=<span class="number">0</span> &amp;&amp; *src!=<span class="string">&#x27;\n&#x27;</span>) ++src;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Div; <span class="keyword">return</span>;&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们利用src比token快一个字符的特点，实现了对多个字符的观察，我们称这个概念为前瞻（lookahead）</p>
<h4 id="其他">其他</h4>
<p>其他的大多数是一些简单的操作符，我们简单的附上代码即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Eq;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Assign;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;+&#x27;</span>)&#123;++src; token = Inc;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Add;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;-&#x27;</span>)&#123;++src; token = Dec;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Sub;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ne;&#125; </span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Le;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&lt;&#x27;</span>)&#123;++src; token = Shl;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Lt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ge;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&gt;&#x27;</span>)&#123;++src; token = Shr;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Gt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;|&#x27;</span>)&#123;++src; token = Lor;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Or;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;&amp;&#x27;</span>)&#123;++src; token = Lan;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = And;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">          token = Xor;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">          token = Mod;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">          token = Mul;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">          token = Brak;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">          token = Cond;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;~&#x27;</span> || token==<span class="string">&#x27;;&#x27;</span> || token==<span class="string">&#x27;&#123;&#x27;</span> || token==<span class="string">&#x27;&#125;&#x27;</span> || token==<span class="string">&#x27;(&#x27;</span> || token==<span class="string">&#x27;)&#x27;</span> || token==<span class="string">&#x27;]&#x27;</span> || token==<span class="string">&#x27;,&#x27;</span> || token==<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>基本的思想就是利用前瞻确定标记。</p>
<h4 id="关键字和内置函数">关键字和内置函数</h4>
<p>完成了上述的词法分析之后，我们需要在正式开始词法分析之前，预处理我们的关键字和内置的函数。我们将它们加入符号表，并提前为他们赋予必要的信息。</p>
<p>我们在<code>main</code>函数中对其进行初始化:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理关键字</span></span><br><span class="line">    &#123;</span><br><span class="line">        Symbols = <span class="built_in">malloc</span>(poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(Symbols, <span class="number">0</span>, poolsize);</span><br><span class="line">        src = <span class="string">&quot;char else enum if int return sizeof while &quot;</span></span><br><span class="line">              <span class="string">&quot;open read close printf malloc memset memcmp exit void main&quot;</span>;</span><br><span class="line">        i=Char;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=While)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;token = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i = OPEN;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=EXIT)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;value = i++;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Sys;</span><br><span class="line">            current_id-&gt;type = INT;</span><br><span class="line">        &#125;</span><br><span class="line">        next(); current_id-&gt;token = Char;</span><br><span class="line">        next(); idmain = current_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们就完成了对源代码的词法分析，程序会通过词法分析将我们的源代码转换成标记流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/" class="post-title-link" itemprop="url">91:c4编译器回顾(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-28 16:37:10" itemprop="dateCreated datePublished" datetime="2025-10-28T16:37:10+08:00">2025-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-29 10:39:50" itemprop="dateModified" datetime="2025-10-29T10:39:50+08:00">2025-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们将尝试构建一个C语言的解释器，这个项目也是我C语言的大作业。现在回顾看来，当时对整个项目都是知其然不知其所以然，从现在的眼光来看，当时很多做法都是很稚嫩的。尤其是对于这个项目结构的理解也远远不足，所以打算重构一遍。</p>
<h2 id="构建流程">构建流程</h2>
<p>首先是整个编译器的构建流程，一般来讲，编译器的编写有三个步骤：</p>
<ol type="1">
<li>词法分析器，用于将文本文件转换为内部的表示结构</li>
<li>语法分析器，在词法分析得到的标记的基础之上，构建一棵语法树</li>
<li>目标代码的生成，将语法树转换成目标代码</li>
</ol>
<p>但是由于这里我们编写的是一个解释器，所以我们自定义自己的虚拟机框架和指令。我们通过语法分析词法分析之后得到的语法树，来生成使用自定义虚拟机框架的指令的目标代码。</p>
<h2 id="编译器的框架">编译器的框架</h2>
<p>仿照c4编译器的写法：</p>
<p>这里我们的解释器主要包括4个函数：</p>
<ul>
<li><code>next()</code> 用于词法分析，获取下一个标记</li>
<li><code>program()</code> 用于语法分析，分析整个C语言的程序</li>
<li><code>expression(level)</code> 用于解析一个表达式</li>
<li><code>eval()</code> 虚拟机的入口，用于执行目标代码</li>
</ul>
<p>可能在此基础之上我会做出一点自己的改动，但是总体框架还是确定的，首先是实现对要解释的文件的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件全局变量</span></span><br><span class="line"><span class="type">int</span> line;       <span class="comment">// 当前行数</span></span><br><span class="line"><span class="type">char</span> *src;      <span class="comment">// 源文件内容</span></span><br><span class="line"><span class="type">char</span> *old_src;  <span class="comment">// 源文件备份</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> poolsize = <span class="number">256</span>*<span class="number">1024</span>; <span class="comment">// 内存池大小</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取源文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(*argv,<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, *argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(src = old_src = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((i=read(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not read %s\n&quot;</span>, *argv);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        src[i] = <span class="number">0</span>; <span class="comment">// 文件结束符</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将读取到的文件内容复制到<code>src</code>内存空间中。</p>
<p>现在我们就需要开始模拟一台计算机应有的功能了，我们的指令需要运行在我们的虚拟机上。那么首先，我们就需要定义一个自己的虚拟机，一台机器必须要有以下几个部分：</p>
<ul>
<li>内存： 这是用来存放数据的主要空间，我们的代码段数据
还有函数调用时的栈段都存放在这里</li>
<li>寄存器：我们需要寄存器帮助我们实现各种命令，同时也需要程序计数器指向我们的指令</li>
<li>CPU：本来这一部分应该是一大堆电路，但是这里我们可以通过操作指针和寄存器的方式，用一系列程序，简单的模拟它</li>
</ul>
<h2 id="计算机内部实现">计算机内部实现</h2>
<h3 id="内存">内存</h3>
<p>首先是内存部分，一般情况下，内存会被分成几个段。由于我们是简单实现的理想模型，我们只需要设置几个最基本的部分就可以了：</p>
<ul>
<li>代码段： 我们分析得到的指令就被存放在这里</li>
<li>数据段： 这里用来存放我们源程序中用的数据，通常和token信息绑定</li>
<li>栈段： 我们处理函数调用将会用到它，存放栈帧和局部变量等数据</li>
</ul>
<p>现在我们就可以简单的对我们的模拟的计算机内存进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 内存布局</span></span><br><span class="line"><span class="type">int</span> *text;          <span class="comment">// 代码段</span></span><br><span class="line"><span class="type">int</span> *old_text;      <span class="comment">// 代码段备份</span></span><br><span class="line"><span class="type">int</span> *<span class="built_in">stack</span>;         <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> *data;         <span class="comment">// 数据段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(text = old_text = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for text\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">stack</span> = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for stack\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(data = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for data\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(text, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, poolsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄存器">寄存器</h3>
<p>寄存器用来存放计算机的运行状态，我们的虚拟机中只简单的使用四个寄存器，分别是：</p>
<ul>
<li><code>PC</code>程序计数器，用于存放一个内存地址，该地址中用于存放下一条要执行的指令</li>
<li><code>SP</code>寄存器，永远指向当前的栈顶（注意这里的栈是从高地址向低地址增长的）</li>
<li><code>BP</code>基址寄存器，用于指向栈底，当我们在函数调用解析参数时需要用到它</li>
<li><code>AX</code>通用寄存器，用来存放一条指令执行后的结果</li>
</ul>
<p>我们对他们进行简单的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 寄存器</span></span><br><span class="line"><span class="type">int</span> *pc;            <span class="comment">// 程序计数器</span></span><br><span class="line"><span class="type">int</span> *bp;            <span class="comment">// 基址指针</span></span><br><span class="line"><span class="type">int</span> *sp;            <span class="comment">// 栈指针</span></span><br><span class="line"><span class="type">int</span> ax;             <span class="comment">// 通用寄存器</span></span><br><span class="line"><span class="type">int</span> cycle;          <span class="comment">// 时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 寄存器初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        bp = sp = (<span class="type">int</span>*)((<span class="type">char</span>*)<span class="built_in">stack</span> + poolsize);</span><br><span class="line">        ax = <span class="number">0</span>;</span><br><span class="line">        cycle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<p>现在我们的虚拟机已经有了基本的骨架，我们可以开始尝试实现我们我们虚拟机最基本的指令集。不过首先我们需要明确我们需要用到哪些指令。这里我们直接照搬C4的指令集就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">       LEA, IMM, JMP, CALL, JZ, JNZ, ENT, ADJ, LEV,</span><br><span class="line">       LI, LC, SI, SC, PUSH,</span><br><span class="line">       OR, XOR, AND, EQ, NE, LT, GT, LE, GE,</span><br><span class="line">       SHL, SHR, ADD, SUB, MUL, DIV, MOD,</span><br><span class="line">       OPEN, READ, CLOS, PRTF, MALC, MSET, MCMP, EXIT </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些指令顺序是有意的，带有参数的指令在前，没有参数指令的放在后面，为了方便我们之后打印调试信息。</p>
<h4 id="mov">MOV</h4>
<p><code>MOV dest,src</code>x86中最基础重要的一个公式，它将<code>SOURCE</code>中的内容放在<code>DEST</code>中。但在我们的虚拟机中只提供了一个通用寄存器<code>AX</code>，加上由于对参数类型的识别是一件复杂的事情，所以我们将<code>MOV</code>拆分成五个子操作来实现：</p>
<ul>
<li><code>IMM &lt;num&gt;</code>
将<code>num</code>放入寄存器<code>ax</code>中</li>
<li><code>LC</code>
将对应地址中的字符载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>LI</code>
将对应地址中的整数载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>SC</code>将<code>ax</code>中的数据作为字符存放入地址中，要求栈顶存放地址</li>
<li><code>SI</code>将<code>ax</code>中的数据作为整数存放入地址中，要求栈顶存放地址</li>
</ul>
<p>这样的拆分，极大程度上的减小了指令实现的复杂度，现在我们可以开始具体的实现了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> op, *tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == IMM) &#123;ax = *pc++;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LC) &#123;ax = *(<span class="type">char</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LI) &#123;ax = *(<span class="type">int</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SC) &#123; *(<span class="type">char</span>*)*sp++ = ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SI) &#123; *(<span class="type">int</span>*)*sp++ = ax;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里得<code>*sp++</code>实际上就是一个退栈操作，将值存储到弹出得地址中。</p>
<p>这里我之前一直没有搞懂，为什么<code>LI/LC</code>要将对应地址中的字符载入<code>ax</code>中，因为我们的默认的计算结果是存储在<code>ax</code>中的，也就是我们指令计算出的地址，可以直接被<code>LI/LC</code>所使用，这样就很高效。</p>
<h4 id="push">PUSH</h4>
<p><code>PUSH</code>的作用很简单，就是将值或者寄存器压入到栈中。在这里我们<code>PUSH</code>的作用给就是将<code>ax</code>的值压入栈中，因为我们只有这一个寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == PUSH) &#123;*--sp = ax;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jmp">JMP</h4>
<p><code>JMP &lt;addr&gt;</code>是跳转指令，无条件的将当前的<code>PC</code>寄存器设置为指定的<code>&lt;addr&gt;</code>，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JMP) &#123;pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>pc始终指向的是下一条指令，所以此时它存放的存放的是JMP指定的参数，即<code>&lt;addr&gt;</code>的值</p>
<h4 id="jzjnz">JZ/JNZ</h4>
<p>为了实现<code>if</code>语句
我们也需要条件判断相关的指令。这里我们只需要实现两个最简单的条件判断，即<code>ax==0/ax!=0</code>的情况下的跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JZ) &#123;pc = ax ? pc+<span class="number">1</span> : (<span class="type">int</span>*)*pc;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JNZ) &#123;pc = ax ? (<span class="type">int</span>*)*pc : pc+<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子函数调用">子函数调用</h3>
<p>这个是比较重要的一部分，我很大程度上也是为了这一部分重新回头别写这个编译器。这里我们将根据子函数调用约定，用几个最简单的指令来实现这个过程，我们要引入的指令有<code>CALL ENT ADJ LEV</code>。</p>
<p>首先我们介绍<code>CALL</code>，它用于跳转到一个子函数的开始地址。程序将会跳转到地址<code>&lt;addr&gt;</code>，并将当前的位置信息保存起来，以用于函数调用后的返回。这里我们将返回的PC存放在栈中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == CALL) &#123;*--sp = (<span class="type">int</span>)(pc+<span class="number">1</span>); pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们能进入调用函数了，那么我们便需要进一步的规范我们的函数调用规则。在实际的函数调用中，我们不仅要考虑函数的地址，也要考虑如何传递参数和返回结果，这里我们将每次的返回结果保存在<code>ax</code>中，对于参数传递，我们需要遵循C语言的调用标准：</p>
<ul>
<li>由调用者将参数入栈</li>
<li>调用结束时，由调用者将参数出栈</li>
<li>参数逆序入栈（因为先进后出）</li>
</ul>
<p>我们可以看下面的这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callee</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ret += <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会生成下面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     1, esp       ; save stack for variable: i</span><br><span class="line">; push call arguments</span><br><span class="line">push    3</span><br><span class="line">push    2</span><br><span class="line">push    1</span><br><span class="line">; call subroutine &#x27;callee&#x27;</span><br><span class="line">call    callee</span><br><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, 12</span><br><span class="line">; use subroutine result</span><br><span class="line">add     eax, 5</span><br><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>但是我们的虚拟机难以解决其中的几个问题：</p>
<ul>
<li><code>push ebp</code> 我们的PUSH无法指定寄存器</li>
<li><code>mov ebp,esp</code> 我们的MOV也无法直接指定源和目的</li>
<li><code>add esp,12</code> 我们的ADD也无法直接实现两个操作数的加法</li>
</ul>
<p>所以我们需要额外的指令来代替这几个的功能，所以我们需要定义以下几个指令：</p>
<h4 id="ent">ENT</h4>
<p><code>ENT &lt;size&gt;</code>指的是<code>enter</code>我们用它实现<code>make new call frame</code>的操作，即保存当前的栈指针，并在栈上保留一定的空间，用来存放局部变量，汇编代码的表现形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     size, esp       ; save stack for variable</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ENT) &#123;*--sp = (<span class="type">int</span>)bp; bp = sp; sp = sp - *pc++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="adj">ADJ</h4>
<p><code>ADJ &lt;size&gt;</code>用于实现<code>remove argument from frame</code>。用于将调用子函数时压入栈中的数据清楚，之所以单独定义这个指令，是对我们ADD功能局限做出的妥协。其汇编实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, size</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ADJ) &#123;sp = sp + *pc++;&#125;    <span class="comment">// add esp &lt;size&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lev">LEV</h4>
<p>本质上这个指令并不是必需的而且我们的指令集中并没有<code>POP</code>的指令，所以为了简洁的进行函数的退出操作，我们专门定义了<code>LEV</code>的封装。对应的汇编操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>我们用以下形式实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEV) &#123;sp = bp; bp = (<span class="type">int</span>*)sp++; pc = (<span class="type">int</span>*)*sp++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>上述的指令解决了调用帧的问题，解决了我们函数的运行和返回的问题。现在，为了进一步的执行调用函数，我们需要想办法获取先前压入的参数。在此之前，我们首先需要了解当参数调用时，栈中的调用帧是什么样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sub_function(arg1, arg2, arg3);</span><br><span class="line"></span><br><span class="line">|    ....       | high address</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 1        |    new_bp + 4</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 2        |    new_bp + 3</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 3        |    new_bp + 2</span><br><span class="line">+---------------+</span><br><span class="line">|return address |    new_bp + 1</span><br><span class="line">+---------------+</span><br><span class="line">| old BP        | &lt;- new BP</span><br><span class="line">+---------------+</span><br><span class="line">| local var 1   |    new_bp - 1</span><br><span class="line">+---------------+</span><br><span class="line">| local var 2   |    new_bp - 2</span><br><span class="line">+---------------+</span><br><span class="line">|    ....       |  low address</span><br></pre></td></tr></table></figure>
<p>我们首先将参数压入栈中，然后进行调用，调用会将返回地址压入栈中，然后保存当前的栈基址（我们将这个保存的栈帧称为<code>old_bp</code>），准备创建下一个栈帧。当前视图就是进行<code>push rbp; mov rbp,rsp;</code>之后的栈帧状态。此时如果我们想要访问函数的第一个参数，我们就需要访问<code>new_bp+4</code>地址上的内容。</p>
<p>但是这里有一个问题，我们的ADD指令无法对bp进行运算，所以我们需要设置一个新的指令，用于访问栈帧上的地址<code>LEA &lt;offset&gt;</code>。我们具体的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEA) &#123;ax = (<span class="type">int</span>)(bp + *pc++);&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们就完成了实现函数调用的所有指令了。</p>
<h3 id="运算符指令">运算符指令</h3>
<p>我们在C语言中支持的各种运算符号都是二元的，所以我们指令的参数也应该是由两个的，但是我们只有一个通用寄存器，这就导致我们需要将其中一个参数放在栈上，另一个参数存放在<code>ax</code>中，我们通过指令计算出来的结果也存放在ax上。</p>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == OR)  ax = *sp++ | ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == XOR) ax = *sp++ ^ ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == AND) ax = *sp++ &amp; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == EQ)  ax = *sp++ == ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == NE)  ax = *sp++ != ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LT)  ax = *sp++ &lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LE)  ax = *sp++ &lt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GT)  ax = *sp++ &gt;  ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GE)  ax = *sp++ &gt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHL) ax = *sp++ &lt;&lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHR) ax = *sp++ &gt;&gt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADD) ax = *sp++ + ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SUB) ax = *sp++ - ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MUL) ax = *sp++ * ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == DIV) ax = *sp++ / ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MOD) ax = *sp++ % ax;</span><br></pre></td></tr></table></figure>
<h3 id="内置命令">内置命令</h3>
<p>有很多由系统支持的函数，我们往往难以在机器上支持实现，所以这里我们简单的对函数进行封装，设置为内置的指令，用来支持一些常用的库函数调用。</p>
<p>这里我们就简单的对<code>exit open close read printf malloc memset</code>指令进行封装以确保我们的程序有基本的能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == EXIT) &#123;<span class="built_in">printf</span>(<span class="string">&quot;exit(%d)&quot;</span>, *sp); <span class="keyword">return</span> *sp;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == OPEN) &#123;ax = open((<span class="type">char</span> *)sp[<span class="number">1</span>], sp[<span class="number">0</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == CLOS) &#123;ax = close(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == READ) &#123;ax = read(sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == PRTF) &#123;tmp = sp+pc[<span class="number">1</span>]; ax = <span class="built_in">printf</span>((<span class="type">char</span>*)tmp[<span class="number">-1</span>],tmp[<span class="number">-2</span>],tmp[<span class="number">-3</span>],tmp[<span class="number">-4</span>],tmp[<span class="number">-5</span>],tmp[<span class="number">-6</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MALC) &#123;ax = (<span class="type">int</span>)<span class="built_in">malloc</span>(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MSET) &#123;ax = (<span class="type">int</span>)<span class="built_in">memset</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MCMP) &#123;ax = <span class="built_in">memcmp</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的参数在函数调用时是顺序入栈，所以看起来比较反直觉，结合栈是自顶向下索引的，所以我们最终可以很好的理解我们的参数调用顺序。</p>
<p>最后在加上一个错误判断，我们的虚拟机指令就完成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown instruction:%d\n&quot;</span>, op);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<p>现在我们的虚拟机指令就完成了，我们可以做一个简单的测试，来看我们的机器能否正确的运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">pc = text;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">12</span>;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">5</span>;</span><br><span class="line">text[i++] = DIV;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">1</span>;</span><br><span class="line">text[i++] = EXIT;</span><br></pre></td></tr></table></figure>
<p>程序执行的结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/c4$ ./a.out</span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="number">2</span>)</span></span><br></pre></td></tr></table></figure>
<p>至此我们的虚拟机以及指令架构就完成了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/24/90-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/24/90-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-13/" class="post-title-link" itemprop="url">90:初始图形学(13)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-24 20:23:06" itemprop="dateCreated datePublished" datetime="2025-10-24T20:23:06+08:00">2025-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-27 17:10:55" itemprop="dateModified" datetime="2025-10-27T17:10:55+08:00">2025-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>自从上个学期之后，就怎么接触过图形学了。但是仔细感受下来，图形学是最让人有收获感的方向。它通过模拟真实的物理规则，通过计算模拟出真实的模拟场景，十分有趣，就是给人一种融汇贯通的感觉，学到的知识能结合在一起，我感觉这才是最有意义的地方。</p>
<p>然后进度的话是接着上一次”图形学(12)“最终的场景，在此之前，我把之前的项目代码熟悉了一下，在WSL环境上重构了一遍，感觉效率相对于原来还是快了一点。现在就正式开始吧</p>
<h2 id="运动模糊">运动模糊</h2>
<p>在真实的世界中，当我们按下快门，相机会接受一段时间内的光线信息，在此期间内，世界中的物体可能会发生移动，这样排除来的照片，我称之为运动模糊。为了真实的再现这个效果，需要对我们现有的程序进行补充：</p>
<h3 id="简介">简介</h3>
<p>我们可以在快门开启的期间随机选择一个时间点发射一条射线从而得到，这条射线上的光子信息。只要我们能够知道在那个随机时间点上，场景中每个物体的位置和姿态。我们就可以像处理静态场景一样，计算这条光线与物体的交点、着色等。这样，这条光线就能准确反映那个特定瞬间的光照情况。</p>
<p>因此光线追踪的过程只需要，在处理每条光线时，更新物体的位置，就可以是实现对物体动态的追踪了。为了实现这一点，我们需要让每条线携带时间信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time)</span><br><span class="line">        : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line">	<span class="comment">// 默认初始化时间为0</span></span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction)</span><br><span class="line">        : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间管理">时间管理</h3>
<p>真实世界中的快门时间是由两部分决定的：</p>
<ul>
<li><strong>帧间隔</strong>：连续两帧画面之间的时间间隔</li>
<li><strong>快门开启时长：</strong>在每一帧的帧间隔中，快门实际打开、允许光线进入的时间长度（一般情况下开启时间越长，运动模糊越明显）</li>
</ul>
<p>但是这里为了简化光线追踪的实现，我们只对一帧的画面进行捕捉。当然，如果想要渲染一个完整的动画，只需要设置好适当的快门时间就可以了。如果世界是静态的，只有相机的位置在移动，那么我们的代码无需做出改变。但如果世界中的物体在进行运动，那么我们需要为<code>hittable</code>设置一种方法，使得每个物体都能感知到当前帧的时间周期，并更新他们此时的位置。</p>
<p>为了简化墨香，我们只渲染一帧，我们把时间设置为从时间t=0到t=1。我们将让相机在时间[0,1]之间随机发射光线，并更新我们的球体类。</p>
<h3 id="更新相机">更新相机</h3>
<p>我们更新相机，使其在开始和结束时间之间随机生成光线，这里我们通过相机类来对光线信息进行管理和生成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray <span class="title function_">get_ray</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> offset = sample_pixel_offset();</span><br><span class="line">    <span class="keyword">auto</span> pixel_sample = pixel_origin + (i + offset.x()) * pixel_delta_u + (j + offset.y()) * pixel_delta_v;</span><br><span class="line">    <span class="keyword">auto</span> ray_origin = (defocus_angle &gt; <span class="number">0.0</span>) ? defocus_disk_sample() : camera_origin;</span><br><span class="line">    <span class="keyword">auto</span> ray_direction = pixel_sample - ray_origin;</span><br><span class="line">    <span class="keyword">auto</span> ray_time = random_double();</span><br><span class="line">    <span class="keyword">return</span> ray(ray_origin, ray_direction, ray_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="球体运动属性">球体运动属性</h3>
<p>现在我们要让我们的世界动起来，我们需要更新球体类，使其中心在t=0到t=1的时间中，从center1线性速度的移动到center。我们将center属性修改成一个从t=0时刻指向t=1时刻的射线向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span>: <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center,<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;&#125;</span><br><span class="line">    <span class="comment">// 动态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center1, <span class="type">const</span> point3&amp; center2, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center1,center2-center1), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ray center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们需要更新<code>hit</code>方法，需要需要在更新动画中心的位置之后，也能正确的进行相交判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    point3 cur_center = center.<span class="built_in">at</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - cur_center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = std::<span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (!t_range.<span class="built_in">contains</span>(root)) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (!t_range.<span class="built_in">contains</span>(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - cur_center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat = mat;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们只需要根据射线携带的时间信息，更新我们的球心位置，然后正常的进行计算就行了，如果<code>r.time()</code>等于0，就说明位置不变。就算变了，我们也不需要花费额外的计算开销。</p>
<h3 id="追踪光线的相交时间">追踪光线的相交时间</h3>
<p>现在光线有了时间属性，我们也需要记录每次光线和世界相交的时间信息，我们只需要简单的更新一下相交光线的信息就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br></pre></td></tr></table></figure>
<h3 id="最终效果">最终效果</h3>
<p>现在我们想世界中添加球体的运动属性，以实现最终的动态渲染效果，让我们看看怎么样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 世界场景</span></span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-8</span>; a &lt; <span class="number">8</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-8</span>; b &lt; <span class="number">8</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">0.2</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, center2, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">0.1</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, center2, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相机</span></span><br><span class="line">    camera cam;</span><br><span class="line">    cam.aspect_ratio = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width = <span class="number">1250</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0.6</span>;</span><br><span class="line">    cam.focus_distance = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到较为明显的运动痕迹：</p>
<figure>
<img src="https://s2.loli.net/2025/10/27/LDBqli3PFQpcvxn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/21/89-makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/21/89-makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">89:makefile基本使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-21 16:27:29" itemprop="dateCreated datePublished" datetime="2025-10-21T16:27:29+08:00">2025-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-22 10:36:41" itemprop="dateModified" datetime="2025-10-22T10:36:41+08:00">2025-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">自动构建</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="makefile教程">MAKEFILE教程</h1>
<p>之后要尝试做一些项目，在加上前一段时间接触PA，发现自己对自动构建项目一类的操作实在是一知半解，而且之后也需要要尝试自动化编译一些大型的源码，所以学习一下<code>makefile</code>的基本使用，完善一下自己对工具链的认知。这里我看的教程是廖雪峰的<code>makefile</code>入门</p>
<h2 id="makefile基础">Makefile基础</h2>
<p>在Linux中我们使用<code>make</code>命令时，他就会在当前目录下找一个名为<code>Makefile</code>的文件，并根据里面的内容进行自动化的执行。我们以下面这个需求为例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt + b.txt -&gt; m.txt</span><br><span class="line">m.txt + c.txt -&gt; x.txt</span><br></pre></td></tr></table></figure>
<p>上述逻辑我们编写makefile</p>
<h3 id="规则">规则</h3>
<p>Makefile由各种规则构成，每一条规则需要指出一个目标文件和若干个依赖文件，以及用于生成目标文件的命令，例如我们想要生成<code>m.txt</code>则规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标文件: 依赖文件1 依赖文件2 依赖文件...</span></span><br><span class="line"><span class="section">m.txt: a.txt b.txt</span></span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>其中<code>#</code>用来注释，一条规则的格式如上，<code>Tab</code>后使用命令来实现目标文件</p>
<p>现在我们就可以完整的实现上述的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">x.txt: m.txt c.txt</span></span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line"><span class="section">m.txt: a.txt b.txt</span></span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>我们可以尝试执行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile  m.txt  x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat x.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">I am c.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat m.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">ylin@Ylin:~/Program/test$</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>所以我们可以知道，实际上Makefile就是一堆规则(即你些的目标文件和依赖)，当满足规则时，就调用规则后的命令，创建出一个新的目标文件</p>
<p>把默认的规则放在第一条，其他规则的顺序makefile会自动判断依赖。<code>make</code>会把每次执行的命令输出出来，便于我们观察调试。</p>
<p>如果我们在不对任何目标文件进行修改的情况下，我们在此使用<code>make</code>就会得到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">make: &#x27;x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>会根据文件的创建和修改时间来判断是否应该更新一个目标文件，例如我们这里只修改<code>c.txt</code>，并不会触发对<code>m.txt</code>的更新，因为他的依赖文件没有发生改变：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat x.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">I am c.txt (modified)</span><br><span class="line">ylin@Ylin:~/Program/test$</span><br></pre></td></tr></table></figure>
<p><code>make</code>只会重新编译那些依赖被修改，或者是尚未完成的部分，重新编译的过程并不是每一条命令都会执行，<code>make</code>只会选择必要的部分执行，我们称这种编译为增量编译。能否正确的实现增量编译，取决于我们编写的规则。</p>
<h3 id="伪目标">伪目标</h3>
<p>为了进一步的便于自动化的构建，有时候我们会需要定义一些常用的规则。例如在我们使用<code>make</code>之后，我们自动生成了<code>m.txt</code>和<code>x.txt</code>，现在我们可以定义一个规则用于清理这些生成的文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然后我们可以通过<code>make clean</code>来调用这个规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile  m.txt  x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile</span><br></pre></td></tr></table></figure>
<p>但是<code>make</code>这里实际上是把clean当作一个目标文件，我们使用<code>make clean</code>规则时，<code>make</code>检查到没有目标文件<code>clean</code>，于是调用命令尝试构建目标文件，但是<code>clean</code>文件不会被生成，所以我们总可以使用它。可是如果目录中有一个clean文件怎么办呢？<code>make</code>认为clean已经被构建了，就不会再使用命令。为了解决这个问题，我们希望<code>make</code>不要将clean视作文件，我们可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，clean就不再被视作一个文件，而是伪目标。一般大型项目会有<code>clean</code>，<code>install</code>一类的常用的伪目标规则，方便用户快速的构建一些任务</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>运行结果如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ylin/Program/test</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ylin/Program/test</span><br></pre></td></tr></table></figure></p>
<p>我们发现命令<code>cd ..</code>并没有修改当前目录，导致每次输出的<code>pwd</code>都是一样的，这是因为<code>make</code>针对每条指令都会创建一个独立的shell环境，所以命令之间无法互相影响。但是我们可以用以下方法实现</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;		<span class="comment"># 使用;可以将多个命令写在一行(顺序执行,不管成功还是失败)</span></span><br></pre></td></tr></table></figure>
<p>我们查看新的执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd;</span><br><span class="line">/home/ylin/Program/test</span><br><span class="line">/home/ylin/Program</span><br></pre></td></tr></table></figure>
<p>当然也可以再<code>;</code>后加<code>\</code>便于分行阅读：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>我们需要注意，在<code>shell</code>中<code>;</code>代表无论当前命令是否生效，都会执行下一个命令。与其相反的一个执行多条命令的语法是<code>&amp;&amp;</code>，当前面的命令执行失败时，后续的命令就不会再继续执行了</p>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出执行的每一条命令，如果我们不想打印某一条命令，我们只需要在命令前面加上<code>@</code>，告诉<code>make</code>不打印该命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;no display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回值错误，就会中断执行。</p>
<p>例如我们手动构建一个错误（用<code>rm</code>删除一个不存在的文件）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;OK&#x27;</span><br></pre></td></tr></table></figure>
<p>会发生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: cannot remove &#x27;zzz.txt&#x27;: No such file or directory</span><br><span class="line">make: *** [Makefile:25: has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>但是有时候我们希望忽略错误，我们可以在特定的指令前面加上<code>-</code>用来忽略错误的命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: cannot remove &#x27;zzz.txt&#x27;: No such file or directory</span><br><span class="line">make: [Makefile:29: ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>对于执行可能出错，但是不影响逻辑的命令，可以使用<code>-</code>忽略</p>
<h2 id="编译c程序">编译C程序</h2>
<p>现在我们尝试一下编译一个简单的C语言程序，其依赖文件如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.c + hello.h -&gt; main.o</span><br><span class="line">hello.c -&gt; hello.o</span><br><span class="line">hello.o + main.o -&gt; a.out</span><br></pre></td></tr></table></figure>
<p>文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;starting main\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ending main\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以编写以下规则，用于自动构建可执行程序：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"><span class="section">hello.o: hello.c hello.h</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>同时也可以通过<code>make clean</code>来删除中间文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.out  hello.c  hello.h  hello.o  main.c  main.o  Makefile</span><br><span class="line">ylin@Ylin:~/Program/test$ make clean</span><br><span class="line">rm -f a.out main.o hello.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">hello.c  hello.h  main.c  Makefile</span><br></pre></td></tr></table></figure>
<p>我们可以看到完整的命令流程如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make clean &amp;&amp; make</span><br><span class="line"><span class="built_in">rm</span> -f a.out main.o hello.o</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o a.out main.o hello.o</span><br></pre></td></tr></table></figure>
<h3 id="隐式规则">隐式规则</h3>
<p>为了编译这个项目，我们一共编写了三条规则，现在我们尝试删除两个<code>.o</code>文件的规则，然后再编译试试：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>然后我们执行<code>make</code>，输出如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc -o a.out main.o hello.o</span><br></pre></td></tr></table></figure>
<p>然后可以发现
我们并没有制定相关的规则，可是程序还是正常的进行了编译，这是<code>make</code>中的隐式规则，因为<code>make</code>本来就是为了编译C程序设计的，所以为了避免重复的编译<code>.o</code>文件，在一开始没有找到对应的规则时，会自动的调用隐式规则。对于<code>C C++ ASM ...</code>等程序，都有内置的隐式规则，这里不展开叙述。</p>
<h2 id="使用变量">使用变量</h2>
<p>我们在编译时难免会遇到许多重复的文件名，为了方便使用，我们引入变量用来解决重复的问题。我们以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>我们可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = a.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: main.o hello.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> main.o hello.o</span><br></pre></td></tr></table></figure>
<p>对于变量定义，我们使用<code>变量名 = 值</code>，变量名通常使用大写。在引用变量时通常使用<code>$(变量名)</code></p>
<p>当然，对于我们的依赖文件列表，也可以使用变量进行替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">OBJS := main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>但是对于依赖文件很多的情况下，我们可能需要一个自动化的方式，来将我们的源文件批量编译成目标文件。我们注意到每个<code>.o</code>文件都是由对应的<code>.c</code>文件编译产生的，我们可以让<code>make</code>先获取<code>.c</code>文件列表再替换生成得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line"><span class="comment"># wildcard意为通配符,即使用通配符去匹配*.c</span></span><br><span class="line"><span class="comment"># patsubst是pattern substitute的缩写,即模式替换,参数为(源模式,目标模式,文件列表)</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<h3 id="内置变量">内置变量</h3>
<p>为了方便我们使用，<code>make</code>也内置了很多的内置变量，例如我们可以用<code>$(CC)</code>替换命令<code>cc</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>这样方便我们在交叉编译时，指定编译器。诸如此类的内置变量还有很多，遇到了再学吧。</p>
<h3 id="自动变量">自动变量</h3>
<p>在<code>makefile</code>中，经常会看到<code>$@</code>、<code>$&lt;</code>之类的变量，这种变量称为自动变量，它们在一个规则中自动指向某个值。例如<code>$@</code>标识目标文件，<code>$^</code>表示所以依赖文件，所以我们也可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<h2 id="模式规则">模式规则</h2>
<p>我们前面提到隐式转换可以在必要时自动创建<code>.o</code>文件，但实际上隐式规则的命令是固定的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>我们只能修改编译器变量和编译选项变量，但没办法运行多条命令。</p>
<p>此时我们就要引入自定义模式规则，它使用<code>make</code>的匹配模式规则，如果匹配上了，就自动创建一条模式规则，我们可以把我们的<code>makefile</code>写成以下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo <span class="string">&quot;Compiling <span class="variable">$&lt;</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>当程序执行<code>a.out: hello.o main.o</code>时，发现没有<code>hello.o</code>，于是查找以<code>hello.o</code>为目标文件的规则，结果匹配到模式规则<code>*.o : *.c</code>，于是模式规则会动态的创建以下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo <span class="string">&quot;Compiling <span class="variable">$&lt;</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>我们可以尝试执行一下<code>make</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">Compiling hello.c to hello.o</span><br><span class="line">cc -c hello.c -o hello.o</span><br><span class="line">Compiling main.c to main.o</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这样他可以比隐式的规则更灵活。但是我们现在也遇到一个问题，就是当我们修改<code>hello.h</code>头文件时，不会触发<code>main.c</code>重新编译的问题，我们之后在解决。</p>
<h2 id="自动完成依赖">自动完成依赖</h2>
<p>我们刚刚提到，在我们可以解决自动把<code>.c</code>编译成<code>.o</code>文件，但是难以解决<code>.c</code>文件对<code>.h</code>文件的依赖规则。因为要想知道<code>.h</code>的依赖关系，我们需要分析文件内容才能做到，并没有一个简单的文件名映射规则。</p>
<p>好在我们可以使用<code>gcc</code>提供的<code>-MM</code>参数，自动分析我们所需要的<code>.h</code>文件参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，我们可以利用这个功能，为每个<code>.c</code>文件都生成一个依赖项，并把它保存到<code>.d</code>(中间文件中)，再使用<code>include</code>将其导入<code>makefile</code>中，这样我们就精准的实现了<code>.c</code>文件的依赖分析。</p>
<p>我们可以更新我们的<code>makefile</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line">DEPS := $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>当我们运行时，通过include会引入<code>.d</code>文件，但是一开始<code>.d</code>文件并不存在，这时会通过模式规则匹配到<code>%.d: %.c</code>。这里用了一个复杂的<code>sed</code>将<code>.d</code>文件创建了出来。我们运行<code>make</code>结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line"><span class="built_in">rm</span> -f main.d; \</span><br><span class="line">cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27;</span> &lt; main.d.tmp &gt; main.d; \</span><br><span class="line"><span class="built_in">rm</span> -f main.d.tmp</span><br><span class="line"><span class="built_in">rm</span> -f hello.d; \</span><br><span class="line">cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27;</span>&lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line"><span class="built_in">rm</span> -f hello.d.tmp</span><br><span class="line">cc -c hello.c -o hello.o</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>.d</code>文件中类似：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>现在，我们文件的依赖就加入了头文件，当我们对头文件进行修改时，就会触发重新编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line"><span class="built_in">rm</span> -f main.d; \</span><br><span class="line">cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27;</span> &lt; main.d.tmp &gt; main.d; \</span><br><span class="line"><span class="built_in">rm</span> -f main.d.tmp</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h2 id="完善makefile">完善Makefile</h2>
<p>我们现在对项目目录进行整理，我们将源码放入<code>src</code>目录，将编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ tree .</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── Makefile</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用我们上述的操作，更新我们的makefile:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR := ./src</span><br><span class="line">BUILD_DIR := ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/a.out</span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)\1</span>.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>我们通过设置目录路径变量实现了对一个简单项目的自动化编译。至此我们的对<code>makefile</code>的基本使用就了解了</p>
<p>对于makefile，它还有很多的复杂的用法，但是之后我会更好的利用它去做更多的项目。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/21/88-%E5%8D%81%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/21/88-%E5%8D%81%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">88:十月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-21 13:00:11 / 修改时间：15:37:35" itemprop="dateCreated datePublished" datetime="2025-10-21T13:00:11+08:00">2025-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">日常总结</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>802</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上个月都没怎么学习，几乎每天都在发呆想事情，因为我和一个傻瓜的事情。前几天去北京和她在一起呆了很久呀，感觉她还是像以前一样对我很好。但是可能异地恋的负担对于她来说还是太大了，所以我也不强求什么了。只求我能努力一点，以后和她一起去北京读书。我和她约好了我会去找她，会陪着她。</p>
<p>她对我一直都很好，很爱我的一个女生，我们从高一在一起，到十月底我们就刚好在一起四年了。我们俩的感情很好，但是我感觉自己还总是没有考虑到她的感受，导致我们的感情总是她一个人承担，所以她真的好幸苦。现在她累累的，就轮到我来照顾她了。我打算好好学习，研究生去北京陪她一起，在她需要我的时候能一直在她身边。</p>
<p>然后这次去北京，听北理的老师和其他高校的学生交流，感觉触动还是很大的吧。感觉他们的眼里都是有光的，他们有自己想做的事，想要做到的事，和自己热爱的事情。而且他们的技术氛围也很好，我感觉自己一直是固步自封，偏于一隅，眼光和格局一直放的很小，总是安于当下。我感觉自己就像一个游魂，每天就是想干啥就干啥，以前我觉得这是一种坦然，现在我感觉这是一种迷茫吧。我应该好好接受生活，体验各种事情，学习各种事情，我想接受更多的东西，不仅仅是知识和技术上的内容。</p>
<p>要做的事情很多呀，确实会很辛苦，但是我认为这是一件很值得的事情。我想和我喜欢的女生在一起，希望自己优秀一点，以后能一直陪在她身边，保护她，我爱她。现在我也不知道应该做什么吧，先把这个学期要学的东西都先学起来，争取这个学期把绩点做好一点，如果有机会保研的话就保研，如果不行的话就考研。</p>
<p>这个月暂时就是整理一下自己，然后开始学一些概率论和离散数学好了，还有一些408的课程。以前我总是不太能接受这些干巴巴的知识，我也更喜欢自己亲自动手实践，但是现在也慢慢开始理解和去接受他们的重要性了。接下来的时间，重要的事情就是先把概率论和离散数学好好学一下。尤其是离散数学，其实我一直都很感兴趣，但是苦于不知道怎么开始学习。</p>
<p>有空的话我想把图形学捡起来好好学一下，打算重构一遍上个学期写的内容，然后进一步的学习一下。</p>
<p>感觉身体也很重要，要做的事情很多，我还要接着加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">229k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:28</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
