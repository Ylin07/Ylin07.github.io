<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/12/00-%E9%A6%96%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/12/00-%E9%A6%96%E9%A1%B5/" class="post-title-link" itemprop="url">Ylin's Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-12 14:53:29" itemprop="dateCreated datePublished" datetime="2025-03-12T14:53:29+08:00">2025-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:25:47" itemprop="dateModified" datetime="2025-11-29T13:25:47+08:00">2025-11-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>45</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="你好呀">你好呀！</h1>
<h1 id="这里记录我的学习经历和内容">这里记录我的学习经历和内容</h1>
<h1 id="希望能够帮到你们">希望能够帮到你们</h1>
<h1 id="section">: )</h1>
<p>标签对应使用的编程语言</p>
<p>分类中查看对应的板块</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/09/105-Python%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/105-Python%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E4%B8%8A/" class="post-title-link" itemprop="url">105:Python字节码解释器基本原理(上)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-09 19:43:00" itemprop="dateCreated datePublished" datetime="2025-12-09T19:43:00+08:00">2025-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-10 11:15:15" itemprop="dateModified" datetime="2025-12-10T11:15:15+08:00">2025-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/Byterun/" itemprop="url" rel="index"><span itemprop="name">Byterun</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>找到一个比较好的项目<a
href="%5BA%20Python%20Interpreter%20Written%20in%20Python%20by%20qingyunha%5D(https://qingyunha.github.io/taotao/)">Byterun</a>，这里进行一下复现。</p>
<h1 id="byterun">Byterun</h1>
<p>Byterun
是一个基于Python实现的Python字节码解释器，简化了Cpython的实现，展示了Python解释器在底层上的实现原理，以及相关的组织过程。</p>
<h2 id="搭建一个解释器">搭建一个解释器</h2>
<p>解释器本质上就是一个虚拟机，他会对你产生的字节码信息进行解释，然后基于栈运行，实现运算、分支条件、循环结构等功能。</p>
<p>Python解释器实际上就是一个字节码解释器，它接受字节码，然后输出运行结果。当你写下一段Python代码时，会被词法分析器解析为token流，然后通过语法分析和编译器，作为字节码（code
object）进行输出。然后字节码再由Python解释器进行运行。这里字节码的作用有点像汇编语言在C语言编译过程。</p>
<h3 id="微型解释器">微型解释器</h3>
<p>我们最简单的解释器开始，它只能识别以下三个指令，我们基于一点一点拓展实现我们的整个项目：</p>
<ul>
<li>LOAD_VALUE：加载值</li>
<li>ADD_TWO_VALUES：相加</li>
<li>PRINT_ANSWER：输出值</li>
</ul>
<p>我们对<code>7+5</code>生成以下指令集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte2exec = &#123;</span><br><span class="line">    <span class="string">&quot;inst&quot;</span>: [</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;num&quot;</span>: [<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以通过这种单指令和零指令的方式进行计算，是因为我们的Python解释器实际上是一个基于栈的虚拟机。</p>
<p>我们将指令和数据分开存放，这样保证了指令是定长的。因此，我们也需要向指令指出数据存放的位置，所以一个完整的指令集有两部分，指令和参数位置。对于不需要参数的零指令，我们用<code>None</code>表示。</p>
<p>现在我们可以基于栈来实现一个简单的解释器结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_VALUES</span>(<span class="params">self,number</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ADD_TWO_VALUES</span>(<span class="params">self</span>):</span><br><span class="line">        first = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        second = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        total = first + second</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(total)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PRINT_ANSWER</span>(<span class="params">self</span>):</span><br><span class="line">        answer = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>
<p>现在我们已经实现了一个虚拟机的基本结构和支持的指令，我们需要一个方法来驱动我们的虚拟机进行对指令的解析与执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, code</span>):</span><br><span class="line">    insts = code[<span class="string">&quot;inst&quot;</span>]</span><br><span class="line">    nums = code[<span class="string">&quot;num&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> insts:</span><br><span class="line">        inst ,arg = i</span><br><span class="line">        <span class="keyword">if</span> inst == <span class="string">&quot;LOAD_VALUES&quot;</span>:</span><br><span class="line">            num = nums[arg]</span><br><span class="line">            <span class="variable language_">self</span>.LOAD_VALUES(num)</span><br><span class="line">        <span class="keyword">elif</span> inst == <span class="string">&quot;ADD_TWO_VALUES&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.ADD_TWO_VALUES()</span><br><span class="line">        <span class="keyword">elif</span> inst == <span class="string">&quot;PRINT_ANSWER&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.PRINT_ANSWER()</span><br></pre></td></tr></table></figure>
<p>现在我们可以尝试使用它们进行简单的计算<code>3+4+5</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;insts&quot;</span>:[</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">2</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;nums&quot;</span>:[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interpreter = Interpreter()</span><br><span class="line">interpreter.run(code)</span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<p>可以看到虚拟机按照预期输出了我们想要的结果。</p>
<h3 id="变量">变量</h3>
<p>现在我们向虚拟机添加存储功能，我们可以将数值存入变量中，实现变量和值的映射关系，我们将实现以下两个指令：</p>
<ul>
<li>STORE_NAME：存入变量</li>
<li>LOAD_NAME：取变量值</li>
</ul>
<p>为了实现这个功能，我们需要再初始化一个内存空间（这里使用字典比较直观），用于存放变量名和值的绑定关系，同时需要在我们的<code>code</code>中添加变量名。我们的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.mem = &#123;&#125;	<span class="comment"># 添加内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_VALUE</span>(<span class="params">self,number</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(number)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">ADD_TWO_VALUES</span>(<span class="params">self</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        y = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(x+y)	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PRINT_ANSWER</span>(<span class="params">self</span>):</span><br><span class="line">        answer = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">STORE_NAME</span>(<span class="params">self,name</span>):</span><br><span class="line">        val = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="variable language_">self</span>.mem[name] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_NAME</span>(<span class="params">self,name</span>):</span><br><span class="line">        val = <span class="variable language_">self</span>.mem[name]</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数索引可能是访问数字也可能是变量 需要进行判断</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_arg</span>(<span class="params">self,inst,arg,code</span>):</span><br><span class="line">        nums = [<span class="string">&quot;LOAD_VALUE&quot;</span>]</span><br><span class="line">        <span class="built_in">vars</span> = [<span class="string">&quot;STORE_NAMES&quot;</span>, <span class="string">&quot;LOAD_NAMES&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> inst <span class="keyword">in</span> nums:</span><br><span class="line">            arg = code[<span class="string">&quot;nums&quot;</span>][arg]</span><br><span class="line">        <span class="keyword">elif</span> inst <span class="keyword">in</span> <span class="built_in">vars</span>:</span><br><span class="line">            arg = code[<span class="string">&quot;vars&quot;</span>][arg]</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, code</span>):</span><br><span class="line">        insts = code[<span class="string">&quot;insts&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> insts:</span><br><span class="line">            inst ,arg = step</span><br><span class="line">            <span class="comment"># 根据指令内容解析对应的参数</span></span><br><span class="line">            arg = <span class="variable language_">self</span>.parse_arg(inst,arg,code)</span><br><span class="line">            <span class="keyword">if</span> inst == <span class="string">&quot;LOAD_VALUE&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.LOAD_VALUE(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;STORE_NAME&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.STORE_NAME(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;LOAD_NAME&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.LOAD_NAME(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;ADD_TWO_VALUES&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.ADD_TWO_VALUES()</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;PRINT_ANSWER&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.PRINT_ANSWER()</span><br></pre></td></tr></table></figure>
<p>这里我们可以试着运行一下<code>x = 3; y = 7; print(x+y)</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;insts&quot;</span>:[</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;STORE_NAME&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;STORE_NAME&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_NAME&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_NAME&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;nums&quot;</span>:[<span class="number">3</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="string">&quot;vars&quot;</span>:[<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interpreter = Interpreter()</span><br><span class="line">interpreter.run(code)</span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p>成功的运行了我们的函数。</p>
<h3 id="程序结构优化">程序结构优化</h3>
<p>随着我们支持的指令增多，我们需要不断的通过if-else结构来进行对指令的执行。在我们的实现中，类的方法名和字节码中的指令是相同的，所以我们通过<code>getattr</code>方法来对<code>run()</code>进行优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, code</span>):</span><br><span class="line">    insts = code[<span class="string">&quot;insts&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> insts:</span><br><span class="line">        inst ,arg = step</span><br><span class="line">        arg = <span class="variable language_">self</span>.parse_arg(inst,arg,code)</span><br><span class="line">        inst = <span class="built_in">getattr</span>(<span class="variable language_">self</span>,inst)	<span class="comment"># 查找和inst同名的方法</span></span><br><span class="line">        <span class="keyword">if</span> arg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            inst()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            inst(arg)</span><br></pre></td></tr></table></figure>
<h2 id="python字节码">Python字节码</h2>
<p>现在我们可以尝试解析一下真实的Python字节码，我们可以以下面的这个函数为例：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;yes&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以通过特殊方法<code>__code__</code>获取函数的字节码和元信息，具体的用法如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数对象 (function)</span><br><span class="line">    │</span><br><span class="line">    └── __code__  (code对象 - 包含完整元数据)</span><br><span class="line">           │</span><br><span class="line">           ├── co_code     (字节码 - 仅指令)</span><br><span class="line">           ├── co_consts   (常量元组)</span><br><span class="line">           ├── co_varnames (变量名元组)</span><br><span class="line">           ├── co_names    (全局名元组)</span><br><span class="line">           ├── co_argcount (参数数量)</span><br><span class="line">           ├── co_nlocals  (局部变量数量)</span><br><span class="line">           └── ... 其他属性</span><br></pre></td></tr></table></figure>
<p>这里我们可以通过这个方式得到我们的字节码指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">codebyte = <span class="built_in">list</span>(codebyte)</span><br><span class="line"><span class="built_in">print</span>(codebyte)</span><br><span class="line"><span class="comment"># [151, 0, 100, 1, 125, 0, 124, 0, 100, 2, 107, 2, 0, 0, 114, 1, 121, 3, 121, 4]</span></span><br></pre></td></tr></table></figure>
<p>我们得到了这个函数的字节码，但是我们无法阅读它。所以我们需要用到Python中的字节码反汇编器<code>dis</code>，将字节码进行翻译并以可读的形式输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">dis.dis(codebyte)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          0 RESUME                   0</span></span><br><span class="line"><span class="string">          2 LOAD_CONST               1</span></span><br><span class="line"><span class="string">          4 STORE_FAST               0</span></span><br><span class="line"><span class="string">          6 LOAD_FAST                0</span></span><br><span class="line"><span class="string">          8 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         10 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         14 POP_JUMP_IF_FALSE        1 (to 18)</span></span><br><span class="line"><span class="string">         16 RETURN_CONST             3</span></span><br><span class="line"><span class="string">    &gt;&gt;   18 RETURN_CONST             4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中第一列是该指令对应的字节码索引，第二列是该字节码的可读形式，第三列是指令的参数索引（第4列可能会指出使用的是什么参数）</p>
<p>同时我们也可以使用<code>dis</code>库中的<code>opname</code>方法，将对应的字节码翻译成可读的指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">codebyte = <span class="built_in">list</span>(codebyte)</span><br><span class="line"><span class="built_in">print</span>(dis.opname[codebyte[<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(dis.opname[codebyte[<span class="number">4</span>]])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">RESUME</span></span><br><span class="line"><span class="string">STORE_FAST</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="条件与循环">条件与循环</h3>
<p>一个语言中条件分支和循环结构的能力也很重要，我们可以借这一段字节码深入的理解Python运行的实现。在我们的例子中<code>if x&gt;5</code>被翻译成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span> LOAD_FAST                <span class="number">0</span></span><br><span class="line"> <span class="number">8</span> LOAD_CONST               <span class="number">2</span></span><br><span class="line"><span class="number">10</span> COMPARE_OP               <span class="number">2</span> (&lt;)</span><br><span class="line"><span class="number">14</span> POP_JUMP_IF_FALSE        <span class="number">1</span> (to <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>LOAD_FAST</code>将局部变量加载到栈上，<code>LOAD_CONST</code>将常数<code>5</code>加载到栈上，然后通过<code>COMPARE_OP</code>指定的比较类型，对栈顶的两个数值进行比较，然后将比较结果放回栈上。最终<code>POP_JUMP_IF_FALSE</code>，根据比较的结果，跳转到指定的指令。跳转后要被加载的指令我们称之为跳转目标，作为<code>POP_JUMP</code>的参数，<code>dis</code>会用<code>&gt;&gt;</code>指出跳转目标。</p>
<p>有了条件判断和跳转之后，我们就可以实现最基本的循环结构，我们对下面这个循环结构进行分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;<span class="number">5</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          0 RESUME                   0</span></span><br><span class="line"><span class="string">          2 LOAD_CONST               1</span></span><br><span class="line"><span class="string">          4 STORE_FAST               0</span></span><br><span class="line"><span class="string">          6 LOAD_FAST                0</span></span><br><span class="line"><span class="string">          8 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         10 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         14 POP_JUMP_IF_FALSE       11 (to 38)</span></span><br><span class="line"><span class="string">    &gt;&gt;   16 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         18 LOAD_CONST               1</span></span><br><span class="line"><span class="string">         20 BINARY_OP               13 (+=)</span></span><br><span class="line"><span class="string">         24 STORE_FAST               0</span></span><br><span class="line"><span class="string">         26 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         28 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         30 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         34 POP_JUMP_IF_FALSE        1 (to 38)</span></span><br><span class="line"><span class="string">         36 JUMP_BACKWARD           11 (to 16)</span></span><br><span class="line"><span class="string">    &gt;&gt;   38 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         40 RETURN_VALUE</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要理解这个循环结构，我们需要从几个跳转指令入手。首先是第一个<code>POP_JUMP</code>，如果判断为真，就进入循环体结构，不为真就直接退出。第二个<code>POP_JUMP</code>则是判断是否退出循环结构。第三个比较特殊<code>JUMP_BACKWARD</code>，它将无条件跳转到循环体的起点。通过跳转和条件分支的功能，实现了循环结构。</p>
<p>其他的语法结构也是类似的，如<code>if ... elif, for ,...</code>，可以通过<code>dis</code>慢慢探索</p>
<h3 id="栈帧">栈帧</h3>
<p>实现了数值的计算和控制转移之后，现在我们需要进一步认识Python
函数调用的过程。正如上面的那个例子，我们看到<code>RETURN_VALUES</code>，那么结束这个函数之后会返回到哪里呢？</p>
<p>如果我们在函数中，我们会返回到调用者。如果是在模块顶层，我们可能会直接结束程序。我们将上一层的信息返回给下一层，例如在递归调用时，我们还需要保存每一层的局部状态。这就引出了Frame的概念，frame是函数调用的一次执行的上下文。它在python运行的过程中不断的被创建和销毁。</p>
<p>对于一个<code>code object</code>，我们可能会有多个frame。但是对于一个<code>frame</code>，我们有且仅对应一个<code>code object</code>。</p>
<p>frame存在于调用栈之中（和C一样）。Python中有三种类型的栈结构：</p>
<ul>
<li>调用栈：用来管理程序运行的函数调用状态</li>
<li>数据栈：用于存放数据</li>
<li>块栈：用于特定的控制流块，如异常和循环结构…</li>
</ul>
<p>在调用栈的每个frame都有它自己的数据栈和块栈。以下面这个程序为例，它在调用栈中的状态大概就是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">y</span>):</span><br><span class="line"><span class="meta">... </span>    z = y + <span class="number">3</span>     </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + bar(b) </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()             </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://s2.loli.net/2025/12/10/znjbvPiEO2JdBSL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>至此，我们对Python字节码的基本分析就结束了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/04/104-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/04/104-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-15/" class="post-title-link" itemprop="url">104:初始图形学(15)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-04 23:09:01" itemprop="dateCreated datePublished" datetime="2025-12-04T23:09:01+08:00">2025-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-06 10:40:35" itemprop="dateModified" datetime="2025-12-06T10:40:35+08:00">2025-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一章中完成了对图形渲染的饿BVH加速，现在我们要尝试将图片纹理映射到物体中。</p>
<h2 id="纹理映射">纹理映射</h2>
<p>图形学中的纹理映射是将材质效果应用于场景中的物理过程。其中”纹理”指的是效果（这个效果可以是材质属性，或是部分存在与否）本身，而映射则是将效果映射到物体的表面上。</p>
<p>最为常见的纹理映射就是将图像映射到物体表面上，就像是把世界地图依附到球体表面。和我们的直觉不同，纹理映射是一个逆向的过程，我们首先确定物体上的一个点，然后查找纹理贴图给定的颜色，以实现对图片的映射。</p>
<p>不过在此之前，我们先用程序化的方式生成纹理颜色，并创建一个纹理贴图。为了执行纹理查找，我们需要物体表面的纹理坐标<code>(u,v)</code>以定位纹理中的像素，同时也需要保存当前点的三维坐标（部分纹理需要这一部分的信息）</p>
<h3 id="恒定色彩纹理">恒定色彩纹理</h3>
<p>我们的纹理颜色类将从最简单的恒定色彩纹理开始实现，实际上我们可以将物体的颜色也视作一种纹理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">texture</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">solid_color</span>(<span class="type">const</span> color&amp; albedo) : <span class="built_in">albedo</span>(albedo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue) : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red,green,blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> albedo;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里我们先实现对纹理类的接口的一个实现，然后创建一个恒定色彩纹理类，返回恒定的颜色类型。</p>
<p>注意到我们这里需要使用到<code>(u,v)</code>表面坐标，我们还需要更新<code>hit_record</code>结构，对这些射线碰撞信息进行存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 p;</span><br><span class="line">    <span class="type">double</span> u;</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    vec3 normal;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="棋盘纹理">棋盘纹理</h3>
<p>棋盘纹理作为实体纹理中的一种。实体纹理取决点在空间中的位置，我们可以理解为给空间中的指定点进行着色，而不是给空间中的某个物体上色。正因如此，当我们的物体在空间中移动时，纹理并不会随物体进行移动，反而像是物体在穿过纹理。</p>
<p>这里我们将实现一个棋盘纹理类，它是一种空间纹理（即实体纹理）。根据点在空间中给定的位置进行纹理颜色的渲染。</p>
<p>为了实现棋盘格图案，我们需要对当前点的每个坐标分量取<code>floor</code>，这样我们就将整个空间分割为<code>1x1x1</code>的单元格，每个坐标都可以映射到对应的单元格，我们对奇数的单元格赋予一种颜色，对偶数赋予另外的一种颜色，这样就实现了棋盘的样式。同时我们还可以设置一个缩放因子<code>scale</code>，控制单元格的大小，从而实现对棋盘格的大小控制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">checker_texture</span>(<span class="type">double</span> scale, shared_ptr&lt;texture&gt; even, shared_ptr&lt;texture&gt; odd)</span><br><span class="line">            : <span class="built_in">inv_scale</span>(<span class="number">1.0</span>/scale), <span class="built_in">even</span>(even), <span class="built_in">odd</span>(odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">checker_texture</span>(<span class="type">double</span> scale, <span class="type">const</span> color&amp; c1, <span class="type">const</span> color&amp; c2)</span><br><span class="line">            : <span class="built_in">checker_texture</span>(scale, <span class="built_in">make_shared</span>&lt;solid_color&gt;(c1), <span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> xInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">x</span>()));</span><br><span class="line">            <span class="keyword">auto</span> yInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">y</span>()));</span><br><span class="line">            <span class="keyword">auto</span> zInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">z</span>()));</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> isEven = (xInt + yInt + zInt) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> isEven ? even-&gt;<span class="built_in">value</span>(u,v,p) : odd-&gt;<span class="built_in">value</span>(u,v,p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> inv_scale;</span><br><span class="line">        shared_ptr&lt;texture&gt; even;</span><br><span class="line">        shared_ptr&lt;texture&gt; odd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了进一步的支持纹理，我们拓展<code>lambertian</code>类，使用纹理代替颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; albedo) : <span class="built_in">tex</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(albedo)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; tex) : <span class="built_in">tex</span>(tex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>()) &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = tex-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; tex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里通过多态的思想实现了对<code>lambertian</code>材质的纹理的实现。</p>
<p>现在我们可以向我们的场景中添加纹理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// main.cpp中将地面设置成棋盘样式</span></span><br><span class="line"><span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="number">0.2</span>, <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">color</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">   world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br></pre></td></tr></table></figure>
<p>渲染结果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/12/05/UjK8dAB24pCTE7O.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="空间纹理的特殊情况">空间纹理的特殊情况</h3>
<p>正如之前所提到的，这种实体纹理的上色方式，更像是物体在穿过纹理，从而完成上色。</p>
<p>我们现在创建一个新的场景来观察这种特殊的情况，我们将先前的main函数保存为一个<code>bounding_ball</code>场景，然后现在我们再来创建一个新的场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkered_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="number">0.32</span>, <span class="built_in">color</span>(<span class="number">.2</span>, <span class="number">.3</span>, <span class="number">.1</span>), <span class="built_in">color</span>(<span class="number">.9</span>, <span class="number">.9</span>, <span class="number">.9</span>));</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    cam.aspect_ratio      = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width       = <span class="number">800</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth         = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过main函数中的switch来切换我们想要渲染的场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: bounding_ball(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: checkered_spheres(); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们渲染出来的结果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/12/05/QbeljFrXuinURdN.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这就是空间纹理渲染的特殊情况，不过你应该能理解这是什么情况。所以为了解决这个问题，我们需要使用表面纹理，这就意味着我们需要根据<code>(u,v)</code>的球体表面位置信息来创建纹理。</p>
<h3 id="球体表面纹理坐标">球体表面纹理坐标</h3>
<p>空间纹理通过空间中一点的坐标，实现纹理的绘制。但是真如我们先前所提到的空间纹理的局限性，我们希望能够更具球体表面的坐标实现对图像点对点的映射。这就以为着我们需要一种方法来查找三维球体表面任意点的坐标<code>(u,v)</code>。</p>
<p>这里用到一个经纬度的思想，首先确定出这个点在球体上的经纬度<span
class="math inline">(<em>θ</em>, <em>ϕ</em>)</span>（横纬竖经，这里<span
class="math inline"><em>θ</em></span>从-Y向上，<span
class="math inline"><em>ϕ</em></span>从-X到+Z到+X到-Z），然后再将球面坐标表示出来，这里的话，如果学过球面坐标，自然能够得到以下式子：
$$ <span
class="math display"><em>我</em><em>们</em><em>可</em><em>以</em><em>简</em><em>单</em><em>的</em><em>推</em><em>导</em><em>得</em><em>到</em>：</span>
$$
所以我们可以写出<code>sphere</code>类中的<code>get_uv</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> theta = std::<span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> phi = std::<span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(),p.<span class="built_in">x</span>()) + pi;</span><br><span class="line">    u = phi / (<span class="number">2</span>*pi);</span><br><span class="line">    v = theta / pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们向<code>hit</code>方法中添加，每次碰撞记录的<code>(u,v)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      rec.t = root;</span><br><span class="line">      rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">      vec3 outward_normal = (rec.p - cur_center) / radius;</span><br><span class="line">      rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">      <span class="comment">// 这里的outward 就是从球心指向碰撞点的向量</span></span><br><span class="line">      <span class="built_in">get_uv</span>(outward_normal,rec.u,rec.v);</span><br><span class="line">      rec.mat = mat;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就实现了对球体表面的位置的<code>(u,v)</code>二维定位</p>
<h3 id="访问纹理图像数据">访问纹理图像数据</h3>
<p>现在我们需要一种手段，将图片数据解析为一种二维关系，我们希望通过<code>(u,v)</code>访问图像数据上对应的像素值。所以我们需要将图片加载为一个浮点数数组，便于我们访问。这里我们使用第三方库<code>stb_image.h</code>来实现</p>
<p>首先我们创建一个辅助类来帮助我们管理图片信息内容，以提供一个<code>pixel_data(int x,int y)</code>方法，来访问任意像素的8位（unsigned
char）RGB。</p>
<p>我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (push,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STBI_FAILURE_USERMSG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">image</span>(<span class="type">const</span> <span class="type">char</span>* image_file)&#123;</span><br><span class="line">            <span class="keyword">auto</span> filename = std::<span class="built_in">string</span>(image_file);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">load</span>(<span class="string">&quot;../images/&quot;</span> + filename)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load image file&quot;</span> &lt;&lt; image_file &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">image</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] bdata;</span><br><span class="line">            <span class="built_in">STBI_FREE</span>(fdata);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> n = bytes_per_pixel;</span><br><span class="line">            fdata = <span class="built_in">stbi_loadf</span>(filename.<span class="built_in">c_str</span>(), &amp;image_width, &amp;image_height, &amp;n, bytes_per_pixel);</span><br><span class="line">            <span class="keyword">if</span>(fdata == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            byte_per_scanline = bytes_per_pixel * image_width;</span><br><span class="line">            <span class="built_in">convert_to_bytes</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (fdata==<span class="literal">nullptr</span>) ? <span class="number">0</span> : image_width;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (fdata==<span class="literal">nullptr</span>) ? <span class="number">0</span> : image_height;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* <span class="title">pixel_data</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> magenta[] = &#123;<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(bdata==<span class="literal">nullptr</span>) <span class="keyword">return</span> magenta;</span><br><span class="line"></span><br><span class="line">            x = <span class="built_in">clamp</span>(x,<span class="number">0</span>,image_width);</span><br><span class="line">            y = <span class="built_in">clamp</span>(y,<span class="number">0</span>,image_height);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bdata + x*bytes_per_pixel + y*byte_per_scanline;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;      <span class="comment">// 每像素的位数(即通道数)</span></span><br><span class="line">        <span class="type">float</span>* fdata = <span class="literal">nullptr</span>;             <span class="comment">// 浮点像素数据</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* bdata = <span class="literal">nullptr</span>;     <span class="comment">// 8bit像素数据</span></span><br><span class="line">        <span class="type">int</span> image_width = <span class="number">0</span>;                <span class="comment">// 图像宽度</span></span><br><span class="line">        <span class="type">int</span> image_height = <span class="number">0</span>;               <span class="comment">// 图像高度</span></span><br><span class="line">        <span class="type">int</span> byte_per_scanline = <span class="number">0</span>;          <span class="comment">// 宽的像素数量</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// return [low,high)</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">clamp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; low) <span class="keyword">return</span> low;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; high) <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">return</span> high - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title">float_to_byte</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value &lt;= <span class="number">0.0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(value &gt;= <span class="number">1.0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(value*<span class="number">256.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">convert_to_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> total_bytes = bytes_per_pixel * image_height * image_width;</span><br><span class="line">            bdata = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[total_bytes];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> *bptr = bdata;</span><br><span class="line">            <span class="keyword">auto</span> *fptr = fdata;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;total_bytes ; i++,fptr++,bptr++)</span><br><span class="line">                *bptr = <span class="built_in">float_to_byte</span>(*fptr);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>现在我们封装好了一个加载并获取图像内容的<code>image</code>类，我们可以利用它实现图像纹理<code>image_texture</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) : <span class="built_in">image</span>(filename)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(image.<span class="built_in">height</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            u = <span class="built_in">interval</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="built_in">clamp</span>(u);</span><br><span class="line">            <span class="comment">// 由于图片坐标起始位置是从左上角开始</span></span><br><span class="line">            <span class="comment">// 而图形学坐标从左下角开始,所以需要进行反转</span></span><br><span class="line">            v = <span class="number">1.0</span> - <span class="built_in">interval</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="built_in">clamp</span>(v);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">int</span>(u*image.<span class="built_in">width</span>());</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">int</span>(v*image.<span class="built_in">height</span>());</span><br><span class="line">            <span class="keyword">auto</span> pixel = image.<span class="built_in">pixel_data</span>(i,j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale*pixel[<span class="number">0</span>], color_scale*pixel[<span class="number">1</span>], color_scale*pixel[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        image image;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="图像纹理渲染">图像纹理渲染</h3>
<p>现在我们可以尝试将一个图片进行渲染：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(<span class="string">&quot;earthmap.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    cam.aspect_ratio      = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width       = <span class="number">2000</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth         = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">-3.75</span>,<span class="number">4</span>,<span class="number">-9</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(<span class="built_in">hittable_list</span>(globe));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一张地球的贴图（效果如下）：</p>
<figure>
<img src="https://s2.loli.net/2025/12/06/xqdSVgTYlvJirGc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>至此 我们的纹理样式就简单介绍完了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/02/103-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/02/103-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-14/" class="post-title-link" itemprop="url">103:初始图形学(14)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-02 15:27:57" itemprop="dateCreated datePublished" datetime="2025-12-02T15:27:57+08:00">2025-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-03 15:34:25" itemprop="dateModified" datetime="2025-12-03T15:34:25+08:00">2025-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，上一次实现了物体运动下的图形学渲染。实现了动态模糊的构建。</p>
<h2 id="包围体积层级">包围体积层级</h2>
<p>现在随着我们场景的复杂化，和对图片质量的提升，有时候渲染一张照片都需要十几分钟。为了让代码运行的更快，我们需要引入一个新的结构
<strong>包围体积层级BVH</strong>，以优化程序渲染的性能。</p>
<p>射线 -
对象求交，是光线追踪过程中的主要性能瓶颈，运行的时间和物体的数量呈线性关系。每当我们发射一条射线，就需要对场景内的所有物体进行求交判断。但是实际上和很多物体的求交是没有必要的，我们向天空发射的一条光线并不会和地上的物体有所交集。</p>
<p>所以我们为了优化这个过程，我们需要避免不必要的射线 -
对象求交计算，接下来我们要学习的方法就是通过包围体积层次来实现对求交场景的优化。</p>
<h3 id="关键思想">关键思想</h3>
<p>为一组对象创建一个完全包围所有对象的包围盒，假如射线会错过这个包围盒，那么它一定会错过这个包围盒中的所有物体，反之，则有可能击中盒中的任意一个对象，所以我们的思想如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="包围体积的层级">包围体积的层级</h3>
<p>为了提高计算的效率，使得处理时间的增长速度慢于物体数量的增长。首先我们需要构建有一个层次化的包围体结构，这里我们通过自顶向下的方法，生成我们的包围体积的层级结构。</p>
<p>一开始我们需要构建一个层次化的包围体结构，用大的包围体包住一群物体，再逐层细化，就像下面这样：</p>
<figure>
<img src="https://s2.loli.net/2025/12/02/hiExpVKkSr8UoDW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以写出以下伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hit purple)</span><br><span class="line">    hit0 = hits blue enclosed objects</span><br><span class="line">    hit1 = hits red enclosed objects</span><br><span class="line">    <span class="keyword">if</span>(hit0 or hit1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> and info of closer hit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当我们确定击中紫色包围盒时，分别对里面的蓝色组和红色组进行分析，从而进一步缩小碰撞检测的范围</p>
<h3 id="轴对齐边界框aabbs">轴对齐边界框(AABBs)</h3>
<p>要让整个层次结构高效工作，我们需要要一个好的划分方式，而且我们需要一个较快的检测光线和包围体相交的算法，否则我们检测相交的速度会抵消掉包围结构层次带来的加速效果。这里我们选择轴对齐包围盒作为我们的包围体。我们通常将其称为AABB。</p>
<p>接下来我们需要了解光线和AABB相交检测的slab方法：</p>
<p>首先我们需要知道什么是片层(Slab)，片层是在一个坐标轴方向上，由两个平行平面围成的空间区域，比如在
x 轴方向，若 AABB 的 x 范围是 [x_min, x_max]，那么这个 slab 就是所有满足
<code>x_min ≤ x ≤ x_max</code>
的点。在我们要用到的3D场景中，<code>AABB = x-slab &amp;&amp; y-slab &amp;&amp; z-slab</code>。</p>
<p>理解片层之后，我们检测碰撞的关键就在于计算光线和不同片层之间的交点，其中射线的函数定于为<span
class="math inline"><em>P</em>(<em>t</em>) = <em>Q</em> + <em>t</em><em>d</em></span>，我们可以求出其在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub><em>t</em></span>平面的交点为：
<span class="math display">$$
\begin{align*}
x_0 &amp;= Q_x + t_0d_x \\
t_0 &amp;= \frac{x_0 - Q_x}{d_x} \\
t_1 &amp;= \frac{x_1 - Q_x}{d_x}
\end{align*}
$$</span>
知道光线与各个片层之间的交点之后，我们可以进一步判断光线和AABB的相交情况了，以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/12/02/YKCFflJMg4nLVIi.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是一个二维的AABB场景，上面的射线和x、y片层中的交集段并没有重叠，所以我们知道射线并没有和AABB发生交集，下面的射线和x、y片层的交集段发生了重叠，所以说射线和AABB之间是有交集的。</p>
<h3 id="与aabb的射线交">与AABB的射线交</h3>
<p>上图我们可以用于以下伪代码确定射线是否和AABB发生碰撞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interval_x &lt;- compute_intersection_x(ray, x0, x1)</span><br><span class="line">interval_y &lt;- compute_intersection_y(ray, y0, y1)</span><br><span class="line"><span class="keyword">return</span> overlaps(interval_x, interval_y)</span><br></pre></td></tr></table></figure>
<p>相应的三维版本如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interval_x &lt;- compute_intersection_x(ray, x0, x1)</span><br><span class="line">interval_y &lt;- compute_intersection_y(ray, y0, y1)</span><br><span class="line">interval_z &lt;- compute_intersection_z(ray, z0, z1)</span><br><span class="line"><span class="keyword">return</span> overlaps(interval_x, interval_y, interval_z)</span><br></pre></td></tr></table></figure>
<p>我们已经知道了怎么求出射线和片层的相交区间，我们需要进一步的检测这些相交区间是否有交集，现在，我们的关键在于实现<code>overlaps</code>了，在此之前我们需要考虑以下几种特殊情况：</p>
<ul>
<li>如果射线沿着负x方向运动，我们的计算得到的区间会发生反转，所以我们始终需要根据<code>min</code>和<code>max</code>来标识我们的区间</li>
<li>当<span
class="math inline"><em>d</em><sub><em>x</em></sub></span>为0
或接近0时，会求得t为<code>-infinity/+infinity</code>，我们通过min/max可以解决这个问题</li>
<li>当<span
class="math inline"><em>d</em><sub><em>x</em></sub></span>为0 但<span
class="math inline"><em>Q</em><sub><em>x</em></sub></span>在AABB的界限上/界限内时，加缓冲防止边界问题</li>
</ul>
<p>现在我们可以写出伪函数<code>overlaps</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">overlaps</span><span class="params">(t_interval1, t_interval2)</span></span><br><span class="line">    t_min = max(t_interval.min, t_interval2.min)</span><br><span class="line">    t_max = min(t_interval.max, t_interval2.max)</span><br><span class="line">    <span class="keyword">return</span> t_max&gt;t_min</span><br></pre></td></tr></table></figure>
<p>对于第三种特殊情况，此时我们无法给出准确的<code>t_min</code>和<code>t_max</code>，所以我们将这个情况称之为<code>NaN</code>，这里我们需要进行手动的处理，为区间添加一个padding，将NaN的情况视作<code>fasle</code></p>
<p>为此我们需要为<code>interval</code>添加一个<code>expend</code>函数，它给区间填充给定的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interval</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function">interval <span class="title">expand</span><span class="params">(<span class="type">double</span> delta)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> padding = delta/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">interval</span>(min-padding, max+padding);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> interval empty,universe;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>
<p>现在，我们可以开始实现AABB类了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        interval x,y,z;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">aabb</span>() &#123;&#125;   <span class="comment">// 默认为空</span></span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> interval&amp; x, <span class="type">const</span> interval&amp; y, interval&amp; z)</span><br><span class="line">            : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; a, <span class="type">const</span> point3&amp; b)&#123;</span><br><span class="line">            <span class="comment">// 这里的a和b是AABB盒的对顶角</span></span><br><span class="line">            x = (a[<span class="number">0</span>]&lt;=b[<span class="number">0</span>]) ? <span class="built_in">interval</span>(a[<span class="number">0</span>],b[<span class="number">0</span>]) : <span class="built_in">interval</span>(b[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line">            y = (a[<span class="number">1</span>]&lt;=b[<span class="number">1</span>]) ? <span class="built_in">interval</span>(a[<span class="number">1</span>],b[<span class="number">1</span>]) : <span class="built_in">interval</span>(b[<span class="number">1</span>],a[<span class="number">1</span>]);</span><br><span class="line">            z = (a[<span class="number">2</span>]&lt;=b[<span class="number">2</span>]) ? <span class="built_in">interval</span>(a[<span class="number">2</span>],b[<span class="number">2</span>]) : <span class="built_in">interval</span>(b[<span class="number">2</span>],a[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> interval&amp; <span class="title">axis_interval</span><span class="params">(<span class="type">int</span> n)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> y;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> z;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval <span class="type">ray_t</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="type">const</span> point3&amp; ray_orig = r.<span class="built_in">origin</span>();</span><br><span class="line">            <span class="type">const</span> vec3&amp; ray_dir = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> axis=<span class="number">0</span>;axis&lt;<span class="number">3</span>;axis++)&#123;</span><br><span class="line">                <span class="type">const</span> interval&amp; ax = <span class="built_in">axis_interval</span>(axis);</span><br><span class="line">                <span class="type">const</span> <span class="type">double</span> adinv = <span class="number">1.0</span> / ray_dir[axis];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t0 = (ax.min - ray_orig[axis]) * adinv;</span><br><span class="line">                <span class="keyword">auto</span> t1 = (ax.max - ray_orig[axis]) * adinv;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 收缩区间（取交集）</span></span><br><span class="line">                <span class="keyword">if</span>(t0 &lt; t1)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t0 &gt; <span class="type">ray_t</span>.min) <span class="type">ray_t</span>.min = t0;</span><br><span class="line">                    <span class="keyword">if</span>(t1 &lt; <span class="type">ray_t</span>.max) <span class="type">ray_t</span>.max = t1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t1 &gt; <span class="type">ray_t</span>.min) <span class="type">ray_t</span>.min = t1;</span><br><span class="line">                    <span class="keyword">if</span>(t0 &lt; <span class="type">ray_t</span>.max) <span class="type">ray_t</span>.max = t0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 说明无交点</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="type">ray_t</span>.min &gt;= <span class="type">ray_t</span>.max)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里的关键在于<code>hit</code>函数，我们通过区间收缩的方式实现对交集的判断。</p>
<h3 id="为可击中类创建包围盒">为可击中类创建包围盒</h3>
<p>现在我们需要为所有的可击中类构建一个包围盒，对于单个的物体，我们将其包围盒视作包围结构层次中的叶子节点，这个我们之后会提到。</p>
<p>由于我们的物体有部分是动画的，所以我们为其生成的包围盒边界应该等于其运动范围，首先，我们需要升级我们的<code>hittable</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">hittable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于静态和动态的球体，我们很容易为其创建出包围盒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span>: <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; static_center, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(static_center,<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rvec = <span class="built_in">vec3</span>(radius,radius,radius);</span><br><span class="line">            bbox = <span class="built_in">aabb</span>(static_center - rvec, static_center + rvec);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 动态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center1, <span class="type">const</span> point3&amp; center2, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center1,center2-center1), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rvec = <span class="built_in">vec3</span>(radius,radius,radius);</span><br><span class="line">            <span class="function">aabb <span class="title">box1</span><span class="params">(center.at(<span class="number">0</span>) - rvec, center.at(<span class="number">0</span>) + rvec)</span></span>;</span><br><span class="line">            <span class="function">aabb <span class="title">box2</span><span class="params">(center.at(<span class="number">1</span>) - rvec, center.at(<span class="number">1</span>) + rvec)</span></span>;</span><br><span class="line">            bbox = <span class="built_in">aabb</span>(box1,box2);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里注意到我们直接将box1和box2合并成了一个新的包围盒区间，这是我们新定义的一种构造方法，也便于之后的包围盒合并：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">aabb</span>(<span class="type">const</span> aabb&amp; box1, <span class="type">const</span> aabb&amp; box2)&#123;</span><br><span class="line">       x = <span class="built_in">interval</span>(box<span class="number">1.</span>x, box<span class="number">2.</span>x);</span><br><span class="line">       y = <span class="built_in">interval</span>(box<span class="number">1.</span>y, box<span class="number">2.</span>y);</span><br><span class="line">       z = <span class="built_in">interval</span>(box<span class="number">1.</span>z, box<span class="number">1.</span>z);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 这里用到的Interval合并形式，来自于interval类中新定义的合并构造</span></span><br><span class="line"><span class="built_in">interval</span>(<span class="type">const</span> interval&amp; a,<span class="type">const</span> interval&amp; b)&#123;</span><br><span class="line">       min = a.min &lt;= b.min ? a.min : b.min;</span><br><span class="line">       max = a.max &gt;= b.max ? a.max : b.max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建对象列表的边界框">创建对象列表的边界框</h3>
<p>现在我们需要更新对象列表<code>hittable_list</code>，现在列表中的物体被创建时，会生成相应的包围盒边界。而我们需要随着每个新子节点的加入逐步的更新边界框，于是我们有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    aabb bbox;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">	....</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; </span><br><span class="line">        objects.<span class="built_in">push_back</span>(object); </span><br><span class="line">        bbox = <span class="built_in">aabb</span>(bbox,object-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bvh节点类">BVH节点类</h3>
<p>BVH本质上也是一个<code>hittable</code>
，它代表一组几何体，光线可以击中它以进行相交判断。我们将它视作一个对象的容器，它封装了几何体，通过包围盒相交测试进行加速检测。</p>
<p>我们通过一个类来实现它，它既可以是节点，也可以是整棵树的根：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AABB.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span>: <span class="keyword">public</span> hittable&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">            <span class="comment">// 待具体实现</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">bvh_node</span>(hittable_list list): <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 重载并使用了上面的初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval <span class="type">ray_t</span>, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bbox.<span class="built_in">hit</span>(r,<span class="type">ray_t</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, <span class="type">ray_t</span>, rec);</span><br><span class="line">            <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, <span class="type">ray_t</span>, rec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> hit_left||hit_right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; left;</span><br><span class="line">        shared_ptr&lt;hittable&gt; right;</span><br><span class="line">        aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来的重点在于怎么将<code>hittable_list</code>构建成我们想要的BVH。我们希望每个BVH下至多有两个左右节点，但是我们以什么为依据进行划分呢，以下是我们的做法：</p>
<ul>
<li>xyz轴任选其一</li>
<li>根据轴值进行排序</li>
<li>将子树对半存放</li>
</ul>
<p>当我们构建BVH的递归生成时，会有以下几种情况：</p>
<ul>
<li>list表中剩余一个物体，我们让BVH节点的子树均指向它</li>
<li>list表中剩余两个物体，我们让BVH节点的左右子树分别指向</li>
<li>list表中有两个以上物体，我们取一轴进行排序，递归进行生成BVH</li>
</ul>
<p>因此，我们的BVH生成的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bvh_node(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">    <span class="type">int</span> axis = random_int(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis==<span class="number">0</span>) ? box_x_compare : (axis==<span class="number">1</span>) ? box_y_compare : box_z_compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(object_span == <span class="number">1</span>)&#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object_span == <span class="number">2</span>)&#123;</span><br><span class="line">        left = objects[start];</span><br><span class="line">        right = objects[start+<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sort(<span class="built_in">std</span>::begin(objects)+start, <span class="built_in">std</span>::begin(objects)+end, comparator);</span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = make_shared&lt;bvh_node&gt;(objects, start, mid);</span><br><span class="line">        right = make_shared&lt;bvh_node&gt;(objects, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    bbox = aabb(left-&gt;bounding_box(), right-&gt;bounding_box());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>sort</code>使用的判断逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis_index</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> a_axis_interval = a-&gt;<span class="built_in">bounding_box</span>().<span class="built_in">axis_interval</span>(axis_index);</span><br><span class="line">            <span class="keyword">auto</span> b_axis_interval = b-&gt;<span class="built_in">bounding_box</span>().<span class="built_in">axis_interval</span>(axis_index);</span><br><span class="line">            <span class="keyword">return</span> a_axis_interval.min &lt; b_axis_interval.min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过实际上我们是可以对这一部分优化的。我们希望构造出来的BVH树是均衡的，所以每次对场景内的物体进行划分时，我们希望，左右子树的分布是均衡的，这就要求我们每次选择的检测轴应该是边长最长的轴。为此我们需要一个函数为我们计算出包围盒的范围，我们将以此为依据实现更加平衡的BVH树结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">            bbox = aabb::empty;</span><br><span class="line">    		<span class="comment">// 对区间内的所有包围盒取并集 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> object_index = start; object_index &lt; end; object_index++)</span><br><span class="line">                bbox = <span class="built_in">aabb</span>(bbox, objects[object_index]-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">            <span class="comment">// 选择边长最大的维度 作为划分轴</span></span><br><span class="line">            <span class="type">int</span> axis = bbox.<span class="built_in">longest_axis</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> comparator = (axis==<span class="number">0</span>) ? box_x_compare : (axis==<span class="number">1</span>) ? box_y_compare : box_z_compare;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(object_span == <span class="number">1</span>)&#123;</span><br><span class="line">                left = right = objects[start];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object_span == <span class="number">2</span>)&#123;</span><br><span class="line">                left = objects[start];</span><br><span class="line">                right = objects[start<span class="number">+1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sort</span>(std::<span class="built_in">begin</span>(objects)+start, std::<span class="built_in">begin</span>(objects)+end, comparator);</span><br><span class="line">                <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">                left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid);</span><br><span class="line">                right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bbox = <span class="built_in">aabb</span>(left-&gt;<span class="built_in">bounding_box</span>(), right-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>为了实现对最长轴的判断 和
包围盒并集的实现，我们需要优化我们的<code>aabb</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 取最长轴</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">longest_axis</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.<span class="built_in">size</span>() &gt; y.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> x.<span class="built_in">size</span>() &gt; z.<span class="built_in">size</span>() ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> y.<span class="built_in">size</span>() &gt; z.<span class="built_in">size</span>() ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 空包围盒 与 无限包围盒</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> aabb empty, universe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> aabb aabb::empty = <span class="built_in">aabb</span>(interval::empty, interval::empty, interval::empty);</span><br><span class="line"><span class="type">const</span> aabb aabb::universe = </span><br><span class="line">    <span class="built_in">aabb</span>(interval::universe, interval::universe, interval::universe);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们就实现了图形的加速渲染。太爽了。</p>
<p>速度差不多提升3-4倍，随着场景规模的提升，这个提升的效果更加明显，可以借下面这个图来感受一下。我们差不多实现了从<code>O(n)</code>到<code>O(logn)</code>的优化：</p>
<figure>
<img src="https://s2.loli.net/2025/12/03/xng6zXZkY4U8GOK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/" class="post-title-link" itemprop="url">102:日后安排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-01 12:01:20 / 修改时间：12:36:00" itemprop="dateCreated datePublished" datetime="2025-12-01T12:01:20+08:00">2025-12-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>795</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近思绪有点乱，感觉要做的事情很多，但是不知道何从下手，所以我要从头缕一缕现在的问题。</p>
<p>首先是分析一下现阶段我要做的事情，按优先级进行分类：</p>
<ul>
<li>课程任务：（这几门课是这个学期的大头）
<ul>
<li><strong>离散数学</strong>：这个课我现在最大的问题就是没有明确的学习路线（对着书硬啃？找个网课学？）</li>
<li><strong>概率论</strong>：这个课我的进度很慢，但是有一高数的课程可以跟着学习，可以从现在开始每天学一点</li>
<li>操作系统：这个课我学的还行，但是我对自己有一定的要求，不想只是简单学会</li>
<li><strong>计算机组成原理</strong>：这个课的应试考法我也不是很熟悉，对于数据的部分不是很熟悉，其他的还可以，但是我对自己也有一定的有要求</li>
<li>数据结构：这门课学的还行，但是不熟悉应试的考法</li>
<li>密码学：目前不清楚考试考察的方向，需要花时间巩固</li>
<li>Python：现在要开始准备大作业</li>
<li><strong>Java</strong>：需要对着PPT再进一步学习，需要准备大作业</li>
<li>毛思想：需要了解一下考什么，和题型。考前需要花时间学习一下</li>
</ul></li>
<li>课外任务：
<ul>
<li><strong>科研任务</strong>：科研训练从和开始入手，怎么去查看论文，怎么去找创新点，怎么去构建项目。</li>
<li>个人任务：
<ul>
<li>锻炼身体：需要加强身体的锻炼和饮食的均衡</li>
<li>练习英语：提升英语水平</li>
<li>CTF二进制安全竞技水平</li>
<li>学习新知识</li>
<li>看书阅读</li>
</ul></li>
</ul></li>
</ul>
<p>这里加粗的部分是需要着重注意的地方，那么我该怎么安排呢？</p>
<h3 id="生活上的安排">生活上的安排</h3>
<p>首先是睡眠，每天十二点必须上床，手机最多玩到十二点半就要睡觉。有早八就七点一十起床，没早八就八点起床。周日可以休息久一点</p>
<p>每天早上至少喝一瓶牛奶，还有早餐。在寝室的期间要喝热水。平时尽量不喝奶茶喝其他饮料，也要控制自己的饮食，不能像以前一样想怎么吃就怎么吃。</p>
<p>平时要坚持锻炼，一周至少锻炼4次，两次耐力，两次力量。没事的时候可以在寝室举哑铃</p>
<p>每天要积极一点，心情不好就出去走一走，要开心。</p>
<p>节假日和周六晚上可以玩久一点游戏，平时尽量少玩一点。要珍惜现在的时间。</p>
<h3 id="学习上的安排">学习上的安排</h3>
<p>除掉周日，单日学概率论，双日学离散数学，每天至少完成一个章节的学习。在什么课上学什么的知识，不能拆东墙补西墙。</p>
<p>这周之内要开始科研训练的内容，首先给出自己一个项目的框架，可行demo</p>
<p>课余的时间学什么由自己决定，优先课程的任务。</p>
<h3 id="感情上的安排">感情上的安排</h3>
<p>别想太多 要接受分开的事实 继续走下去</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">101:DWADRF信息解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-24 10:26:27 / 修改时间：10:17:49" itemprop="dateCreated datePublished" datetime="2025-11-24T10:26:27+08:00">2025-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上个学期也尝试了解过这些，但是那个时候还没有接触编译链接，对DWARF信息的理解不够深刻。最近有计划了解一下调试器的原理，所以重新捡起来好好学一遍。</p>
<p>我参考的教程是DWARF的官方介绍文档<a
target="_blank" rel="noopener" href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf">Debugging
using DWARF</a>，作为对其的简单了解</p>
<h2 id="dwarf概述">DWARF概述</h2>
<p>一开始我并不知道怎么说明这一部分，AI给了我一个很好的比方。如果说程序是一个设计图纸（源代码），它事无巨细的包含一个城市的所有信息，那么编译器就是一个工程师，他根据设计图纸将建造出城市（可执行文件）。而DWARF信息，就相当于这个城市的地图，它告诉你每条街道（机器指令，数据信息）对应设计图中的哪个位置（源代码）。而调试器就是一个导游，它根据这个地图带你去任何地方。</p>
<p>现代的编程语言大多是块状结构的，一个实体往往包含着更多的实体，每个实体中可能都有若干个数据和函数定义，那么在这个实体中，就产生了词法的作用域。这个定义仅在被定义的作用域中有意义。</p>
<p>我们可以用一个常见的文件结构来描述这种特征：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源文件</span><br><span class="line">├── 函数A</span><br><span class="line">│   ├── 变量x</span><br><span class="line">│   ├── 语句块1</span><br><span class="line">│   │   ├── 变量y (只在当前块内有效)</span><br><span class="line">│   │   ├── 函数C</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── 函数B</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure>
<p>对于数据和函数一类的内容，我们按照编译链接的习惯，称之为符号。一般情况下，一个符号的作用域属于当前块（也可以通过关键词指定作用域范围）。所以我们要查找特定符号的定义，先从当前作用域中查找定义，然后从连续的外层定义域中依次查找，直到找到该符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var;          <span class="comment">// 全局作用域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">()</span> &#123;     <span class="comment">// 函数作用域</span></span><br><span class="line">    <span class="type">int</span> local_var;       <span class="comment">// 函数内有效</span></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="type">int</span> block_var;   <span class="comment">// 只在if块内有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block_var 在这里结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接的过程中，这些信息会被抛弃或者是简化。因为编译器只在乎对内存和寄存器的管理和操作，所以我们很难根据机器指令去恢复这些信息。</p>
<p>所以这里我们就需要DWARF信息来保存这些信息，DWARF和程序语义一样，通过树状结构来组织信息。DWARF中的所有描述性实体都包含在一个父条目中，且实体中还可以包含更多节点，这些节点可能表示类型，变量或是函数…一个常见的结构可以是下面这样的：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译单元 (CU)</span><br><span class="line">├── 函数: main</span><br><span class="line">│   ├── 类型: int</span><br><span class="line">│   ├── 变量: argc</span><br><span class="line">│   ├── 变量: argv</span><br><span class="line">│   └── 代码位置: 0x400500-0x400600</span><br><span class="line">├── 函数: add</span><br><span class="line">│   ├── 参数: a (int)</span><br><span class="line">│   ├── 参数: b (int) </span><br><span class="line">│   ├── 局部变量: result (int)</span><br><span class="line">│   └── 代码位置: 0x400610-0x400650</span><br><span class="line">└── 全局变量: global_counter</span><br></pre></td></tr></table></figure>
<p>而接下来，我们将学习怎么去理解这些常见的DWARF信息</p>
<h2 id="调试信息条目die">调试信息条目（DIE）</h2>
<h3 id="标签与属性">标签与属性</h3>
<p>DWARF 中的基本描述实体是<strong>调试信息条目</strong>。一个 DIE
包含一个<strong>标签</strong>——用于指定该 DIE
描述的是什么，以及一个<strong>属性列表</strong>——用于填充细节并进一步描述该实体。除了最顶层的
DIE 外，每个 DIE 都包含在或归属于一个父 DIE，并且可能拥有兄弟 DIE 或子
DIE。属性可以包含各种值：常量（例如函数名）、变量（例如函数的起始地址），或者指向另一个
DIE 的引用（例如函数返回值的类型）</p>
<p>例如下图中就展示了一个简单的程序的DWARF信息：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/Gs3CVb6do4cpXUL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最上面的是CU编译单元，它作为DWARF信息的根节点，包含了两个下级DIE。其中一个描述main的信息，如返回类型、行号、函数起始地址…另一个DIE描述的是int类型，通过子程序DIE中的Type属性而被引用。</p>
<h3 id="die类型">DIE类型</h3>
<p>DIE可以分为两种通用类型：</p>
<ul>
<li>一类用来描述数据的DIE</li>
<li>另一类用来描述函数或者其他可执行代码</li>
</ul>
<h2 id="基础类型-数据类型">基础类型-&gt;数据类型</h2>
<p>大多数语言都有复杂的数据类型体系，例如内置数据类型、指针、数据结构、自定义结构等类型。这些基于语言底层设计的主要类型我们称之为<strong>基础类型</strong>，其他的数据类型都由这些基础类型构造而成。</p>
<p>一个具名变量由一个拥有多种属性的 DIE
描述，其中一个属性是对类型定义的引用。下图就描述了一个名为<code>x</code>的整型变量：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/BOJYREo8Zib5m9w.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>int</code>
的基础类型将其描述为一个占用四个字节的有符号二进制整数。用于变量
<code>x</code> 的 <code>DW_TAG_variable</code> DIE
给出了它的名称和一个类型属性，该属性引用了基础类型 DIE。</p>
<p>同样的，DWARF
也可以使用基础类型通过组合来构建其他数据类型定义。一个新类型是作为对另一个类型的补充而创建的。以下面这个<code>int* px</code>的DIE信息为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/7O2vFEV9fsyQbSK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个 DIE 定义了一个指针类型，指明其大小为四个字节，并继而引用了
<code>int</code> 基础类型。</p>
<p>还可以更复杂的，比如加上关键词去限定这个变量的属性和类型，也可以将更多类型的DIE链接在一起以描述更复杂的数据类型，例如<code>const char ** argv</code>的DIE信息如下：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/frAqTD1J3j2dmNK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>总的来说，在DWARF信息中，我们通过组合基本类型的方式来表示程序语言中的数据类型。这样我们无需了解所有程序语言的数据结构，也可以描述出数据类型的信息。</p>
<h2 id="常见类型">常见类型</h2>
<h3 id="数组">数组</h3>
<p>数组类型由<code>DW_TAG_array_type</code>表示，对于<code>int arr[10]</code>，其一般DWARF结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_array_type</span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x00000045</span>&gt;</span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_subrange_type</span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">                        DW_AT_upper_bound           <span class="number">9</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000003e</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_unsigned</span><br><span class="line">                      DW_AT_name                  <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000045</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000004c</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  arr</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000005</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x034040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004040</span><br></pre></td></tr></table></figure>
<p>其中<code>DW_TAG_subrange_type</code>用来存储描述数组维度的范围（下标范围），这里不仅指示了下标的上界<code>DW_AT_upper_bound 9</code>也指明了下标的数据类型<code>DW_AT_type &lt;0x0000003e&gt;</code></p>
<p>我们可以看到左边的<code>&lt;1&gt; &lt;2&gt;</code>的符号，这代表当前条目在条目树结构中的深度。</p>
<p>理解了数据类型的结构分析之后，我们看到变量的定义信息：</p>
<ul>
<li>DW_AT_name：变量名</li>
<li>DW_AT_decl_line：变量的定义行</li>
<li>DW_AT_decl_column：变量的定义列</li>
<li>DW_AT_type：变量定义类型</li>
<li>DW_AT_external：变量的作用域范围（全局符号）</li>
<li>DW_AT_location：变量在内存中的存储位置</li>
</ul>
<p>通过这些信息，我们就可以还原出数组的数据类型、存储结构、以及在源代码中的定义位置等信息</p>
<h3 id="结构类联合体接口">结构、类、联合体、接口</h3>
<p>大多数的语言都支持将各种数据类型的组合到一个结构体中，只不过不同的语言叫法不一样而已，这里的我们就简单的介绍一下结构体和类的标签。</p>
<p>结构体相较于类更加纯粹，它主要对数据进行封装，将不同的数据类型整合成一个大的结构体，在结构体中通过字段对这些数据进行索引，我们可以看下它的DWARF结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_structure_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  age</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000002</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x00000009</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000044</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000b</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000059</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000052</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000059</span>&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000005f</span>&gt;</span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000005f</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000066</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  student</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000002</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x032040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004020</span><br></pre></td></tr></table></figure>
<p>结构体类型由<code>DW_TAG_structure_type</code>进行表示，这里我们定义的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读到以下结构体的属性：</p>
<ul>
<li>DW_TAG_member：结构体的成员</li>
<li>DW_AT_data_member_location：字段在结构体中偏移值，我们可以通过这个值访问结构体中的成员</li>
<li>DW_AT_byte_size：结构体的大小（这里可以看出内存对齐了）</li>
<li>还有典型的一些属性…</li>
</ul>
<p>然后是类的，类相当于结构体的plus版，既可以组合数据类型，也可以包含函数方法，不过对于类的内存分布，我暂时也不是很清楚。我们可以看看类的<code>DWARF</code>信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002a</span>&gt;    DW_TAG_class_type</span><br><span class="line">                      DW_AT_name                  Student</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000007</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  ID</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000005</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000d</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000043</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000008</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000f</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000074</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000051</span>&gt;      DW_TAG_subprogram</span><br><span class="line">                        DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_name                  getID</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000009</span><br><span class="line">                        DW_AT_decl_column           0x0000000d</span><br><span class="line">                        DW_AT_linkage_name          _ZN7Student5getIDEv</span><br><span class="line">                        DW_AT_type                  &lt;0x0000006d&gt;</span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">                        DW_AT_declaration           <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_object_pointer        &lt;0x00000066&gt;</span><br><span class="line">&lt; 3&gt;&lt;0x00000066&gt;        DW_TAG_formal_parameter</span><br><span class="line">                          DW_AT_type                  &lt;0x00000080&gt;</span><br><span class="line">                          DW_AT_artificial            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 1&gt;&lt;0x0000006d&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000074&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x00000079&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000079&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000001</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000080&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x0000002a&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000085&gt;    DW_TAG_const_type</span><br><span class="line">                      DW_AT_type                  &lt;0x00000080&gt;</span><br></pre></td></tr></table></figure>
<p>类的类型由<code>DW_TAG_class_type</code>进行表示，这里我们定义的类是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    private:</span><br><span class="line">        <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读以下类的信息：</p>
<ul>
<li>DW_TAG_subprogram：这里表示这是类的一个方法，之后会详细描述一下这个标签</li>
<li>DW_AT_accessibility：用来指出数据和方法的成员属性（公/私），默认为私有，<code>DW_ACCESS_public</code>为公有</li>
<li>DW_AT_object_pointer：这个是隐含得参数指向this指针参数。</li>
</ul>
<p>类由还有很多标签，但是这里不过多进行讲解。</p>
<h3 id="变量">变量</h3>
<p>变量通常相当简单。它们有一个名称，代表一块可以存储某种值的内存（或寄存器）。变量可以包含的值的种类，以及对其修改方式的限制（例如，是否为
<code>const</code>），都由变量的类型来描述。</p>
<p>区分变量的关键在于其值的存储位置和其作用域。变量的作用域定义了变量在程序中的哪些位置是已知的，并在某种程度上由变量声明的位置决定。在
C
语言中，在函数或块内声明的变量具有函数或块作用域。在函数外声明的变量具有全局或文件作用域。这允许在不同文件中定义同名的变量而不会冲突，也允许不同的函数或编译单元引用同一个变量。</p>
<p>DWARF
将变量分为三类：<strong>常量</strong>、<strong>形式参数</strong>和<strong>变量</strong>。</p>
<ul>
<li><strong>常量</strong>用于那些语言本身包含真正具名常量的情况，例如
Ada 参数。（C 语言本身没有将常量作为语言的一部分。声明一个
<code>const</code>
变量只是表示你不能在没有使用显式类型转换的情况下修改变量。）</li>
<li><strong>形式参数</strong>表示传递给函数的值。我们稍后再讨论这个。</li>
</ul>
<p>大多数变量都有一个<strong>位置属性</strong>，用于描述变量的存储位置。</p>
<ul>
<li>在最简单的情况下，变量存储在内存中并具有<strong>固定地址</strong>。</li>
<li>但是许多变量，例如在 C
函数内声明的变量，是<strong>动态分配</strong>的，定位它们需要进行一些（通常简单的）计算。例如，一个局部变量可能在栈上分配，定位它可能简单到只需给帧指针加上一个固定偏移量。</li>
<li>在其他情况下，变量可能存储在<strong>寄存器</strong>中。</li>
<li>其他变量可能需要更复杂一些的计算来定位数据。作为 C++
类成员的变量可能需要更复杂的计算来确定基类在派生类中的位置。</li>
</ul>
<h3 id="可执行代码段函数与子程序">可执行代码段：函数与子程序</h3>
<p>这里的函数和子程序实际上是同一个东西，硬要细分的话，函数是有返回值的，而子程序没有（我们更多是利用子程序的副作用）。我们可以看一下函数会包含的DWARF信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000065</span>&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_name                  hello</span><br><span class="line">                      DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.c</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br><span class="line">                      DW_AT_decl_column           0x00000005</span><br><span class="line">                      DW_AT_prototyped            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                      DW_AT_low_pc                0x00001129</span><br><span class="line">                      DW_AT_high_pc               &lt;offset-from-lowpc&gt; 24 &lt;highpc: 0x00001141&gt;</span><br><span class="line">                      DW_AT_frame_base            len 0x0001: 0x9c:</span><br><span class="line">                          DW_OP_call_frame_cfa</span><br><span class="line">                      DW_AT_call_all_calls        <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 2&gt;&lt;0x00000083&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  x</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x0000000f</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x916c:</span><br><span class="line">                            DW_OP_fbreg -20</span><br><span class="line">&lt; 2&gt;&lt;0x0000008e&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  y</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x00000016</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x9168:</span><br><span class="line">                            DW_OP_fbreg -24</span><br></pre></td></tr></table></figure>
<p>首先我们可以看到包含源代码位置信息的三元组（文件、行、列），然后是函数的高低内存范围，一般情概况下，我们默认函数的低内存地址（起始地址）为函数的入口。函数的返回类型，由类型属性指定。</p>
<p>这里需要注意的是<code>DW_OP_call_frame_cfa</code>指定的CFA<code>0x9c</code>。CFA就是函数执行时，其调用者的栈帧的栈顶位置，标志着一个函数栈帧的开始边界。以下图结构为例：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（高地址）</span><br><span class="line">+----------------------+</span><br><span class="line">| ...                  |</span><br><span class="line">| main 的局部变量       | &lt;--- main 函数的栈帧</span><br><span class="line">+----------------------+</span><br><span class="line">| 返回地址              | &lt;--- [!] hello 函数的 CFA 指向这里</span><br><span class="line">+----------------------+------ hello 函数栈帧的“边界”</span><br><span class="line">| 保存的 RBP (帧指针)   | &lt;--- 帧基址 (Frame Base) 常常指向这里</span><br><span class="line">+----------------------+</span><br><span class="line">| hello 的局部变量      |</span><br><span class="line">| ...                  |</span><br><span class="line">|  可能还有保存的寄存器  |</span><br><span class="line">+----------------------+ &lt;--- 当前 RSP 指向这里（栈顶）</span><br><span class="line">（低地址）</span><br></pre></td></tr></table></figure>
<p>在我们的示例中，DWARF信息指出<code>DW_AT_frame_base : DW_OP_call_frame_cfa</code>，所以这里我们的栈基址等于CFA值。基于栈基址，我们就可以对被调用栈帧中的变量进行访问。我们看到<code>DW_AT_location</code>的属性下，通常有<code>DW_OP_fbreg - 偏移值</code>的形式来计算参数在栈帧上的位置。</p>
<p>DWARF不定义函数的调用约定，这一部分有应用程序二进制接口规范确定（ABI）</p>
<h3 id="编译单元">编译单元</h3>
<p>大多数的程序室友多个文件构成的，每个文件会被独立编译，然后与系统库链接成最终的程序，DWARF将每个独立编译的源文件称为一个编译单元</p>
<p>每个编译单元的DWARF数据，都会从一个编译单元调试信息项开始。该调试信息项包含编译过程中的通用信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">0</span>&gt;&lt;<span class="number">0x0000000c</span>&gt;  DW_TAG_compile_unit</span><br><span class="line">                    DW_AT_producer              GNU C17 <span class="number">13.3</span>.<span class="number">0</span> -mtune=generic -march=x86<span class="number">-64</span> -g -O0 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection</span><br><span class="line">                    DW_AT_language              DW_LANG_C11</span><br><span class="line">                    DW_AT_name                  test.c</span><br><span class="line">                    DW_AT_comp_dir              /home/ylin/Program/test</span><br><span class="line">                    DW_AT_low_pc                <span class="number">0x00001129</span></span><br><span class="line">                    DW_AT_high_pc               &lt;offset-from-lowpc&gt; <span class="number">61</span> &lt;highpc: <span class="number">0x00001166</span>&gt;</span><br><span class="line">                    DW_AT_stmt_list             <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>包括：</p>
<ul>
<li>编译器和编译参数</li>
<li>源文件的目录路径和文件名称</li>
<li>编译单元在内存中的起始结束地址（如果编译单元在内存中是连续的）</li>
<li>编译单元占用内存的地址列表（如果编译单元在内存中非连续）</li>
<li>指向调试器行号的指针(DW_AT_stmt_list)</li>
</ul>
<p>编译单元调试信息项是所有该编译单元调试信息的父项。一般情况下，调试信息会先描述数据类型，接着是全局数据，然后再是子函数。</p>
<p>至此基本的DWARF信息就介绍到这里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/100-%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/100-%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">100:感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 20:18:05" itemprop="dateCreated datePublished" datetime="2025-11-22T20:18:05+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:19" itemprop="dateModified" datetime="2025-11-29T13:49:19+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>也是好不容易水到第100篇了，我本来准备了好多台词的，但是不知道说什么。我就记录一下我的几个感悟吧</p>
<h3 id="学会放弃">学会放弃</h3>
<p>刚开始觉得只要努力学就会有所收获吧，如果没学会就是自己比较笨什么的。但事实不是这样的，认知一个领域的过程是循序渐进的，就像游戏里的科技树一样，解锁一个科技需要一大堆前置科技。有时候一些知识也是这样，所以一开始学不会一些东西很正常，这个时候应该先放一放，去试试其他的方向，或者是从前置的内容开始学。</p>
<p>关于这一点我的感受就很明显吧，我每次遇到学不会的东西，就会放弃然后去学其他的东西。但是过一段时间之后再来看这些内容反而有一种水到渠成的感觉，我猜测一个是知识体系上的补齐，还有一个是你对这个领域的认知能力也在慢慢变强。你能对一些内容做出自己的解释，能说服自己我认为是理解一个知识的开始吧。不管你的猜想是不是对的，只要他能补齐你对这方面的认识，你就可以视作自己理解了。之后随着需求和认知的提升，再一步步完善自己对这方面的理解吧。</p>
<p>我发现生活中也有很多这样的事情，给你一种无从下手或者无能为力的感觉。如果实在不行就放弃吧，可以之后再试试，先把其他的事情做好，也许很多事情时间会给出答案，因为我们每天都在慢慢长大。只要不放弃从头再来的决心，迟早有一天也能找到自己的答案。</p>
<h3 id="主动学习">主动学习</h3>
<p>大家都在学习凭什么，也不存在谁比谁笨，为什么有的人能学会有的人不能呢？我认为这不是努不努力的事情，大家回宿舍都是打游戏，如果能认真学下去，活该他学的好。我觉得更多是对于这个知识的态度吧，有的人是被动的接受的，有的人是主动的接受的。主动接受的话你就会发现很多问题啥的，就是你的脑子里的东西和答案不一样，或者你脑子里没有这个东西。在这个不断碰撞思考的过程中，你的知识体系会被答案说服或者补全，这样你的认知体系就会慢慢完善，感觉这个就是高中老师说的框架/查漏补缺，这个就是主动学习。但是大多数人就是书上讲得是啥就是啥，老师说啥就是啥，一上来就记住正确答案，对知识很内容知其然不知其所以然，这种效率就很差。中国传统的应试教育就是这样的，所以大家都是这样的，我也是这样的。</p>
<p>这也是为什么比起看网课我更喜欢看书，看网课的时候，老师叽里咕噜讲个不停，你很难有自己思考的时间，更别说有时候发呆什么的。但是看书不一样，你不懂得时候可以对着书上得那句话发呆，等你发完呆它还在那里，你就有充分得时间去理解它，或者再来一遍。就是这个时候你的大脑是属于你自己的，你的想法不是跟着别人走的，更自由一点。这样你就能做出更多自己的思考。</p>
<p>我知道这样子很不好，但是有时候动脑子真的好累，偶尔主动学习一些重要的东西也还行。我的话有时候突然想做项目或者刷视频看到什么好帅的东西，我会迫不及待的去了解一下。主要是对游戏方面感兴趣一点</p>
<h3 id="要有耐心">要有耐心</h3>
<p>就是电视上和老师经常说的要坐的住冷板凳吧，有时候学一些东西确实挺牢的，就是很无聊，知识从脑袋里滑走了。这个时候就是看你有没有耐心了，感觉这个和我第一条说的是相反的，按道理这种情况是要放弃的，但是有时候就是不太想放弃，你就需要耐心一点。所以这么看来放弃是一件很理性的事情，坚持反而是一件很感性的事情。回到正题，我想说的是，人生的常态就是失败和无聊，但是不耐心去做一件事的话就会错过很多东西。什么时候放弃，什么时候坚持是一件很哲学的问题吧。我到这里也不知道说什么好了。</p>
<p>今天就暂时写到这些吧，希望之后的时间也能继续加油。现在虽然学了很多东西，但是没办法把知识串联在一起，也有点迷茫。有时候分析一些问题的时候，反而会因为知道的太多而被绕进去。就像之前不知道从哪里看到的三大境界：</p>
<ul>
<li>看山是山 看水是水</li>
<li>看山不是山 看水不是水</li>
<li>看山还是山 看水还是水</li>
</ul>
<p>我现在可能介于一二之间吧，很难受，技术不到家，看很多东西都是残破不堪的，漏洞百出，我自己也知道。希望以后能慢慢解决这个这个问题吧。还有就是我现在也遇到了一些生活中难以解决的问题，我也不知道怎么做，在迷茫的时候还是要坚定的提升自己，也许以后时间会给出答案吧。之后也要继续加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/99-%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/99-%E5%9B%BE/" class="post-title-link" itemprop="url">99:图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 11:15:14" itemprop="dateCreated datePublished" datetime="2025-11-22T11:15:14+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:11" itemprop="dateModified" datetime="2025-11-29T13:49:11+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天接着来认识一下图，结束了图的学习，数据结构的部分就告一段落了。之后就是涉及到一些基本的算法问题，感觉也会越来越难。</p>
<h1 id="图">图</h1>
<h2 id="认识图">认识图</h2>
<p>和之前的数据结构不同，图是一种非线性的结构，由顶点和边组成，以下面为例，我们可以将图G抽象的表示成一组顶点和一组边的集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">E = &#123;(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>)&#125;</span><br><span class="line">G = &#123;V,E&#125;</span><br></pre></td></tr></table></figure>
<p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数
据结构。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/6ASNIDxnhqC7tKo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="图的常见类型和术语">图的常见类型和术语</h3>
<p>结合不同的场景，我们可以从不同的角度对图进行分类：</p>
<ul>
<li>根据边是否具有方向，分为有向图和无向图</li>
<li>根据顶点直接是否全部联通，分为联通图和非联通图</li>
<li>根据边上的权重，非为无权图和有权图</li>
<li>….</li>
</ul>
<p>在不同的场景中我们选择合适的类型，来解决问题。</p>
<p>图的数据结构有以下常用术语：</p>
<ul>
<li><strong>邻接：</strong>当两顶点之间存在边相连时，称这两个顶点邻接</li>
<li><strong>路径：</strong>从顶点A到顶点B经过的边构成的序列被称为从A到B的路径</li>
<li><strong>度：</strong>一个顶点拥有的边数。对有向图，根据边的方向，还分为入度和出度。</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>图通常使用两种表示方式，我们这里均以无向图为例：</p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>设图的顶点数量为𝑛，邻接矩阵使用一个n×n大小的矩阵来表示图，每一行（列）代
表一个顶点，矩阵元素代表边，用1或0表示两个顶点之间是否存在边。</p>
<p>设邻接矩阵为𝑀、顶点列表为𝑉
，那么矩阵元素𝑀[𝑖,𝑗]=1表示顶点𝑉[𝑖]到顶点𝑉[𝑗]
之间存在边，反之𝑀[𝑖,𝑗]=0表示两顶点之间无边。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/3i1YVTLzGIZHjQr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>邻接矩阵有以下性质：</p>
<ul>
<li>在简单图中，顶点不能和自己相连，所以邻接矩阵主对角线上的元素是没有意义的</li>
<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称</li>
<li>将邻接矩阵的元素替换成权重就是有权图</li>
</ul>
<h4 id="邻接表">邻接表</h4>
<p>邻接表使用n个链表来表示图，链表节点表示顶点。第i个链表对应顶点i，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。如下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/1W6QDdhbJVTZUYE.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="两种表示方法的比较">两种表示方法的比较</h4>
<p>对于邻接矩阵，我们可以直接访问矩阵元素实现对边的CRUD，时间效率高达<span
class="math inline"><em>O</em>(1)</span>。但是矩阵存储的空间复杂度为<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></p>
<p>对于邻接表，由于表中只存储实际已存在的边数，而边数通常小于<span
class="math inline"><em>n</em><sup>2</sup></span>，所以空间存储的效率上来看，邻接表要更加的节省空间。但是对于CRUD的操作，邻接表需要通过遍历搜索的方式来进行，所以时间效率更差。</p>
<p>但是结合先前的只是，对于这种链表较长的情况，我们可以将它优化成哈希表或者AVL树等结构，实现对时间效率的优化，所以对于大规模的图的使用场景，邻接表也更加普遍。</p>
<h2 id="图的基本操作">图的基本操作</h2>
<p>图的操作主要可以分为对顶点和对边的操作，这里分别通过邻接矩阵和邻接表的方式进行实现。</p>
<h3 id="基于邻接矩阵的实现">基于邻接矩阵的实现</h3>
<p>给定给一个顶点数量为n的无向图，我们需要完成以下操作：</p>
<ul>
<li><strong>添加或删除边：</strong>直接在邻接矩阵修改指定的边，只不过要注意同时更新两个方向的边（无向图）</li>
<li><strong>添加顶点：</strong>在邻接矩阵的尾部添加一行一列，并初始化为0即可。</li>
<li><strong>删除顶点：</strong>在邻接举证中删除一行一列，将剩下的元素向左上补齐。对于最坏的情况（删除首行首列）需要移动<span
class="math inline">(<em>n</em> − 1)<sup>2</sup></span>个元素</li>
<li><strong>初始化：</strong>传入n个顶点，初始化长度为n的顶点列表和nxn大小的邻接矩阵</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/zKrGQMe1svBL9jY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMap</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vertices;           <span class="comment">// 顶点列表</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMat;     <span class="comment">// 邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphMap</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val : vertices)</span><br><span class="line">                <span class="built_in">addVertex</span>(val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;edge : edges)</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">            <span class="comment">// 向邻接矩阵中添加一行</span></span><br><span class="line">            adjMat.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row: adjMat)</span><br><span class="line">                row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除行</span></span><br><span class="line">            adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除列</span></span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat)</span><br><span class="line">                row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="基于邻接表的实现">基于邻接表的实现</h3>
<p>设无向图的顶点总数为n、边总数为m，我们需要完成以下操作：</p>
<ul>
<li><strong>添加边：</strong>在顶点对应链表的末尾添加边就行了。但是要注意无向图要加两个方向的边</li>
<li><strong>删除边：</strong>在顶点管理的链表中查找并删除指定的边。无向图中删两个方向。</li>
<li><strong>添加顶点：</strong>在邻接表中添加一个链表，并将新增顶点作为链表头节点</li>
<li><strong>删除顶点：</strong>遍历整个邻接表，删除包含指定顶点的所有边</li>
<li><strong>初始化：</strong>在邻接表中创建n个顶点和2m条边</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/eZVmQvChWyGikj2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>以下是邻接表的代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        unordered_map&lt;Vertex* ,vector&lt;Vertex*&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex*&gt; &amp;vec, Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i]==vet)&#123;</span><br><span class="line">                    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphList</span>(<span class="type">const</span> vector&lt;vector&lt;Vertex*&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;Vertex *&gt; &amp; edge: edges)&#123;</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            adjList[vet] = <span class="built_in">vector</span>&lt;Vertex*&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;adj : adjList)</span><br><span class="line">                <span class="built_in">remove</span>(adj.second,vet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">            adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet1],vet2);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet2],vet1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为了方便，我们使用动态数组代替了链表。用哈希表来表示邻接表结构。</p>
<p>同时需要注意在邻接表中我们使用<code>Vertex</code>类来表示顶点，也是为了方便。如果我们使用列表索引来区分不同德顶点的话，那么每当我们删除一个索引为i的顶点，就需要遍历整个邻接表，把所有索引大于i的顶点重新更新一遍，这样的话效率就很差。</p>
<h2 id="图的遍历">图的遍历</h2>
<p>树代表的是一对多的关系，图代表的是多对多的关系，所以我们可以将树视作图的一个特例。所以说树的遍历操作实际上也是图的遍历操作的一种特例。</p>
<p>和树类似的，我们有两种遍历方式实现对图的遍历操作：广度优先遍历和深度优先遍历</p>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外
扩张。以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/T2MS6rYJNOWeIGb.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻
接顶点，以此类推，直至所有顶点访问完毕。</p>
<h4 id="算法实现">算法实现</h4>
<p>BFS通常需要一个辅助队列来实现，通过队列先进先出的性质，实现BFS由近及远的思路。我们的实现流程如下：</p>
<ul>
<li>将遍历起始顶点<code>startVet</code>加入队列中，开始循环</li>
<li>在每次迭代中，弹出队首顶点并访问，将该顶点的所有邻接点加入到队列尾部</li>
<li>循环上一步，知道队列为空</li>
</ul>
<p>同时我们还需要一个哈希集合<code>visited</code>来记录哪些节点被访问，以防止重复遍历顶点。</p>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphBFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    vector&lt;Vertex*&gt; res;				<span class="comment">// 返回的顶点序列</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;		 <span class="comment">// 哈希集合,用来记录被访问过的顶点	</span></span><br><span class="line">    queue&lt;Vertex*&gt; que;					<span class="comment">// 辅助队列	</span></span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Vertex* vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> adjVet : graph.adjList[vet])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;				<span class="comment">// 跳过已访问的顶点</span></span><br><span class="line">            que.<span class="built_in">push</span>(adjVet);</span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过画图的方法帮助理解一下这个过程</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。以下图为例</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/4BcYNu6gOmpyzfa.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="算法实现-1">算法实现</h4>
<p>这种走到尽头并返回的样式，我们可以通过递归的方式实现。关键在于怎么设置边界条件，退出递归。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(GraphList &amp;graph, unordered_set&lt;Vertex*&gt; &amp;visited,</span></span></span><br><span class="line"><span class="params"><span class="function">         vector&lt;Vertex*&gt; &amp;res, Vertex * vet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 记录访问节点</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">    <span class="comment">// 标记已访问节点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet);</span><br><span class="line">	<span class="comment">// 遍历所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span>(Vertex* adjVet : graph.adjList[vet])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph,visited,res,adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphDFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex*&gt; res;</span><br><span class="line">    <span class="comment">// 以访问过的顶点</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph,visited,res,startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自己尝试手推一下这个过程，加深理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/18/98-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/18/98-%E5%A0%86/" class="post-title-link" itemprop="url">98:堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-18 15:07:44" itemprop="dateCreated datePublished" datetime="2025-11-18T15:07:44+08:00">2025-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:06" itemprop="dateModified" datetime="2025-11-29T13:49:06+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学一种新的数据结构——“堆”，但是貌似和底层原理中的堆并不一样。之前总是略有耳闻，但是一直都很少仔细去了解。</p>
<h1 id="堆">堆</h1>
<p>堆是一种满足特定条件的完全二叉树，根据性质可以分为两种类型：</p>
<ul>
<li>小顶堆：任意节点的值 &lt;= 子节点的值</li>
<li>大顶堆：任意节点的值 &gt;= 子节点的值</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/18/Zjx5Hnc4sqoQYiW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>堆作为完全二叉树的一个特例，有以下规则：</p>
<ul>
<li>最底层的节点靠左排列，其他层被节点填满。</li>
<li>二叉树的根节点被称为<strong>堆顶</strong>，二叉树底层靠右的节点称为<strong>堆底</strong></li>
<li>对于大(小)顶堆，堆顶元素的值是最大(小)的</li>
</ul>
<h2 id="堆的常用操作">堆的常用操作</h2>
<p>有一种抽象的数据结构——优先队列，定义为具有优先级排序的队列。通常我们会使用堆来实现优先队列，大顶堆就相当于元素按大到小的顺序出队的优先队列。这里我们将其视作等价的数据结构。</p>
<p>这里我们先通过优先队列来认识一下堆的一些操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minheap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxheap;</span><br><span class="line"></span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The size is &quot;</span> &lt;&lt; maxheap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> top = maxheap.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The top is &quot;</span> &lt;&lt; top &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEmpty = maxheap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的可以总结为以下几类：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/7Lgt6pdXfOrTP2V.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="堆的实现">堆的实现</h2>
<p>现在我们尝试从底层实现一个堆，这里我们用大顶堆演示，小顶堆只需要将所有的大小逻辑判断反转即可。</p>
<h3 id="堆的存储和表示">堆的存储和表示</h3>
<p>堆是一种完全二叉树，我们之前提到过完全二叉树十分适合用数组来进行存储，所以这里我们的底层实现选择用数组，和之前的实现一样。我们使用索引的映射公式来代替节点指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问堆顶元素">访问堆顶元素</h3>
<p>堆顶元素就是二叉树的根节点，也就是我们数组的首元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素入堆">元素入堆</h3>
<p>给定<code>val</code>，我们将其添加到堆底。但是此时插入的值可能会破坏当前到根节点的路径，导致堆的成立条件被破坏。所以我们需要遍历修复从插入节点到根节点路径上的所有节点，这个过程我们称之为<strong>堆化</strong></p>
<p>从入堆节点开始，我们从底执行堆化。我们依次比较当前节点和父节点的大小，如果插入节点更大就讲他们交换，知道修复所有的节点关系。</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/3OjBe9MCgLIG7sA.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过以下方式实现这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          heap.<span class="built_in">push_back</span>(i);</span><br><span class="line">          <span class="comment">// 从堆底开始堆化</span></span><br><span class="line">          <span class="built_in">siftUp</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">              <span class="type">int</span> p = <span class="built_in">parent</span>(i);</span><br><span class="line">              <span class="keyword">if</span>(p&lt;<span class="number">0</span> || heap[i] &lt;= heap[p])</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="built_in">swap</span>(heap[i],heap[p]);</span><br><span class="line">              <span class="comment">// 向上堆化</span></span><br><span class="line">              i=p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆顶元素出栈">堆顶元素出栈</h3>
<p>堆顶元素是二叉树的根节点，如果我们直接从数组中删除首元素，那么会破坏整个树的树状结构，这导致后续的堆化难以修复。所以我们采取以下步骤将堆顶元素出栈：</p>
<ul>
<li>交换堆顶元素（根节点）和堆底元素（最右元素）</li>
<li>交换完成之后，我们将堆底删除</li>
<li>从根节点开始自顶向底执行堆化</li>
</ul>
<p>自顶向下的堆化和自底向上的堆化逻辑相反，我们将当前节点和较大的子节点进行比较，然后进行交换，直到没有子节点或者无需再交换了：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/DhigaQdUJ3GnKW5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>出堆的实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// ma为较大的节点</span></span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">left</span>(i), r=<span class="built_in">right</span>(i), ma = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[l])</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[r])</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// l,r越界或者i已经是最大节点 则退出堆化</span></span><br><span class="line">        <span class="keyword">if</span>(ma==i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[ma]);</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建堆操作">建堆操作</h3>
<p>我们希望能直接根据一个列表中的所有元素来构建一个堆。我们有两种可行的方案：</p>
<ul>
<li>创建一个空堆，然后遍历列表，对每一个元素都进行入堆操作。但是对于n个元素执行复杂度为<code>O(logn)</code>的入堆操作，时间复杂度会增长到<code>O(nlogn)</code></li>
<li>另一个方法就是，将列表中的元素添加到完全二叉树中，尽管现在的堆的性质并没有被满足。接下来我们倒序遍历堆，并对每个非叶节点进行一次自顶向下的堆化。这样每当我们堆化一个节点之后，都会以该节点为根节点形成一个子堆。</li>
</ul>
<p>这里我们着重分析一下第二种方法。我们可以通过以下方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Heap</span>(vector&lt;<span class="type">int</span>&gt; vec)&#123;</span><br><span class="line">    heap = vec;</span><br><span class="line">    <span class="comment">// 倒序遍历的第一个非叶节点 就是最后一个叶节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">parent</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>); i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">siftDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法下的复杂度被优化到了<code>O(n)</code>，更加的便捷。</p>
<h2 id="top-k问题">Top-k问题</h2>
<p>所谓top-k问题，就是给定一个长度为n的无序数组<code>nums</code>，请返回数组中最大的k个元素。</p>
<p>对于这个问题我们有很多种解决方案：</p>
<h3 id="遍历选择">遍历选择</h3>
<p>我们可以像这样对一个长度为n的序列进行k次遍历，每轮遍历都提取出当前序列中的最大的数据。时间复杂度为<code>O(nk)</code>。当k接近n时，时间复杂度增长到<code>O(n^2)</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/18/upZYUAsJwrt2gcz.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="排序">排序</h3>
<p>先对数组<code>nums</code>进行排序，然后再返回最右边的k个数据。这个方法主要取决于对数组排序的时间复杂度，对于<code>std::sort</code>，这个方法的复杂度是<code>O(nlogn)</code></p>
<h3 id="堆-1">堆</h3>
<p>我们可以基于堆更加高效的完成这个任务，我们遵循以下步骤实现：</p>
<ul>
<li>初始化一个小顶堆，此时其堆顶元素最小。</li>
<li>然后将数组的前k个元素依次入堆</li>
<li>从第k+1个元素开始，如果当前元素大于堆顶元素，我们就将堆顶出堆，并将当前元素入堆。</li>
<li>遍历完成之后，堆中保存的就是最大的k个元素。</li>
</ul>
<p>我们可以写出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">topHeap</span>(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">top</span>() &lt; nums[i])&#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共进行了n轮入堆和出堆，由于堆大小是固定的k，所以我们只需要维护k个元素，所以实际上我们的计算复杂度只有<code>O(nlogk)</code>，在k较小时，我们的时间复杂度约等于<code>O(n)</code></p>
<p>由此可以看到通过堆的思路，对解决<code>TopK</code>问题的显著提升。尤其是对于这种方法，适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现
最大的𝑘个元素的动态更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="post-title-link" itemprop="url">97:平衡树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-17 20:45:51" itemprop="dateCreated datePublished" datetime="2025-11-17T20:45:51+08:00">2025-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:53" itemprop="dateModified" datetime="2025-11-29T13:48:53+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，接着研究一下AVL树。</p>
<h2 id="avl树">AVL树</h2>
<p>在二叉搜索树中，我们可以知道，在多次的插入和删除之后，二叉树的左右可能会失去平衡，从而导致退化成链表，在这样的情况下我们的算法的效率会从<code>O(logn)</code>退化到<code>O(n)</code>：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/5jRdMzbsJDmt3Z2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/hxU4EiZFm9HaNOk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>但是我们接下来将要提到的AVL树，将解决这些问题</p>
<h3 id="avl树的常见术语">AVL树的常见术语</h3>
<p>AVL树本质是二叉搜索树和二叉平衡树的结合，所以同时满足这两种树的性质：</p>
<ol type="1">
<li><strong>节点高度</strong></li>
</ol>
<p>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。这里我们让叶子节点的高度为<code>0</code>，把空节点的高度设置为<code>-1</code>。我们将根据这些性质来编写我们的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left&#123;&#125;;</span><br><span class="line">    TreeNode* right&#123;&#125;;</span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span>: val(x) &#123;</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的高度 = 最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left),<span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>节点的平衡因子</strong></li>
</ol>
<p>节点的平衡因子定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。对于AVL树，我们要求树中任意节点的平衡因子<code>-1&lt;=f&lt;=1</code>，否则这个树就进入了失衡状态。我们可以写出以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">balance</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的旋转">AVL树的旋转</h3>
<p>AVL树的精髓就在于旋转操作，当我们的树中存在失衡节点时，我们可以通过“旋转”操作，在不影响中序遍历序列的前提下，使失衡的节点重新回到平衡的状态。</p>
<p>我们将<code>|平衡因子| &gt; 1</code>的节点称为失衡节点，根据不同的失衡情况，我们有四种旋转操作：</p>
<h4 id="右旋">右旋</h4>
<figure>
<img src="https://s2.loli.net/2025/11/17/OHDbWSA6JQIgBc4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>结合这张图来看，从底至顶看，二叉树中首个失衡节点是“节点3”。我们关注以该失衡
节点为根节点的子树，将该节点记为 node ，其左子节点记为 child
，执行“右旋”操作。完成右旋后，子树
恢复平衡，并且仍然保持二叉搜索树的性质。</p>
<p>但是对于，当节点<code>child</code>有右节点（记作<code>grand_child</code>）的情况下，我们需在右旋中添加一步：将<code>grand_child</code>设置为<code>node</code>的左子节点。</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/J1BOAZhMKVXuwGl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过修改节点指针的方法来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    TreeNode* grandChild = child-&gt;right;</span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    <span class="comment">// 当grandChild为null时无影响</span></span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="comment">// 右旋后child作为左子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="左旋">左旋</h4>
<p>左旋作为右旋的镜像版本，对应右节点失衡的情况，同样是下面的两种情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/vSVYkineu6gU9ID.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/xqeXp4zbtHB3KIg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;right;</span><br><span class="line">    TreeNode* grandChild = child-&gt;left;</span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先左旋后右旋">先左旋后右旋</h4>
<p>对于下面这种情况，我们需要先对<code>child</code>进行左旋，再对<code>node</code>进行右旋：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/LzuXUe4dlR2GSaD.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="先右旋后左旋">先右旋后左旋</h3>
<p>这种情况依旧是上一种情况的镜像对称情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/q2JQknaz7PGlIci.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="旋转的选择">旋转的选择</h4>
<p>讲完了四种旋转的操作，现在我们需要分析，在什么情况下需要对我们的树进行哪些操作了，这里的话我推荐看一个视频：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&amp;vd_source=860ada84437562c4715775e08ac9e2ae">平衡二叉树(AVL树)_哔哩哔哩_bilibili</a></p>
<p>我们的步骤总结如下：</p>
<ul>
<li>先检查失衡节点的子节点<code>child</code>的平衡因子，大于0则需要进行右旋操作，小于0则需要进行左旋操作。</li>
<li>然后检查失衡节点<code>node</code>的平衡因子，大于1则需要进行右旋操作，小于1则需要左旋操作。</li>
<li>最后比较对子节点<code>chlid</code>和失衡节点<code>node</code>的需要进行的操作，如果相同则合并，不同则先操作子节点后操作失衡节点。</li>
</ul>
<p>我们也可以用一张表来进行这个判断：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/HInBOe2GjgZEXCo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>现在我们可以写出AVL树的平衡函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _balanceFactor = <span class="built_in">balance</span>(node);</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(_balanceFactor &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 右旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&lt;<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 先左旋</span></span><br><span class="line">            child = <span class="built_in">leftRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_balanceFactor &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 左旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 先右旋</span></span><br><span class="line">            child = <span class="built_in">rightRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 平衡</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的常用操作">AVL树的常用操作</h3>
<ol type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>AVL树的节点插入操作和二叉搜索树一样，只不过在AVL树插入节点之后，从这个节点到根节点的路径上可能会出现一系列的失衡节点。所以我们需要从这个节点开始，自底向上的执行平衡操作，知道所有的失衡节点都恢复平衡。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _insert(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _insert(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = _insert(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>删除操作</strong></li>
</ol>
<p>删除也是差不多，需要在删除的基础之上，从底部到顶部进行平衡操作，确保所有的失衡点都恢复平衡：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _remove(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _remove(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right =_remove(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>||node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* child = node-&gt;left==<span class="literal">nullptr</span> ? node-&gt;right : node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* tmp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left !=<span class="literal">nullptr</span>)</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            <span class="type">int</span> val = tmp-&gt;val;</span><br><span class="line">            node-&gt;right = _remove(node-&gt;right,tmp-&gt;val);</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>查找操作</strong></li>
</ol>
<p>和二叉搜索树一样，没有变化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">246k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:56</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
