<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/12/00-%E9%A6%96%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/12/00-%E9%A6%96%E9%A1%B5/" class="post-title-link" itemprop="url">Ylin's Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-12 14:53:29" itemprop="dateCreated datePublished" datetime="2025-03-12T14:53:29+08:00">2025-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:25:47" itemprop="dateModified" datetime="2025-11-29T13:25:47+08:00">2025-11-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>45</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="你好呀">你好呀！</h1>
<h1 id="这里记录我的学习经历和内容">这里记录我的学习经历和内容</h1>
<h1 id="希望能够帮到你们">希望能够帮到你们</h1>
<h1 id="section">: )</h1>
<p>标签对应使用的编程语言</p>
<p>分类中查看对应的板块</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/19/108-%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AFF3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/19/108-%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AFF3-1/" class="post-title-link" itemprop="url">108:一生一芯F3(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-19 13:18:29 / 修改时间：23:33:27" itemprop="dateCreated datePublished" datetime="2026-01-19T13:18:29+08:00">2026-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AFF/" itemprop="url" rel="index"><span itemprop="name">一生一芯F</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>寒假报名了一生一芯的训练，作为对我这个学期的知识的一个补全，顺便学一些新的知识。为下个学期研究二进制安全做一点准备。这一部分就记录我在学习过程中的一些心得体会。就不再像往常一样讲的那么详细了，因为知识点在文档中给的很清楚，没必要再敲一遍。</p>
<h2 id="通过晶体管实现0和1">通过晶体管实现0和1</h2>
<p>主要认识两种类晶体管：</p>
<ul>
<li>nMOS：当G为高电压时，电信号由S-&gt;D；反之则阻塞信号</li>
<li>pMOS：当G为低电压时，电信号由S-&gt;D；反之则阻塞信号</li>
<li>注意两者输入输出的方向，pMOS图带圈</li>
</ul>
<figure>
<img src="https://s2.loli.net/2026/01/19/j6oCLRvZfWAk35K.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="通过晶体管搭建门电路">通过晶体管搭建门电路</h2>
<h3 id="f3.2.1-分析门电路">F3.2.1 分析门电路</h3>
<blockquote>
<p>尝试分析以下门电路的行为和功能.</p>
</blockquote>
<p>基于mos管，我们可以实现基础的门电路，我们分析下面的门电路功能：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/LkUSzXNOlocvGaW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>只有A和B均为低电压时，才能输出高电平信号。当A或B任一处于高电压时，输出低电平信号。分析为——NOR门</p>
<h3 id="f3.2.2-或门的晶体管结构">F3.2.2 或门的晶体管结构</h3>
<blockquote>
<p>尝试画出或门的晶体管结构.</p>
</blockquote>
<p>画出或门的晶体管结构，就是在上面的基础上加上一个非门的晶体管结构就好了：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/F1Mq5mlwVn7aUvB.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.2.3-对比两种实现的晶体管所需要的数量">F3.2.3
对比两种实现的晶体管所需要的数量</h3>
<blockquote>
<p>不难分析, 上述晶体管结构同样实现了三输入与非门的功能.
尝试对比两种实现方式中所需晶体管的数量.</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2026/01/19/35bkUQdxTun7ywR.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>分别对两种方案进行计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 门电路方案</span></span><br><span class="line">#T(NAND3) = #T(AND) + #T(NAND) = <span class="number">8</span> + <span class="number">6</span> = <span class="number">14</span></span><br><span class="line"><span class="comment">// 晶体管方案</span></span><br><span class="line">#T(NAND3) = <span class="number">3</span>*#T(P) + <span class="number">3</span>*#T(N)*<span class="number">3</span> = <span class="number">3</span> + <span class="number">9</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="f3.3.1-用其他门电路搭建异或门">F3.3.1
用其他门电路搭建异或门</h3>
<blockquote>
<p>尝试在Logisim中用上文提到的门电路搭建一个异或门. 搭建后,
通过仿真检查你的方案是否正确.</p>
<p>实现正确后, 计算你的方案使用了多少个晶体管.</p>
</blockquote>
<p>异或门的真值表，也可以看作是或门和与非门的交集。根据这个特征我们可以通过以下形式实现异或门：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/17XbjHsAfNpS64y.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.3.2-设计同或门">F3.3.2 设计同或门</h3>
<blockquote>
<p>还有另一种操作是”同或”操作, 当输入A和B相同时, 结果为<code>1</code>,
否则为<code>0</code>. 同或操作可以认为是异或操作结果的取反.</p>
<p>尝试在Logisim中用上文提到的门电路搭建一个同或门. 搭建后,
通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>在上面的基础上加一个非门就行了：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/WstgwX5F6in3VGv.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="进位计数法">进位计数法</h2>
<p>主要讲了2，10，16进制间的转换，这个比较简单，暂时略过。</p>
<h2
id="通过门电路搭建基本组合逻辑电路">通过门电路搭建基本组合逻辑电路</h2>
<p>我们基于晶体管实现了门电路，现在我们将忽略晶体管的电气特性，将视角聚焦到门电路层面。在此基础之上，搭建各种基础的基础电路模块。</p>
<h3 id="f3.5.1-搭建2-4译码器">F3.5.1 搭建2-4译码器</h3>
<blockquote>
<p>尝试在Logisim中用门电路搭建一个2-4译码器, 它有2位输入, 4位输出.
搭建后, 通过仿真检查你的方案是否正确.</p>
<p>Logisim中也直接提供了译码器等现成的元件,
但我们还是要求大家使用门电路来搭建它们,
从而更好地学习数字电路的基本原理.</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2026/01/19/eac4GfSm6J7R3TQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.2-logisim中的子电路功能">F3.5.2 Logisim中的子电路功能</h3>
<blockquote>
<p>译码器在后续的数字电路设计中会经常用到,
为了避免用户重复设计相同的电路, Logisim提供了子电路功能,
相应电路只需要设计一次, 后续即可反复实例化.
具体操作方式请阅读官方手册中的<code>Subcircuits(子电路)</code>部分.</p>
<p>学习如何使用Logisim的子电路功能后,
尝试将你设计的译码器封装成子电路.</p>
</blockquote>
<p>可以通过添加电路，然后设置好IO引脚，这样就可以打包成一个子电路，方便之后调用：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/KahbAuLmDNlJ8xY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.3-译码器的扩展">F3.5.3 译码器的扩展</h3>
<blockquote>
<p>3-8译码器有3位输入, 8位输出.
尝试实例化若干个2-4译码器(具体数量交给你的思考), 并添加少量门电路,
从而实现3-8译码器的功能. 搭建后, 通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>通过第三个信号和原有的2-4译码器，实现3-8译码器</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/dG6Y9yE4PcbOClW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.4-搭建七段数码管译码器">F3.5.4 搭建七段数码管译码器</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个七段数码管译码器,
它有4位输入和8位输出, 分别与拨码开关和七段数码管相连.
七段数码管译码器支持十进制数字的显示, 即当输入对应0-9时,
七段数码管显示对应的数字; 对于其他输入, 七段数码管只显示小数点. 搭建后,
通过仿真检查你的实现是否正确.</p>
</blockquote>
<p>这里用了隧道和解码器，来简化实现，对着文档搓就行了。RTFM！！！</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/6VmP7eU1sLzW9bQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.5-搭建七段数码管译码器2">F3.5.5
搭建七段数码管译码器(2)</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个支持十六进制数字的七段数码管译码器.
和上述的十进制数字相比, 当输入对应10-15时, 七段数码管分别显示A, b, C, d,
E, F. 搭建后, 通过仿真检查你的实现是否正确.</p>
</blockquote>
<p>在上一个的基础之上添加对<code>A,b,C,d,E,F</code>的数码管支持就好了。就是有点麻烦。</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/MipQKxs3UmtgPXV.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.6-编码器">F3.5.6 编码器</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个16-4编码器, 它有16位输入和4位输出,
分别与拨码开关和七段数码管译码器相连,
使得编码器的输出结果通过十六进制数字显示在七段数码管中. 搭建后,
通过仿真检查你的实现是否正确.</p>
</blockquote>
<p>每个Y的输出只关注当前的二进制对应的位数是否需要Y，然后使用或门进行合并：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/4Xjk15U9BbLJi2D.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>使用封装的译码器驱动我们的七段管：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/rj5NkzPGqx8MCD9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.7-搭建4-2优先编码器">F3.5.7 搭建4-2优先编码器</h3>
<blockquote>
<p>根据上述真值表, 尝试列出每一位输出的逻辑表达式.
然后尝试在Logisim中通过门电路搭建一个4-2优先编码器. 搭建后,
通过仿真检查你的方案是否正确.</p>
<p>实现后, 对比4-2编码器和4-2优先编码器所需的门电路数量.</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/gF61ikCnqyXGz5w.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
</blockquote>
<p>实现的过程中发现只有当A2为1时，后面的A1信号会对结果造成影响。设置一个与门作为开关就可以抑制这个现象了：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/fgH4wzFSVvCGnQt.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>门电路数量比较：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4-2</span></span><br><span class="line">#T(<span class="number">4</span><span class="number">-2</span>) = <span class="number">2</span>*#T(OR) = <span class="number">2</span>*<span class="number">8</span> = <span class="number">16</span></span><br><span class="line"><span class="comment">// 优先4-2</span></span><br><span class="line">#T(P4<span class="number">-2</span>) = <span class="number">2</span>*#T(OR) + #T(AND) + #T(NOT) = <span class="number">2</span>*<span class="number">8</span> + <span class="number">8</span> + <span class="number">2</span> = <span class="number">26</span></span><br></pre></td></tr></table></figure>
<h3 id="f3.5.10-搭建1位2选1选择器">F3.5.10 搭建1位2选1选择器</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个1位2选1选择器. 搭建后,
通过仿真检查你的方案是否正确.</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2026/01/19/SLnFOz8Zt3T2X4v.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.11-搭建3位4选1选择器">F3.5.11 搭建3位4选1选择器</h3>
<blockquote>
<p>尝试画出3位4选1选择器的电路结构图,
然后在Logisim中通过门电路搭建一个3位4选1选择器. 搭建后,
通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>这个比较复杂，但是原理一样：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/JiegQYWol4s7ma3.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.12-搭建可切换进位计数制的七段数码管">F3.5.12
搭建可切换进位计数制的七段数码管</h3>
<blockquote>
<p>通过5个拨码开关和1个七段数码管, 实现如下功能:
其中4个拨码开关当作数据输入, 剩下1个拨码开关作为进位计数制的选择,
当选择信号为<code>0</code>时, 七段数码管以十进制方式显示数据;
当选择信号为<code>1</code>时, 七段数码管以十六进制方式显示数据.
在输入数据为10-15时, 两种显示方式有所不同.</p>
</blockquote>
<p>使用系统封装好的多路复用器就很容易实现</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/NGOEYKdIs9S8TBe.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.13-搭建比较器">F3.5.13 搭建比较器</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个4位比较器,
然后通过两组拨码开关对比两组数据是否相等, 若相等, 则点亮一个LED灯.
搭建后, 通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>四个同或门比较信号，然后使用与门收集信号，若全为真则各位相同：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/SJHGzWp9ag3jUZC.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.14-搭建1位全加器">F3.5.14 搭建1位全加器</h3>
<blockquote>
<p>尝试列出1位全加器的真值表, 并在Logisim中通过门电路搭建一个1位全加器.
搭建后, 通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>本质上就是在半加器的基础上，对一个新的进位进行额外的判断：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/bKAJWVCarqeuYcX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.15-搭建1位全加器2">F3.5.15 搭建1位全加器（2）</h3>
<blockquote>
<p>尝试实例化若干个半加器, 并添加少量门电路, 从而实现一个1位全加器.
搭建后, 通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>一样的原理，只不过封装了起来</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/MDKfFRIebchJrlL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="f3.5.16-搭建4位加法器">F3.5.16 搭建4位加法器</h3>
<blockquote>
<p>尝试在Logisim中通过门电路搭建一个4位加法器,
用七段数码管按十六进制显示加法器的两个输入和结果,
并用一个LED灯指示加法结果是否产生进位. 搭建后,
通过仿真检查你的方案是否正确.</p>
</blockquote>
<p>使用全加器串联起来：</p>
<figure>
<img src="https://s2.loli.net/2026/01/19/Ropm6SxelvZ1U4k.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/16/107-%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D%E4%B8%8E%E5%AF%B9%E5%AF%92%E5%81%87%E7%9A%84%E5%B1%95%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/16/107-%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D%E4%B8%8E%E5%AF%B9%E5%AF%92%E5%81%87%E7%9A%84%E5%B1%95%E6%9C%9B/" class="post-title-link" itemprop="url">107:一月的反思与对寒假的展望</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-16 23:15:18 / 修改时间：23:29:20" itemprop="dateCreated datePublished" datetime="2026-01-16T23:15:18+08:00">2026-01-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>545</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>终于考完试了，也要做好打算琢磨一下接下来该做什么了。总体来说，这个寒假会好忙，但是也是一个很好的机遇。我打算用这段时间好好提升一下自己，无论是学习上还是生活上。</p>
<p>先对我的一月份做个小小的反思吧，这个月主要是期末周，导致我都没有更新博客，也没有学什么新的技术，寒假我会好好补起来的。至于期末开始，只能说考的一般吧，自己还是抱有侥幸心理，偷了很多懒。导致复习的过程很赶，很多知识都是一知半解。尤其是概率论，唉，基本都不会，我考前还一直在打游戏，也不知道怎么想的。</p>
<p>然后就是主要讲一讲寒假的安排吧，和往常一样，我想做的事情比较多，但是不一定能做到。但是目标还是要定下来的：</p>
<ul>
<li>科研训练任务（这个是重中之重，如果寒假拿不出成果，就真要寄了）</li>
<li>然后是完成一生一芯的预学习阶段，通过答辩，成为正式学员。</li>
<li>再是要提升一下国际象棋技术，争取冲到1300-1500分，要多和真人对练</li>
<li>然后平时要坚持锻炼身体，不能三天打鱼两天晒网，而且感觉自己的身体素质也越来越差了</li>
<li>接着就是学习一下游戏引擎吧，我想试着做一做游戏。</li>
</ul>
<p>这些是要做的事情，我还想立几个比较具体的任务，我打算看完三本书：</p>
<ul>
<li>计算机组成设计与接口：Risc-V</li>
<li>计算机网络：自顶向下</li>
<li>OSTEP：操作系统，顺便把xv6的内核源代码给看一看</li>
</ul>
<p>所以综上所述，要做的事情还是很多的。所以每天要早睡早起，少刷视频。我发现这个学期我刷视频的时间明显变多了很多。</p>
<p>今年的寒假很长，希望能通过这个寒假给自己带来一点改变。不能止步不前，Keep
on going。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/17/106-%E5%8D%81%E4%BA%8C%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/17/106-%E5%8D%81%E4%BA%8C%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">106:十二月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-17 12:55:55" itemprop="dateCreated datePublished" datetime="2025-12-17T12:55:55+08:00">2025-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-19 14:26:08" itemprop="dateModified" datetime="2025-12-19T14:26:08+08:00">2025-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2025年马上就过去了，这一年发生了很多事情，我也不怎么记得了。仔细一想感觉一年好长，但是时间却又过的好快。最近很多软件都公布了年度报告，不知道为什么我甚至不敢点开，我好害怕去回想这些事情。可能是因为最近过的不是很好吧，我不想去回忆以前很多很开心的瞬间。我怕自己看到了会难过。</p>
<p>但我还是点开看了，我最先意识到的就是，原来我有这么多时间。我仔细算了一下，人的一天有24个小时，去掉12个小时吃饭睡觉，我还剩下12个小时。一年下来就是
4380个小时，我的B站视频时长是930个小时，今年的游戏时长1500个小时。我将近一半的时间都在娱乐，我推测学习时长也就1000个小时。我的每一天无形之中浪费了很多时间。如果我能注意到这些时间就好了。</p>
<p>我总是觉得自己好忙好累，我为什么不拿这些多余的时间去陪陪自己的女朋友，或者锻炼培养下自己的爱好。</p>
<p>我觉得很自责，心里。我明明可以做得更好，但是我什么也没做，我感觉自己是个无聊的人，可能每天就是宅着，过完一天又一天。我总是觉得自己毫无长进，我现在知道这份感受的来源了。我希望新的一年自己能做的更好吧，心里非常难过，也不知道说什么好，我觉得还是挺后悔的，我十二月有一段时间什么也不想做。每天就是打游戏，看动漫，尽量让自己不去思考吧。我玩蔚蓝，把BC面全部通关了。我一直死一直重来，我心里是有幻想的，就好像我通关了之后我就能大声的宣告，自己从失恋的阴影中走了出来。但我还是没能做到，我不仅没有通关，也没有从失恋的阴影中走出来。</p>
<p>我看网上很多人说，走出失恋的痛苦就需要你把你的注意力转移到自己身上，去打破现有的僵局，去改正自己的不足。我觉得很有道理，但是太难了，失恋在我看来就是一种精神病，让失恋的人走出来，就好比让抑郁症开心一点。我也不知道该怎么做吧，只是尽量的让自己忙一点。最近开始着手准备期末和大作业的项目，所以心情好一点，暂时不会去想了。零散的时间我会看看国际象棋，看看视频。最近这几天稍微心情好一点。所以写下这篇反思。</p>
<p>但是这样的日子还要多久呢，我要一直让自己忙碌下去，什么时候才能停下来呢。-</p>
<p>尽管如此，我还是想像往常一样定下几个目标，尽力去做吧：</p>
<ul>
<li>照顾好自己，要正常的饮食和作息和生活习惯</li>
<li>从现在开始到期末结束，不玩游戏。累的时候可以看看书</li>
<li>每周要锻炼，锻炼会让短时间心情变好</li>
<li>全力开始期末的准备，这个学期学的很糟糕，所以要万分准备</li>
<li>振作起来</li>
</ul>
<p>我觉得放弃确实狼狈，但是也不能因此丢失了再来的勇气，否则我也不再是我。通过这段时间我对自己的观察，我发现我有一个特点。无论是打游戏还是生活中，只要有一件我想做到的事情我就会没日没夜的去完成它，大部分时候我都能做到。少部分时候，我会遇到无论如何也无法解决的问题，我会情绪很失控，很自责，很消极。我不知道这样是好还是坏，但是我不愿意放弃，当下我应该整顿好自己，然后再来一次。不能止步不前。</p>
<p>也许这也是一次转机吧，这段时间我重新认识了自己，想了很多以前不会想的事情，希望我能做到越来越好。如果可以的话，我还是想去北京，去看北方的初雪。冬天如约而至，可是你成了我永远迟到的季节。我要完成我的遗憾。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/09/105-Python%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/105-Python%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E4%B8%8A/" class="post-title-link" itemprop="url">105:Python字节码解释器基本原理(上)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-09 19:43:00" itemprop="dateCreated datePublished" datetime="2025-12-09T19:43:00+08:00">2025-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-10 11:15:15" itemprop="dateModified" datetime="2025-12-10T11:15:15+08:00">2025-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/Byterun/" itemprop="url" rel="index"><span itemprop="name">Byterun</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>找到一个比较好的项目<a
href="%5BA%20Python%20Interpreter%20Written%20in%20Python%20by%20qingyunha%5D(https://qingyunha.github.io/taotao/)">Byterun</a>，这里进行一下复现。</p>
<h1 id="byterun">Byterun</h1>
<p>Byterun
是一个基于Python实现的Python字节码解释器，简化了Cpython的实现，展示了Python解释器在底层上的实现原理，以及相关的组织过程。</p>
<h2 id="搭建一个解释器">搭建一个解释器</h2>
<p>解释器本质上就是一个虚拟机，他会对你产生的字节码信息进行解释，然后基于栈运行，实现运算、分支条件、循环结构等功能。</p>
<p>Python解释器实际上就是一个字节码解释器，它接受字节码，然后输出运行结果。当你写下一段Python代码时，会被词法分析器解析为token流，然后通过语法分析和编译器，作为字节码（code
object）进行输出。然后字节码再由Python解释器进行运行。这里字节码的作用有点像汇编语言在C语言编译过程。</p>
<h3 id="微型解释器">微型解释器</h3>
<p>我们最简单的解释器开始，它只能识别以下三个指令，我们基于一点一点拓展实现我们的整个项目：</p>
<ul>
<li>LOAD_VALUE：加载值</li>
<li>ADD_TWO_VALUES：相加</li>
<li>PRINT_ANSWER：输出值</li>
</ul>
<p>我们对<code>7+5</code>生成以下指令集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte2exec = &#123;</span><br><span class="line">    <span class="string">&quot;inst&quot;</span>: [</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;num&quot;</span>: [<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以通过这种单指令和零指令的方式进行计算，是因为我们的Python解释器实际上是一个基于栈的虚拟机。</p>
<p>我们将指令和数据分开存放，这样保证了指令是定长的。因此，我们也需要向指令指出数据存放的位置，所以一个完整的指令集有两部分，指令和参数位置。对于不需要参数的零指令，我们用<code>None</code>表示。</p>
<p>现在我们可以基于栈来实现一个简单的解释器结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_VALUES</span>(<span class="params">self,number</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ADD_TWO_VALUES</span>(<span class="params">self</span>):</span><br><span class="line">        first = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        second = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        total = first + second</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(total)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PRINT_ANSWER</span>(<span class="params">self</span>):</span><br><span class="line">        answer = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>
<p>现在我们已经实现了一个虚拟机的基本结构和支持的指令，我们需要一个方法来驱动我们的虚拟机进行对指令的解析与执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, code</span>):</span><br><span class="line">    insts = code[<span class="string">&quot;inst&quot;</span>]</span><br><span class="line">    nums = code[<span class="string">&quot;num&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> insts:</span><br><span class="line">        inst ,arg = i</span><br><span class="line">        <span class="keyword">if</span> inst == <span class="string">&quot;LOAD_VALUES&quot;</span>:</span><br><span class="line">            num = nums[arg]</span><br><span class="line">            <span class="variable language_">self</span>.LOAD_VALUES(num)</span><br><span class="line">        <span class="keyword">elif</span> inst == <span class="string">&quot;ADD_TWO_VALUES&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.ADD_TWO_VALUES()</span><br><span class="line">        <span class="keyword">elif</span> inst == <span class="string">&quot;PRINT_ANSWER&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.PRINT_ANSWER()</span><br></pre></td></tr></table></figure>
<p>现在我们可以尝试使用它们进行简单的计算<code>3+4+5</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;insts&quot;</span>:[</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUES&quot;</span>,<span class="number">2</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;nums&quot;</span>:[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interpreter = Interpreter()</span><br><span class="line">interpreter.run(code)</span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<p>可以看到虚拟机按照预期输出了我们想要的结果。</p>
<h3 id="变量">变量</h3>
<p>现在我们向虚拟机添加存储功能，我们可以将数值存入变量中，实现变量和值的映射关系，我们将实现以下两个指令：</p>
<ul>
<li>STORE_NAME：存入变量</li>
<li>LOAD_NAME：取变量值</li>
</ul>
<p>为了实现这个功能，我们需要再初始化一个内存空间（这里使用字典比较直观），用于存放变量名和值的绑定关系，同时需要在我们的<code>code</code>中添加变量名。我们的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.mem = &#123;&#125;	<span class="comment"># 添加内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_VALUE</span>(<span class="params">self,number</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(number)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">ADD_TWO_VALUES</span>(<span class="params">self</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        y = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(x+y)	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PRINT_ANSWER</span>(<span class="params">self</span>):</span><br><span class="line">        answer = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">STORE_NAME</span>(<span class="params">self,name</span>):</span><br><span class="line">        val = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">        <span class="variable language_">self</span>.mem[name] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LOAD_NAME</span>(<span class="params">self,name</span>):</span><br><span class="line">        val = <span class="variable language_">self</span>.mem[name]</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数索引可能是访问数字也可能是变量 需要进行判断</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_arg</span>(<span class="params">self,inst,arg,code</span>):</span><br><span class="line">        nums = [<span class="string">&quot;LOAD_VALUE&quot;</span>]</span><br><span class="line">        <span class="built_in">vars</span> = [<span class="string">&quot;STORE_NAMES&quot;</span>, <span class="string">&quot;LOAD_NAMES&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> inst <span class="keyword">in</span> nums:</span><br><span class="line">            arg = code[<span class="string">&quot;nums&quot;</span>][arg]</span><br><span class="line">        <span class="keyword">elif</span> inst <span class="keyword">in</span> <span class="built_in">vars</span>:</span><br><span class="line">            arg = code[<span class="string">&quot;vars&quot;</span>][arg]</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, code</span>):</span><br><span class="line">        insts = code[<span class="string">&quot;insts&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> insts:</span><br><span class="line">            inst ,arg = step</span><br><span class="line">            <span class="comment"># 根据指令内容解析对应的参数</span></span><br><span class="line">            arg = <span class="variable language_">self</span>.parse_arg(inst,arg,code)</span><br><span class="line">            <span class="keyword">if</span> inst == <span class="string">&quot;LOAD_VALUE&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.LOAD_VALUE(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;STORE_NAME&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.STORE_NAME(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;LOAD_NAME&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.LOAD_NAME(arg)</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;ADD_TWO_VALUES&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.ADD_TWO_VALUES()</span><br><span class="line">            <span class="keyword">elif</span> inst == <span class="string">&quot;PRINT_ANSWER&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.PRINT_ANSWER()</span><br></pre></td></tr></table></figure>
<p>这里我们可以试着运行一下<code>x = 3; y = 7; print(x+y)</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;insts&quot;</span>:[</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;STORE_NAME&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_VALUE&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;STORE_NAME&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_NAME&quot;</span>,<span class="number">0</span>),</span><br><span class="line">        (<span class="string">&quot;LOAD_NAME&quot;</span>,<span class="number">1</span>),</span><br><span class="line">        (<span class="string">&quot;ADD_TWO_VALUES&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">        (<span class="string">&quot;PRINT_ANSWER&quot;</span>,<span class="literal">None</span>),</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;nums&quot;</span>:[<span class="number">3</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="string">&quot;vars&quot;</span>:[<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interpreter = Interpreter()</span><br><span class="line">interpreter.run(code)</span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p>成功的运行了我们的函数。</p>
<h3 id="程序结构优化">程序结构优化</h3>
<p>随着我们支持的指令增多，我们需要不断的通过if-else结构来进行对指令的执行。在我们的实现中，类的方法名和字节码中的指令是相同的，所以我们通过<code>getattr</code>方法来对<code>run()</code>进行优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, code</span>):</span><br><span class="line">    insts = code[<span class="string">&quot;insts&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> insts:</span><br><span class="line">        inst ,arg = step</span><br><span class="line">        arg = <span class="variable language_">self</span>.parse_arg(inst,arg,code)</span><br><span class="line">        inst = <span class="built_in">getattr</span>(<span class="variable language_">self</span>,inst)	<span class="comment"># 查找和inst同名的方法</span></span><br><span class="line">        <span class="keyword">if</span> arg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            inst()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            inst(arg)</span><br></pre></td></tr></table></figure>
<h2 id="python字节码">Python字节码</h2>
<p>现在我们可以尝试解析一下真实的Python字节码，我们可以以下面的这个函数为例：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;yes&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以通过特殊方法<code>__code__</code>获取函数的字节码和元信息，具体的用法如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数对象 (function)</span><br><span class="line">    │</span><br><span class="line">    └── __code__  (code对象 - 包含完整元数据)</span><br><span class="line">           │</span><br><span class="line">           ├── co_code     (字节码 - 仅指令)</span><br><span class="line">           ├── co_consts   (常量元组)</span><br><span class="line">           ├── co_varnames (变量名元组)</span><br><span class="line">           ├── co_names    (全局名元组)</span><br><span class="line">           ├── co_argcount (参数数量)</span><br><span class="line">           ├── co_nlocals  (局部变量数量)</span><br><span class="line">           └── ... 其他属性</span><br></pre></td></tr></table></figure>
<p>这里我们可以通过这个方式得到我们的字节码指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">codebyte = <span class="built_in">list</span>(codebyte)</span><br><span class="line"><span class="built_in">print</span>(codebyte)</span><br><span class="line"><span class="comment"># [151, 0, 100, 1, 125, 0, 124, 0, 100, 2, 107, 2, 0, 0, 114, 1, 121, 3, 121, 4]</span></span><br></pre></td></tr></table></figure>
<p>我们得到了这个函数的字节码，但是我们无法阅读它。所以我们需要用到Python中的字节码反汇编器<code>dis</code>，将字节码进行翻译并以可读的形式输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">dis.dis(codebyte)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          0 RESUME                   0</span></span><br><span class="line"><span class="string">          2 LOAD_CONST               1</span></span><br><span class="line"><span class="string">          4 STORE_FAST               0</span></span><br><span class="line"><span class="string">          6 LOAD_FAST                0</span></span><br><span class="line"><span class="string">          8 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         10 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         14 POP_JUMP_IF_FALSE        1 (to 18)</span></span><br><span class="line"><span class="string">         16 RETURN_CONST             3</span></span><br><span class="line"><span class="string">    &gt;&gt;   18 RETURN_CONST             4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中第一列是该指令对应的字节码索引，第二列是该字节码的可读形式，第三列是指令的参数索引（第4列可能会指出使用的是什么参数）</p>
<p>同时我们也可以使用<code>dis</code>库中的<code>opname</code>方法，将对应的字节码翻译成可读的指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">codebyte = cond.__code__.co_code</span><br><span class="line">codebyte = <span class="built_in">list</span>(codebyte)</span><br><span class="line"><span class="built_in">print</span>(dis.opname[codebyte[<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(dis.opname[codebyte[<span class="number">4</span>]])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">RESUME</span></span><br><span class="line"><span class="string">STORE_FAST</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="条件与循环">条件与循环</h3>
<p>一个语言中条件分支和循环结构的能力也很重要，我们可以借这一段字节码深入的理解Python运行的实现。在我们的例子中<code>if x&gt;5</code>被翻译成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span> LOAD_FAST                <span class="number">0</span></span><br><span class="line"> <span class="number">8</span> LOAD_CONST               <span class="number">2</span></span><br><span class="line"><span class="number">10</span> COMPARE_OP               <span class="number">2</span> (&lt;)</span><br><span class="line"><span class="number">14</span> POP_JUMP_IF_FALSE        <span class="number">1</span> (to <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>LOAD_FAST</code>将局部变量加载到栈上，<code>LOAD_CONST</code>将常数<code>5</code>加载到栈上，然后通过<code>COMPARE_OP</code>指定的比较类型，对栈顶的两个数值进行比较，然后将比较结果放回栈上。最终<code>POP_JUMP_IF_FALSE</code>，根据比较的结果，跳转到指定的指令。跳转后要被加载的指令我们称之为跳转目标，作为<code>POP_JUMP</code>的参数，<code>dis</code>会用<code>&gt;&gt;</code>指出跳转目标。</p>
<p>有了条件判断和跳转之后，我们就可以实现最基本的循环结构，我们对下面这个循环结构进行分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cond</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> x&lt;<span class="number">5</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          0 RESUME                   0</span></span><br><span class="line"><span class="string">          2 LOAD_CONST               1</span></span><br><span class="line"><span class="string">          4 STORE_FAST               0</span></span><br><span class="line"><span class="string">          6 LOAD_FAST                0</span></span><br><span class="line"><span class="string">          8 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         10 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         14 POP_JUMP_IF_FALSE       11 (to 38)</span></span><br><span class="line"><span class="string">    &gt;&gt;   16 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         18 LOAD_CONST               1</span></span><br><span class="line"><span class="string">         20 BINARY_OP               13 (+=)</span></span><br><span class="line"><span class="string">         24 STORE_FAST               0</span></span><br><span class="line"><span class="string">         26 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         28 LOAD_CONST               2</span></span><br><span class="line"><span class="string">         30 COMPARE_OP               2 (&lt;)</span></span><br><span class="line"><span class="string">         34 POP_JUMP_IF_FALSE        1 (to 38)</span></span><br><span class="line"><span class="string">         36 JUMP_BACKWARD           11 (to 16)</span></span><br><span class="line"><span class="string">    &gt;&gt;   38 LOAD_FAST                0</span></span><br><span class="line"><span class="string">         40 RETURN_VALUE</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要理解这个循环结构，我们需要从几个跳转指令入手。首先是第一个<code>POP_JUMP</code>，如果判断为真，就进入循环体结构，不为真就直接退出。第二个<code>POP_JUMP</code>则是判断是否退出循环结构。第三个比较特殊<code>JUMP_BACKWARD</code>，它将无条件跳转到循环体的起点。通过跳转和条件分支的功能，实现了循环结构。</p>
<p>其他的语法结构也是类似的，如<code>if ... elif, for ,...</code>，可以通过<code>dis</code>慢慢探索</p>
<h3 id="栈帧">栈帧</h3>
<p>实现了数值的计算和控制转移之后，现在我们需要进一步认识Python
函数调用的过程。正如上面的那个例子，我们看到<code>RETURN_VALUES</code>，那么结束这个函数之后会返回到哪里呢？</p>
<p>如果我们在函数中，我们会返回到调用者。如果是在模块顶层，我们可能会直接结束程序。我们将上一层的信息返回给下一层，例如在递归调用时，我们还需要保存每一层的局部状态。这就引出了Frame的概念，frame是函数调用的一次执行的上下文。它在python运行的过程中不断的被创建和销毁。</p>
<p>对于一个<code>code object</code>，我们可能会有多个frame。但是对于一个<code>frame</code>，我们有且仅对应一个<code>code object</code>。</p>
<p>frame存在于调用栈之中（和C一样）。Python中有三种类型的栈结构：</p>
<ul>
<li>调用栈：用来管理程序运行的函数调用状态</li>
<li>数据栈：用于存放数据</li>
<li>块栈：用于特定的控制流块，如异常和循环结构…</li>
</ul>
<p>在调用栈的每个frame都有它自己的数据栈和块栈。以下面这个程序为例，它在调用栈中的状态大概就是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">y</span>):</span><br><span class="line"><span class="meta">... </span>    z = y + <span class="number">3</span>     </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="meta">... </span>    a = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    b = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + bar(b) </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()             </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://s2.loli.net/2025/12/10/znjbvPiEO2JdBSL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>至此，我们对Python字节码的基本分析就结束了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/04/104-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/04/104-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-15/" class="post-title-link" itemprop="url">104:初始图形学(15)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-04 23:09:01" itemprop="dateCreated datePublished" datetime="2025-12-04T23:09:01+08:00">2025-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-06 10:40:35" itemprop="dateModified" datetime="2025-12-06T10:40:35+08:00">2025-12-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一章中完成了对图形渲染的饿BVH加速，现在我们要尝试将图片纹理映射到物体中。</p>
<h2 id="纹理映射">纹理映射</h2>
<p>图形学中的纹理映射是将材质效果应用于场景中的物理过程。其中”纹理”指的是效果（这个效果可以是材质属性，或是部分存在与否）本身，而映射则是将效果映射到物体的表面上。</p>
<p>最为常见的纹理映射就是将图像映射到物体表面上，就像是把世界地图依附到球体表面。和我们的直觉不同，纹理映射是一个逆向的过程，我们首先确定物体上的一个点，然后查找纹理贴图给定的颜色，以实现对图片的映射。</p>
<p>不过在此之前，我们先用程序化的方式生成纹理颜色，并创建一个纹理贴图。为了执行纹理查找，我们需要物体表面的纹理坐标<code>(u,v)</code>以定位纹理中的像素，同时也需要保存当前点的三维坐标（部分纹理需要这一部分的信息）</p>
<h3 id="恒定色彩纹理">恒定色彩纹理</h3>
<p>我们的纹理颜色类将从最简单的恒定色彩纹理开始实现，实际上我们可以将物体的颜色也视作一种纹理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">texture</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">solid_color</span>(<span class="type">const</span> color&amp; albedo) : <span class="built_in">albedo</span>(albedo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue) : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red,green,blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> albedo;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里我们先实现对纹理类的接口的一个实现，然后创建一个恒定色彩纹理类，返回恒定的颜色类型。</p>
<p>注意到我们这里需要使用到<code>(u,v)</code>表面坐标，我们还需要更新<code>hit_record</code>结构，对这些射线碰撞信息进行存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 p;</span><br><span class="line">    <span class="type">double</span> u;</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">    vec3 normal;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="棋盘纹理">棋盘纹理</h3>
<p>棋盘纹理作为实体纹理中的一种。实体纹理取决点在空间中的位置，我们可以理解为给空间中的指定点进行着色，而不是给空间中的某个物体上色。正因如此，当我们的物体在空间中移动时，纹理并不会随物体进行移动，反而像是物体在穿过纹理。</p>
<p>这里我们将实现一个棋盘纹理类，它是一种空间纹理（即实体纹理）。根据点在空间中给定的位置进行纹理颜色的渲染。</p>
<p>为了实现棋盘格图案，我们需要对当前点的每个坐标分量取<code>floor</code>，这样我们就将整个空间分割为<code>1x1x1</code>的单元格，每个坐标都可以映射到对应的单元格，我们对奇数的单元格赋予一种颜色，对偶数赋予另外的一种颜色，这样就实现了棋盘的样式。同时我们还可以设置一个缩放因子<code>scale</code>，控制单元格的大小，从而实现对棋盘格的大小控制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">checker_texture</span>(<span class="type">double</span> scale, shared_ptr&lt;texture&gt; even, shared_ptr&lt;texture&gt; odd)</span><br><span class="line">            : <span class="built_in">inv_scale</span>(<span class="number">1.0</span>/scale), <span class="built_in">even</span>(even), <span class="built_in">odd</span>(odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">checker_texture</span>(<span class="type">double</span> scale, <span class="type">const</span> color&amp; c1, <span class="type">const</span> color&amp; c2)</span><br><span class="line">            : <span class="built_in">checker_texture</span>(scale, <span class="built_in">make_shared</span>&lt;solid_color&gt;(c1), <span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> xInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">x</span>()));</span><br><span class="line">            <span class="keyword">auto</span> yInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">y</span>()));</span><br><span class="line">            <span class="keyword">auto</span> zInt = <span class="built_in">int</span>(<span class="built_in">floor</span>(inv_scale*p.<span class="built_in">z</span>()));</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> isEven = (xInt + yInt + zInt) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> isEven ? even-&gt;<span class="built_in">value</span>(u,v,p) : odd-&gt;<span class="built_in">value</span>(u,v,p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> inv_scale;</span><br><span class="line">        shared_ptr&lt;texture&gt; even;</span><br><span class="line">        shared_ptr&lt;texture&gt; odd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了进一步的支持纹理，我们拓展<code>lambertian</code>类，使用纹理代替颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; albedo) : <span class="built_in">tex</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(albedo)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; tex) : <span class="built_in">tex</span>(tex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>()) &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = tex-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; tex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里通过多态的思想实现了对<code>lambertian</code>材质的纹理的实现。</p>
<p>现在我们可以向我们的场景中添加纹理了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// main.cpp中将地面设置成棋盘样式</span></span><br><span class="line"><span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="number">0.2</span>, <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">color</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">   world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br></pre></td></tr></table></figure>
<p>渲染结果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/12/05/UjK8dAB24pCTE7O.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="空间纹理的特殊情况">空间纹理的特殊情况</h3>
<p>正如之前所提到的，这种实体纹理的上色方式，更像是物体在穿过纹理，从而完成上色。</p>
<p>我们现在创建一个新的场景来观察这种特殊的情况，我们将先前的main函数保存为一个<code>bounding_ball</code>场景，然后现在我们再来创建一个新的场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkered_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="number">0.32</span>, <span class="built_in">color</span>(<span class="number">.2</span>, <span class="number">.3</span>, <span class="number">.1</span>), <span class="built_in">color</span>(<span class="number">.9</span>, <span class="number">.9</span>, <span class="number">.9</span>));</span><br><span class="line"></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    cam.aspect_ratio      = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width       = <span class="number">800</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth         = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过main函数中的switch来切换我们想要渲染的场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: bounding_ball(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: checkered_spheres(); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们渲染出来的结果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/12/05/QbeljFrXuinURdN.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这就是空间纹理渲染的特殊情况，不过你应该能理解这是什么情况。所以为了解决这个问题，我们需要使用表面纹理，这就意味着我们需要根据<code>(u,v)</code>的球体表面位置信息来创建纹理。</p>
<h3 id="球体表面纹理坐标">球体表面纹理坐标</h3>
<p>空间纹理通过空间中一点的坐标，实现纹理的绘制。但是真如我们先前所提到的空间纹理的局限性，我们希望能够更具球体表面的坐标实现对图像点对点的映射。这就以为着我们需要一种方法来查找三维球体表面任意点的坐标<code>(u,v)</code>。</p>
<p>这里用到一个经纬度的思想，首先确定出这个点在球体上的经纬度<span
class="math inline">(<em>θ</em>, <em>ϕ</em>)</span>（横纬竖经，这里<span
class="math inline"><em>θ</em></span>从-Y向上，<span
class="math inline"><em>ϕ</em></span>从-X到+Z到+X到-Z），然后再将球面坐标表示出来，这里的话，如果学过球面坐标，自然能够得到以下式子：
$$ <span
class="math display"><em>我</em><em>们</em><em>可</em><em>以</em><em>简</em><em>单</em><em>的</em><em>推</em><em>导</em><em>得</em><em>到</em>：</span>
$$
所以我们可以写出<code>sphere</code>类中的<code>get_uv</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> theta = std::<span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> phi = std::<span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(),p.<span class="built_in">x</span>()) + pi;</span><br><span class="line">    u = phi / (<span class="number">2</span>*pi);</span><br><span class="line">    v = theta / pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们向<code>hit</code>方法中添加，每次碰撞记录的<code>(u,v)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      rec.t = root;</span><br><span class="line">      rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">      vec3 outward_normal = (rec.p - cur_center) / radius;</span><br><span class="line">      rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">      <span class="comment">// 这里的outward 就是从球心指向碰撞点的向量</span></span><br><span class="line">      <span class="built_in">get_uv</span>(outward_normal,rec.u,rec.v);</span><br><span class="line">      rec.mat = mat;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就实现了对球体表面的位置的<code>(u,v)</code>二维定位</p>
<h3 id="访问纹理图像数据">访问纹理图像数据</h3>
<p>现在我们需要一种手段，将图片数据解析为一种二维关系，我们希望通过<code>(u,v)</code>访问图像数据上对应的像素值。所以我们需要将图片加载为一个浮点数数组，便于我们访问。这里我们使用第三方库<code>stb_image.h</code>来实现</p>
<p>首先我们创建一个辅助类来帮助我们管理图片信息内容，以提供一个<code>pixel_data(int x,int y)</code>方法，来访问任意像素的8位（unsigned
char）RGB。</p>
<p>我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (push,0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STBI_FAILURE_USERMSG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">image</span>(<span class="type">const</span> <span class="type">char</span>* image_file)&#123;</span><br><span class="line">            <span class="keyword">auto</span> filename = std::<span class="built_in">string</span>(image_file);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">load</span>(<span class="string">&quot;../images/&quot;</span> + filename)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load image file&quot;</span> &lt;&lt; image_file &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">image</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] bdata;</span><br><span class="line">            <span class="built_in">STBI_FREE</span>(fdata);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> n = bytes_per_pixel;</span><br><span class="line">            fdata = <span class="built_in">stbi_loadf</span>(filename.<span class="built_in">c_str</span>(), &amp;image_width, &amp;image_height, &amp;n, bytes_per_pixel);</span><br><span class="line">            <span class="keyword">if</span>(fdata == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            byte_per_scanline = bytes_per_pixel * image_width;</span><br><span class="line">            <span class="built_in">convert_to_bytes</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (fdata==<span class="literal">nullptr</span>) ? <span class="number">0</span> : image_width;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> (fdata==<span class="literal">nullptr</span>) ? <span class="number">0</span> : image_height;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* <span class="title">pixel_data</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> magenta[] = &#123;<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(bdata==<span class="literal">nullptr</span>) <span class="keyword">return</span> magenta;</span><br><span class="line"></span><br><span class="line">            x = <span class="built_in">clamp</span>(x,<span class="number">0</span>,image_width);</span><br><span class="line">            y = <span class="built_in">clamp</span>(y,<span class="number">0</span>,image_height);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bdata + x*bytes_per_pixel + y*byte_per_scanline;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;      <span class="comment">// 每像素的位数(即通道数)</span></span><br><span class="line">        <span class="type">float</span>* fdata = <span class="literal">nullptr</span>;             <span class="comment">// 浮点像素数据</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* bdata = <span class="literal">nullptr</span>;     <span class="comment">// 8bit像素数据</span></span><br><span class="line">        <span class="type">int</span> image_width = <span class="number">0</span>;                <span class="comment">// 图像宽度</span></span><br><span class="line">        <span class="type">int</span> image_height = <span class="number">0</span>;               <span class="comment">// 图像高度</span></span><br><span class="line">        <span class="type">int</span> byte_per_scanline = <span class="number">0</span>;          <span class="comment">// 宽的像素数量</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// return [low,high)</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">clamp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; low) <span class="keyword">return</span> low;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; high) <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">return</span> high - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title">float_to_byte</span><span class="params">(<span class="type">float</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value &lt;= <span class="number">0.0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(value &gt;= <span class="number">1.0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(value*<span class="number">256.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">convert_to_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> total_bytes = bytes_per_pixel * image_height * image_width;</span><br><span class="line">            bdata = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[total_bytes];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> *bptr = bdata;</span><br><span class="line">            <span class="keyword">auto</span> *fptr = fdata;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;total_bytes ; i++,fptr++,bptr++)</span><br><span class="line">                *bptr = <span class="built_in">float_to_byte</span>(*fptr);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>现在我们封装好了一个加载并获取图像内容的<code>image</code>类，我们可以利用它实现图像纹理<code>image_texture</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) : <span class="built_in">image</span>(filename)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(image.<span class="built_in">height</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            u = <span class="built_in">interval</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="built_in">clamp</span>(u);</span><br><span class="line">            <span class="comment">// 由于图片坐标起始位置是从左上角开始</span></span><br><span class="line">            <span class="comment">// 而图形学坐标从左下角开始,所以需要进行反转</span></span><br><span class="line">            v = <span class="number">1.0</span> - <span class="built_in">interval</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="built_in">clamp</span>(v);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> i = <span class="built_in">int</span>(u*image.<span class="built_in">width</span>());</span><br><span class="line">            <span class="keyword">auto</span> j = <span class="built_in">int</span>(v*image.<span class="built_in">height</span>());</span><br><span class="line">            <span class="keyword">auto</span> pixel = image.<span class="built_in">pixel_data</span>(i,j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale*pixel[<span class="number">0</span>], color_scale*pixel[<span class="number">1</span>], color_scale*pixel[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        image image;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="图像纹理渲染">图像纹理渲染</h3>
<p>现在我们可以尝试将一个图片进行渲染：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(<span class="string">&quot;earthmap.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    cam.aspect_ratio      = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width       = <span class="number">2000</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth         = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">-3.75</span>,<span class="number">4</span>,<span class="number">-9</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(<span class="built_in">hittable_list</span>(globe));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一张地球的贴图（效果如下）：</p>
<figure>
<img src="https://s2.loli.net/2025/12/06/xqdSVgTYlvJirGc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>至此 我们的纹理样式就简单介绍完了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/02/103-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/02/103-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-14/" class="post-title-link" itemprop="url">103:初始图形学(14)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-02 15:27:57" itemprop="dateCreated datePublished" datetime="2025-12-02T15:27:57+08:00">2025-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-03 15:34:25" itemprop="dateModified" datetime="2025-12-03T15:34:25+08:00">2025-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，上一次实现了物体运动下的图形学渲染。实现了动态模糊的构建。</p>
<h2 id="包围体积层级">包围体积层级</h2>
<p>现在随着我们场景的复杂化，和对图片质量的提升，有时候渲染一张照片都需要十几分钟。为了让代码运行的更快，我们需要引入一个新的结构
<strong>包围体积层级BVH</strong>，以优化程序渲染的性能。</p>
<p>射线 -
对象求交，是光线追踪过程中的主要性能瓶颈，运行的时间和物体的数量呈线性关系。每当我们发射一条射线，就需要对场景内的所有物体进行求交判断。但是实际上和很多物体的求交是没有必要的，我们向天空发射的一条光线并不会和地上的物体有所交集。</p>
<p>所以我们为了优化这个过程，我们需要避免不必要的射线 -
对象求交计算，接下来我们要学习的方法就是通过包围体积层次来实现对求交场景的优化。</p>
<h3 id="关键思想">关键思想</h3>
<p>为一组对象创建一个完全包围所有对象的包围盒，假如射线会错过这个包围盒，那么它一定会错过这个包围盒中的所有物体，反之，则有可能击中盒中的任意一个对象，所以我们的思想如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ray hits bounding object)</span><br><span class="line">    <span class="keyword">return</span> whether ray hits bounded objects</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="包围体积的层级">包围体积的层级</h3>
<p>为了提高计算的效率，使得处理时间的增长速度慢于物体数量的增长。首先我们需要构建有一个层次化的包围体结构，这里我们通过自顶向下的方法，生成我们的包围体积的层级结构。</p>
<p>一开始我们需要构建一个层次化的包围体结构，用大的包围体包住一群物体，再逐层细化，就像下面这样：</p>
<figure>
<img src="https://s2.loli.net/2025/12/02/hiExpVKkSr8UoDW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以写出以下伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hit purple)</span><br><span class="line">    hit0 = hits blue enclosed objects</span><br><span class="line">    hit1 = hits red enclosed objects</span><br><span class="line">    <span class="keyword">if</span>(hit0 or hit1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> and info of closer hit</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当我们确定击中紫色包围盒时，分别对里面的蓝色组和红色组进行分析，从而进一步缩小碰撞检测的范围</p>
<h3 id="轴对齐边界框aabbs">轴对齐边界框(AABBs)</h3>
<p>要让整个层次结构高效工作，我们需要要一个好的划分方式，而且我们需要一个较快的检测光线和包围体相交的算法，否则我们检测相交的速度会抵消掉包围结构层次带来的加速效果。这里我们选择轴对齐包围盒作为我们的包围体。我们通常将其称为AABB。</p>
<p>接下来我们需要了解光线和AABB相交检测的slab方法：</p>
<p>首先我们需要知道什么是片层(Slab)，片层是在一个坐标轴方向上，由两个平行平面围成的空间区域，比如在
x 轴方向，若 AABB 的 x 范围是 [x_min, x_max]，那么这个 slab 就是所有满足
<code>x_min ≤ x ≤ x_max</code>
的点。在我们要用到的3D场景中，<code>AABB = x-slab &amp;&amp; y-slab &amp;&amp; z-slab</code>。</p>
<p>理解片层之后，我们检测碰撞的关键就在于计算光线和不同片层之间的交点，其中射线的函数定于为<span
class="math inline"><em>P</em>(<em>t</em>) = <em>Q</em> + <em>t</em><em>d</em></span>，我们可以求出其在<span
class="math inline"><em>x</em> = <em>x</em><sub>0</sub><em>t</em></span>平面的交点为：
<span class="math display">$$
\begin{align*}
x_0 &amp;= Q_x + t_0d_x \\
t_0 &amp;= \frac{x_0 - Q_x}{d_x} \\
t_1 &amp;= \frac{x_1 - Q_x}{d_x}
\end{align*}
$$</span>
知道光线与各个片层之间的交点之后，我们可以进一步判断光线和AABB的相交情况了，以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/12/02/YKCFflJMg4nLVIi.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是一个二维的AABB场景，上面的射线和x、y片层中的交集段并没有重叠，所以我们知道射线并没有和AABB发生交集，下面的射线和x、y片层的交集段发生了重叠，所以说射线和AABB之间是有交集的。</p>
<h3 id="与aabb的射线交">与AABB的射线交</h3>
<p>上图我们可以用于以下伪代码确定射线是否和AABB发生碰撞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interval_x &lt;- compute_intersection_x(ray, x0, x1)</span><br><span class="line">interval_y &lt;- compute_intersection_y(ray, y0, y1)</span><br><span class="line"><span class="keyword">return</span> overlaps(interval_x, interval_y)</span><br></pre></td></tr></table></figure>
<p>相应的三维版本如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interval_x &lt;- compute_intersection_x(ray, x0, x1)</span><br><span class="line">interval_y &lt;- compute_intersection_y(ray, y0, y1)</span><br><span class="line">interval_z &lt;- compute_intersection_z(ray, z0, z1)</span><br><span class="line"><span class="keyword">return</span> overlaps(interval_x, interval_y, interval_z)</span><br></pre></td></tr></table></figure>
<p>我们已经知道了怎么求出射线和片层的相交区间，我们需要进一步的检测这些相交区间是否有交集，现在，我们的关键在于实现<code>overlaps</code>了，在此之前我们需要考虑以下几种特殊情况：</p>
<ul>
<li>如果射线沿着负x方向运动，我们的计算得到的区间会发生反转，所以我们始终需要根据<code>min</code>和<code>max</code>来标识我们的区间</li>
<li>当<span
class="math inline"><em>d</em><sub><em>x</em></sub></span>为0
或接近0时，会求得t为<code>-infinity/+infinity</code>，我们通过min/max可以解决这个问题</li>
<li>当<span
class="math inline"><em>d</em><sub><em>x</em></sub></span>为0 但<span
class="math inline"><em>Q</em><sub><em>x</em></sub></span>在AABB的界限上/界限内时，加缓冲防止边界问题</li>
</ul>
<p>现在我们可以写出伪函数<code>overlaps</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">overlaps</span><span class="params">(t_interval1, t_interval2)</span></span><br><span class="line">    t_min = max(t_interval.min, t_interval2.min)</span><br><span class="line">    t_max = min(t_interval.max, t_interval2.max)</span><br><span class="line">    <span class="keyword">return</span> t_max&gt;t_min</span><br></pre></td></tr></table></figure>
<p>对于第三种特殊情况，此时我们无法给出准确的<code>t_min</code>和<code>t_max</code>，所以我们将这个情况称之为<code>NaN</code>，这里我们需要进行手动的处理，为区间添加一个padding，将NaN的情况视作<code>fasle</code></p>
<p>为此我们需要为<code>interval</code>添加一个<code>expend</code>函数，它给区间填充给定的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">interval</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function">interval <span class="title">expand</span><span class="params">(<span class="type">double</span> delta)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> padding = delta/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">interval</span>(min-padding, max+padding);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> interval empty,universe;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>
<p>现在，我们可以开始实现AABB类了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        interval x,y,z;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">aabb</span>() &#123;&#125;   <span class="comment">// 默认为空</span></span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> interval&amp; x, <span class="type">const</span> interval&amp; y, interval&amp; z)</span><br><span class="line">            : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">        <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; a, <span class="type">const</span> point3&amp; b)&#123;</span><br><span class="line">            <span class="comment">// 这里的a和b是AABB盒的对顶角</span></span><br><span class="line">            x = (a[<span class="number">0</span>]&lt;=b[<span class="number">0</span>]) ? <span class="built_in">interval</span>(a[<span class="number">0</span>],b[<span class="number">0</span>]) : <span class="built_in">interval</span>(b[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line">            y = (a[<span class="number">1</span>]&lt;=b[<span class="number">1</span>]) ? <span class="built_in">interval</span>(a[<span class="number">1</span>],b[<span class="number">1</span>]) : <span class="built_in">interval</span>(b[<span class="number">1</span>],a[<span class="number">1</span>]);</span><br><span class="line">            z = (a[<span class="number">2</span>]&lt;=b[<span class="number">2</span>]) ? <span class="built_in">interval</span>(a[<span class="number">2</span>],b[<span class="number">2</span>]) : <span class="built_in">interval</span>(b[<span class="number">2</span>],a[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> interval&amp; <span class="title">axis_interval</span><span class="params">(<span class="type">int</span> n)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> y;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> z;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval <span class="type">ray_t</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="type">const</span> point3&amp; ray_orig = r.<span class="built_in">origin</span>();</span><br><span class="line">            <span class="type">const</span> vec3&amp; ray_dir = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> axis=<span class="number">0</span>;axis&lt;<span class="number">3</span>;axis++)&#123;</span><br><span class="line">                <span class="type">const</span> interval&amp; ax = <span class="built_in">axis_interval</span>(axis);</span><br><span class="line">                <span class="type">const</span> <span class="type">double</span> adinv = <span class="number">1.0</span> / ray_dir[axis];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t0 = (ax.min - ray_orig[axis]) * adinv;</span><br><span class="line">                <span class="keyword">auto</span> t1 = (ax.max - ray_orig[axis]) * adinv;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 收缩区间（取交集）</span></span><br><span class="line">                <span class="keyword">if</span>(t0 &lt; t1)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t0 &gt; <span class="type">ray_t</span>.min) <span class="type">ray_t</span>.min = t0;</span><br><span class="line">                    <span class="keyword">if</span>(t1 &lt; <span class="type">ray_t</span>.max) <span class="type">ray_t</span>.max = t1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t1 &gt; <span class="type">ray_t</span>.min) <span class="type">ray_t</span>.min = t1;</span><br><span class="line">                    <span class="keyword">if</span>(t0 &lt; <span class="type">ray_t</span>.max) <span class="type">ray_t</span>.max = t0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 说明无交点</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="type">ray_t</span>.min &gt;= <span class="type">ray_t</span>.max)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里的关键在于<code>hit</code>函数，我们通过区间收缩的方式实现对交集的判断。</p>
<h3 id="为可击中类创建包围盒">为可击中类创建包围盒</h3>
<p>现在我们需要为所有的可击中类构建一个包围盒，对于单个的物体，我们将其包围盒视作包围结构层次中的叶子节点，这个我们之后会提到。</p>
<p>由于我们的物体有部分是动画的，所以我们为其生成的包围盒边界应该等于其运动范围，首先，我们需要升级我们的<code>hittable</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">hittable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于静态和动态的球体，我们很容易为其创建出包围盒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span>: <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; static_center, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(static_center,<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rvec = <span class="built_in">vec3</span>(radius,radius,radius);</span><br><span class="line">            bbox = <span class="built_in">aabb</span>(static_center - rvec, static_center + rvec);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 动态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center1, <span class="type">const</span> point3&amp; center2, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center1,center2-center1), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;</span><br><span class="line">            <span class="keyword">auto</span> rvec = <span class="built_in">vec3</span>(radius,radius,radius);</span><br><span class="line">            <span class="function">aabb <span class="title">box1</span><span class="params">(center.at(<span class="number">0</span>) - rvec, center.at(<span class="number">0</span>) + rvec)</span></span>;</span><br><span class="line">            <span class="function">aabb <span class="title">box2</span><span class="params">(center.at(<span class="number">1</span>) - rvec, center.at(<span class="number">1</span>) + rvec)</span></span>;</span><br><span class="line">            bbox = <span class="built_in">aabb</span>(box1,box2);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里注意到我们直接将box1和box2合并成了一个新的包围盒区间，这是我们新定义的一种构造方法，也便于之后的包围盒合并：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">aabb</span>(<span class="type">const</span> aabb&amp; box1, <span class="type">const</span> aabb&amp; box2)&#123;</span><br><span class="line">       x = <span class="built_in">interval</span>(box<span class="number">1.</span>x, box<span class="number">2.</span>x);</span><br><span class="line">       y = <span class="built_in">interval</span>(box<span class="number">1.</span>y, box<span class="number">2.</span>y);</span><br><span class="line">       z = <span class="built_in">interval</span>(box<span class="number">1.</span>z, box<span class="number">1.</span>z);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 这里用到的Interval合并形式，来自于interval类中新定义的合并构造</span></span><br><span class="line"><span class="built_in">interval</span>(<span class="type">const</span> interval&amp; a,<span class="type">const</span> interval&amp; b)&#123;</span><br><span class="line">       min = a.min &lt;= b.min ? a.min : b.min;</span><br><span class="line">       max = a.max &gt;= b.max ? a.max : b.max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建对象列表的边界框">创建对象列表的边界框</h3>
<p>现在我们需要更新对象列表<code>hittable_list</code>，现在列表中的物体被创建时，会生成相应的包围盒边界。而我们需要随着每个新子节点的加入逐步的更新边界框，于是我们有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    aabb bbox;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">	....</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; </span><br><span class="line">        objects.<span class="built_in">push_back</span>(object); </span><br><span class="line">        bbox = <span class="built_in">aabb</span>(bbox,object-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bvh节点类">BVH节点类</h3>
<p>BVH本质上也是一个<code>hittable</code>
，它代表一组几何体，光线可以击中它以进行相交判断。我们将它视作一个对象的容器，它封装了几何体，通过包围盒相交测试进行加速检测。</p>
<p>我们通过一个类来实现它，它既可以是节点，也可以是整棵树的根：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AABB.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span>: <span class="keyword">public</span> hittable&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">            <span class="comment">// 待具体实现</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">bvh_node</span>(hittable_list list): <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 重载并使用了上面的初始化方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval <span class="type">ray_t</span>, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bbox.<span class="built_in">hit</span>(r,<span class="type">ray_t</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, <span class="type">ray_t</span>, rec);</span><br><span class="line">            <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, <span class="type">ray_t</span>, rec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> hit_left||hit_right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">aabb <span class="title">bounding_box</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;<span class="keyword">return</span> bbox;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        shared_ptr&lt;hittable&gt; left;</span><br><span class="line">        shared_ptr&lt;hittable&gt; right;</span><br><span class="line">        aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来的重点在于怎么将<code>hittable_list</code>构建成我们想要的BVH。我们希望每个BVH下至多有两个左右节点，但是我们以什么为依据进行划分呢，以下是我们的做法：</p>
<ul>
<li>xyz轴任选其一</li>
<li>根据轴值进行排序</li>
<li>将子树对半存放</li>
</ul>
<p>当我们构建BVH的递归生成时，会有以下几种情况：</p>
<ul>
<li>list表中剩余一个物体，我们让BVH节点的子树均指向它</li>
<li>list表中剩余两个物体，我们让BVH节点的左右子树分别指向</li>
<li>list表中有两个以上物体，我们取一轴进行排序，递归进行生成BVH</li>
</ul>
<p>因此，我们的BVH生成的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bvh_node(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">    <span class="type">int</span> axis = random_int(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis==<span class="number">0</span>) ? box_x_compare : (axis==<span class="number">1</span>) ? box_y_compare : box_z_compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(object_span == <span class="number">1</span>)&#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object_span == <span class="number">2</span>)&#123;</span><br><span class="line">        left = objects[start];</span><br><span class="line">        right = objects[start+<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sort(<span class="built_in">std</span>::begin(objects)+start, <span class="built_in">std</span>::begin(objects)+end, comparator);</span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">        left = make_shared&lt;bvh_node&gt;(objects, start, mid);</span><br><span class="line">        right = make_shared&lt;bvh_node&gt;(objects, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    bbox = aabb(left-&gt;bounding_box(), right-&gt;bounding_box());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>sort</code>使用的判断逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis_index</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> a_axis_interval = a-&gt;<span class="built_in">bounding_box</span>().<span class="built_in">axis_interval</span>(axis_index);</span><br><span class="line">            <span class="keyword">auto</span> b_axis_interval = b-&gt;<span class="built_in">bounding_box</span>().<span class="built_in">axis_interval</span>(axis_index);</span><br><span class="line">            <span class="keyword">return</span> a_axis_interval.min &lt; b_axis_interval.min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_x_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_y_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">box_z_compare</span> <span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过实际上我们是可以对这一部分优化的。我们希望构造出来的BVH树是均衡的，所以每次对场景内的物体进行划分时，我们希望，左右子树的分布是均衡的，这就要求我们每次选择的检测轴应该是边长最长的轴。为此我们需要一个函数为我们计算出包围盒的范围，我们将以此为依据实现更加平衡的BVH树结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bvh_node</span>(std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; objects, <span class="type">size_t</span> start, <span class="type">size_t</span> end) &#123;</span><br><span class="line">            bbox = aabb::empty;</span><br><span class="line">    		<span class="comment">// 对区间内的所有包围盒取并集 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> object_index = start; object_index &lt; end; object_index++)</span><br><span class="line">                bbox = <span class="built_in">aabb</span>(bbox, objects[object_index]-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">            <span class="comment">// 选择边长最大的维度 作为划分轴</span></span><br><span class="line">            <span class="type">int</span> axis = bbox.<span class="built_in">longest_axis</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> comparator = (axis==<span class="number">0</span>) ? box_x_compare : (axis==<span class="number">1</span>) ? box_y_compare : box_z_compare;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> object_span = end - start;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(object_span == <span class="number">1</span>)&#123;</span><br><span class="line">                left = right = objects[start];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object_span == <span class="number">2</span>)&#123;</span><br><span class="line">                left = objects[start];</span><br><span class="line">                right = objects[start<span class="number">+1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sort</span>(std::<span class="built_in">begin</span>(objects)+start, std::<span class="built_in">begin</span>(objects)+end, comparator);</span><br><span class="line">                <span class="keyword">auto</span> mid = start + object_span/<span class="number">2</span>;</span><br><span class="line">                left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid);</span><br><span class="line">                right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bbox = <span class="built_in">aabb</span>(left-&gt;<span class="built_in">bounding_box</span>(), right-&gt;<span class="built_in">bounding_box</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>为了实现对最长轴的判断 和
包围盒并集的实现，我们需要优化我们的<code>aabb</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 取最长轴</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">longest_axis</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.<span class="built_in">size</span>() &gt; y.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> x.<span class="built_in">size</span>() &gt; z.<span class="built_in">size</span>() ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> y.<span class="built_in">size</span>() &gt; z.<span class="built_in">size</span>() ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 空包围盒 与 无限包围盒</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> aabb empty, universe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> aabb aabb::empty = <span class="built_in">aabb</span>(interval::empty, interval::empty, interval::empty);</span><br><span class="line"><span class="type">const</span> aabb aabb::universe = </span><br><span class="line">    <span class="built_in">aabb</span>(interval::universe, interval::universe, interval::universe);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们就实现了图形的加速渲染。太爽了。</p>
<p>速度差不多提升3-4倍，随着场景规模的提升，这个提升的效果更加明显，可以借下面这个图来感受一下。我们差不多实现了从<code>O(n)</code>到<code>O(logn)</code>的优化：</p>
<figure>
<img src="https://s2.loli.net/2025/12/03/xng6zXZkY4U8GOK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/" class="post-title-link" itemprop="url">102:日后安排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-01 12:01:20 / 修改时间：12:36:00" itemprop="dateCreated datePublished" datetime="2025-12-01T12:01:20+08:00">2025-12-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>795</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近思绪有点乱，感觉要做的事情很多，但是不知道何从下手，所以我要从头缕一缕现在的问题。</p>
<p>首先是分析一下现阶段我要做的事情，按优先级进行分类：</p>
<ul>
<li>课程任务：（这几门课是这个学期的大头）
<ul>
<li><strong>离散数学</strong>：这个课我现在最大的问题就是没有明确的学习路线（对着书硬啃？找个网课学？）</li>
<li><strong>概率论</strong>：这个课我的进度很慢，但是有一高数的课程可以跟着学习，可以从现在开始每天学一点</li>
<li>操作系统：这个课我学的还行，但是我对自己有一定的要求，不想只是简单学会</li>
<li><strong>计算机组成原理</strong>：这个课的应试考法我也不是很熟悉，对于数据的部分不是很熟悉，其他的还可以，但是我对自己也有一定的有要求</li>
<li>数据结构：这门课学的还行，但是不熟悉应试的考法</li>
<li>密码学：目前不清楚考试考察的方向，需要花时间巩固</li>
<li>Python：现在要开始准备大作业</li>
<li><strong>Java</strong>：需要对着PPT再进一步学习，需要准备大作业</li>
<li>毛思想：需要了解一下考什么，和题型。考前需要花时间学习一下</li>
</ul></li>
<li>课外任务：
<ul>
<li><strong>科研任务</strong>：科研训练从和开始入手，怎么去查看论文，怎么去找创新点，怎么去构建项目。</li>
<li>个人任务：
<ul>
<li>锻炼身体：需要加强身体的锻炼和饮食的均衡</li>
<li>练习英语：提升英语水平</li>
<li>CTF二进制安全竞技水平</li>
<li>学习新知识</li>
<li>看书阅读</li>
</ul></li>
</ul></li>
</ul>
<p>这里加粗的部分是需要着重注意的地方，那么我该怎么安排呢？</p>
<h3 id="生活上的安排">生活上的安排</h3>
<p>首先是睡眠，每天十二点必须上床，手机最多玩到十二点半就要睡觉。有早八就七点一十起床，没早八就八点起床。周日可以休息久一点</p>
<p>每天早上至少喝一瓶牛奶，还有早餐。在寝室的期间要喝热水。平时尽量不喝奶茶喝其他饮料，也要控制自己的饮食，不能像以前一样想怎么吃就怎么吃。</p>
<p>平时要坚持锻炼，一周至少锻炼4次，两次耐力，两次力量。没事的时候可以在寝室举哑铃</p>
<p>每天要积极一点，心情不好就出去走一走，要开心。</p>
<p>节假日和周六晚上可以玩久一点游戏，平时尽量少玩一点。要珍惜现在的时间。</p>
<h3 id="学习上的安排">学习上的安排</h3>
<p>除掉周日，单日学概率论，双日学离散数学，每天至少完成一个章节的学习。在什么课上学什么的知识，不能拆东墙补西墙。</p>
<p>这周之内要开始科研训练的内容，首先给出自己一个项目的框架，可行demo</p>
<p>课余的时间学什么由自己决定，优先课程的任务。</p>
<h3 id="感情上的安排">感情上的安排</h3>
<p>别想太多 要接受分开的事实 继续走下去</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">101:DWADRF信息解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-24 10:26:27" itemprop="dateCreated datePublished" datetime="2025-11-24T10:26:27+08:00">2025-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:22" itemprop="dateModified" datetime="2025-11-29T13:49:22+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上个学期也尝试了解过这些，但是那个时候还没有接触编译链接，对DWARF信息的理解不够深刻。最近有计划了解一下调试器的原理，所以重新捡起来好好学一遍。</p>
<p>我参考的教程是DWARF的官方介绍文档<a
target="_blank" rel="noopener" href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf">Debugging
using DWARF</a>，作为对其的简单了解</p>
<h2 id="dwarf概述">DWARF概述</h2>
<p>一开始我并不知道怎么说明这一部分，AI给了我一个很好的比方。如果说程序是一个设计图纸（源代码），它事无巨细的包含一个城市的所有信息，那么编译器就是一个工程师，他根据设计图纸将建造出城市（可执行文件）。而DWARF信息，就相当于这个城市的地图，它告诉你每条街道（机器指令，数据信息）对应设计图中的哪个位置（源代码）。而调试器就是一个导游，它根据这个地图带你去任何地方。</p>
<p>现代的编程语言大多是块状结构的，一个实体往往包含着更多的实体，每个实体中可能都有若干个数据和函数定义，那么在这个实体中，就产生了词法的作用域。这个定义仅在被定义的作用域中有意义。</p>
<p>我们可以用一个常见的文件结构来描述这种特征：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源文件</span><br><span class="line">├── 函数A</span><br><span class="line">│   ├── 变量x</span><br><span class="line">│   ├── 语句块1</span><br><span class="line">│   │   ├── 变量y (只在当前块内有效)</span><br><span class="line">│   │   ├── 函数C</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── 函数B</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure>
<p>对于数据和函数一类的内容，我们按照编译链接的习惯，称之为符号。一般情况下，一个符号的作用域属于当前块（也可以通过关键词指定作用域范围）。所以我们要查找特定符号的定义，先从当前作用域中查找定义，然后从连续的外层定义域中依次查找，直到找到该符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var;          <span class="comment">// 全局作用域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">()</span> &#123;     <span class="comment">// 函数作用域</span></span><br><span class="line">    <span class="type">int</span> local_var;       <span class="comment">// 函数内有效</span></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="type">int</span> block_var;   <span class="comment">// 只在if块内有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block_var 在这里结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接的过程中，这些信息会被抛弃或者是简化。因为编译器只在乎对内存和寄存器的管理和操作，所以我们很难根据机器指令去恢复这些信息。</p>
<p>所以这里我们就需要DWARF信息来保存这些信息，DWARF和程序语义一样，通过树状结构来组织信息。DWARF中的所有描述性实体都包含在一个父条目中，且实体中还可以包含更多节点，这些节点可能表示类型，变量或是函数…一个常见的结构可以是下面这样的：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译单元 (CU)</span><br><span class="line">├── 函数: main</span><br><span class="line">│   ├── 类型: int</span><br><span class="line">│   ├── 变量: argc</span><br><span class="line">│   ├── 变量: argv</span><br><span class="line">│   └── 代码位置: 0x400500-0x400600</span><br><span class="line">├── 函数: add</span><br><span class="line">│   ├── 参数: a (int)</span><br><span class="line">│   ├── 参数: b (int) </span><br><span class="line">│   ├── 局部变量: result (int)</span><br><span class="line">│   └── 代码位置: 0x400610-0x400650</span><br><span class="line">└── 全局变量: global_counter</span><br></pre></td></tr></table></figure>
<p>而接下来，我们将学习怎么去理解这些常见的DWARF信息</p>
<h2 id="调试信息条目die">调试信息条目（DIE）</h2>
<h3 id="标签与属性">标签与属性</h3>
<p>DWARF 中的基本描述实体是<strong>调试信息条目</strong>。一个 DIE
包含一个<strong>标签</strong>——用于指定该 DIE
描述的是什么，以及一个<strong>属性列表</strong>——用于填充细节并进一步描述该实体。除了最顶层的
DIE 外，每个 DIE 都包含在或归属于一个父 DIE，并且可能拥有兄弟 DIE 或子
DIE。属性可以包含各种值：常量（例如函数名）、变量（例如函数的起始地址），或者指向另一个
DIE 的引用（例如函数返回值的类型）</p>
<p>例如下图中就展示了一个简单的程序的DWARF信息：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/Gs3CVb6do4cpXUL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最上面的是CU编译单元，它作为DWARF信息的根节点，包含了两个下级DIE。其中一个描述main的信息，如返回类型、行号、函数起始地址…另一个DIE描述的是int类型，通过子程序DIE中的Type属性而被引用。</p>
<h3 id="die类型">DIE类型</h3>
<p>DIE可以分为两种通用类型：</p>
<ul>
<li>一类用来描述数据的DIE</li>
<li>另一类用来描述函数或者其他可执行代码</li>
</ul>
<h2 id="基础类型-数据类型">基础类型-&gt;数据类型</h2>
<p>大多数语言都有复杂的数据类型体系，例如内置数据类型、指针、数据结构、自定义结构等类型。这些基于语言底层设计的主要类型我们称之为<strong>基础类型</strong>，其他的数据类型都由这些基础类型构造而成。</p>
<p>一个具名变量由一个拥有多种属性的 DIE
描述，其中一个属性是对类型定义的引用。下图就描述了一个名为<code>x</code>的整型变量：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/BOJYREo8Zib5m9w.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>int</code>
的基础类型将其描述为一个占用四个字节的有符号二进制整数。用于变量
<code>x</code> 的 <code>DW_TAG_variable</code> DIE
给出了它的名称和一个类型属性，该属性引用了基础类型 DIE。</p>
<p>同样的，DWARF
也可以使用基础类型通过组合来构建其他数据类型定义。一个新类型是作为对另一个类型的补充而创建的。以下面这个<code>int* px</code>的DIE信息为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/7O2vFEV9fsyQbSK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个 DIE 定义了一个指针类型，指明其大小为四个字节，并继而引用了
<code>int</code> 基础类型。</p>
<p>还可以更复杂的，比如加上关键词去限定这个变量的属性和类型，也可以将更多类型的DIE链接在一起以描述更复杂的数据类型，例如<code>const char ** argv</code>的DIE信息如下：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/frAqTD1J3j2dmNK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>总的来说，在DWARF信息中，我们通过组合基本类型的方式来表示程序语言中的数据类型。这样我们无需了解所有程序语言的数据结构，也可以描述出数据类型的信息。</p>
<h2 id="常见类型">常见类型</h2>
<h3 id="数组">数组</h3>
<p>数组类型由<code>DW_TAG_array_type</code>表示，对于<code>int arr[10]</code>，其一般DWARF结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_array_type</span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x00000045</span>&gt;</span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_subrange_type</span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">                        DW_AT_upper_bound           <span class="number">9</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000003e</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_unsigned</span><br><span class="line">                      DW_AT_name                  <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000045</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000004c</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  arr</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000005</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x034040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004040</span><br></pre></td></tr></table></figure>
<p>其中<code>DW_TAG_subrange_type</code>用来存储描述数组维度的范围（下标范围），这里不仅指示了下标的上界<code>DW_AT_upper_bound 9</code>也指明了下标的数据类型<code>DW_AT_type &lt;0x0000003e&gt;</code></p>
<p>我们可以看到左边的<code>&lt;1&gt; &lt;2&gt;</code>的符号，这代表当前条目在条目树结构中的深度。</p>
<p>理解了数据类型的结构分析之后，我们看到变量的定义信息：</p>
<ul>
<li>DW_AT_name：变量名</li>
<li>DW_AT_decl_line：变量的定义行</li>
<li>DW_AT_decl_column：变量的定义列</li>
<li>DW_AT_type：变量定义类型</li>
<li>DW_AT_external：变量的作用域范围（全局符号）</li>
<li>DW_AT_location：变量在内存中的存储位置</li>
</ul>
<p>通过这些信息，我们就可以还原出数组的数据类型、存储结构、以及在源代码中的定义位置等信息</p>
<h3 id="结构类联合体接口">结构、类、联合体、接口</h3>
<p>大多数的语言都支持将各种数据类型的组合到一个结构体中，只不过不同的语言叫法不一样而已，这里的我们就简单的介绍一下结构体和类的标签。</p>
<p>结构体相较于类更加纯粹，它主要对数据进行封装，将不同的数据类型整合成一个大的结构体，在结构体中通过字段对这些数据进行索引，我们可以看下它的DWARF结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_structure_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  age</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000002</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x00000009</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000044</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000b</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000059</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000052</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000059</span>&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000005f</span>&gt;</span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000005f</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000066</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  student</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000002</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x032040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004020</span><br></pre></td></tr></table></figure>
<p>结构体类型由<code>DW_TAG_structure_type</code>进行表示，这里我们定义的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读到以下结构体的属性：</p>
<ul>
<li>DW_TAG_member：结构体的成员</li>
<li>DW_AT_data_member_location：字段在结构体中偏移值，我们可以通过这个值访问结构体中的成员</li>
<li>DW_AT_byte_size：结构体的大小（这里可以看出内存对齐了）</li>
<li>还有典型的一些属性…</li>
</ul>
<p>然后是类的，类相当于结构体的plus版，既可以组合数据类型，也可以包含函数方法，不过对于类的内存分布，我暂时也不是很清楚。我们可以看看类的<code>DWARF</code>信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002a</span>&gt;    DW_TAG_class_type</span><br><span class="line">                      DW_AT_name                  Student</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000007</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  ID</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000005</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000d</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000043</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000008</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000f</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000074</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000051</span>&gt;      DW_TAG_subprogram</span><br><span class="line">                        DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_name                  getID</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000009</span><br><span class="line">                        DW_AT_decl_column           0x0000000d</span><br><span class="line">                        DW_AT_linkage_name          _ZN7Student5getIDEv</span><br><span class="line">                        DW_AT_type                  &lt;0x0000006d&gt;</span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">                        DW_AT_declaration           <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_object_pointer        &lt;0x00000066&gt;</span><br><span class="line">&lt; 3&gt;&lt;0x00000066&gt;        DW_TAG_formal_parameter</span><br><span class="line">                          DW_AT_type                  &lt;0x00000080&gt;</span><br><span class="line">                          DW_AT_artificial            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 1&gt;&lt;0x0000006d&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000074&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x00000079&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000079&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000001</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000080&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x0000002a&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000085&gt;    DW_TAG_const_type</span><br><span class="line">                      DW_AT_type                  &lt;0x00000080&gt;</span><br></pre></td></tr></table></figure>
<p>类的类型由<code>DW_TAG_class_type</code>进行表示，这里我们定义的类是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    private:</span><br><span class="line">        <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读以下类的信息：</p>
<ul>
<li>DW_TAG_subprogram：这里表示这是类的一个方法，之后会详细描述一下这个标签</li>
<li>DW_AT_accessibility：用来指出数据和方法的成员属性（公/私），默认为私有，<code>DW_ACCESS_public</code>为公有</li>
<li>DW_AT_object_pointer：这个是隐含得参数指向this指针参数。</li>
</ul>
<p>类由还有很多标签，但是这里不过多进行讲解。</p>
<h3 id="变量">变量</h3>
<p>变量通常相当简单。它们有一个名称，代表一块可以存储某种值的内存（或寄存器）。变量可以包含的值的种类，以及对其修改方式的限制（例如，是否为
<code>const</code>），都由变量的类型来描述。</p>
<p>区分变量的关键在于其值的存储位置和其作用域。变量的作用域定义了变量在程序中的哪些位置是已知的，并在某种程度上由变量声明的位置决定。在
C
语言中，在函数或块内声明的变量具有函数或块作用域。在函数外声明的变量具有全局或文件作用域。这允许在不同文件中定义同名的变量而不会冲突，也允许不同的函数或编译单元引用同一个变量。</p>
<p>DWARF
将变量分为三类：<strong>常量</strong>、<strong>形式参数</strong>和<strong>变量</strong>。</p>
<ul>
<li><strong>常量</strong>用于那些语言本身包含真正具名常量的情况，例如
Ada 参数。（C 语言本身没有将常量作为语言的一部分。声明一个
<code>const</code>
变量只是表示你不能在没有使用显式类型转换的情况下修改变量。）</li>
<li><strong>形式参数</strong>表示传递给函数的值。我们稍后再讨论这个。</li>
</ul>
<p>大多数变量都有一个<strong>位置属性</strong>，用于描述变量的存储位置。</p>
<ul>
<li>在最简单的情况下，变量存储在内存中并具有<strong>固定地址</strong>。</li>
<li>但是许多变量，例如在 C
函数内声明的变量，是<strong>动态分配</strong>的，定位它们需要进行一些（通常简单的）计算。例如，一个局部变量可能在栈上分配，定位它可能简单到只需给帧指针加上一个固定偏移量。</li>
<li>在其他情况下，变量可能存储在<strong>寄存器</strong>中。</li>
<li>其他变量可能需要更复杂一些的计算来定位数据。作为 C++
类成员的变量可能需要更复杂的计算来确定基类在派生类中的位置。</li>
</ul>
<h3 id="可执行代码段函数与子程序">可执行代码段：函数与子程序</h3>
<p>这里的函数和子程序实际上是同一个东西，硬要细分的话，函数是有返回值的，而子程序没有（我们更多是利用子程序的副作用）。我们可以看一下函数会包含的DWARF信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000065</span>&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_name                  hello</span><br><span class="line">                      DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.c</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br><span class="line">                      DW_AT_decl_column           0x00000005</span><br><span class="line">                      DW_AT_prototyped            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                      DW_AT_low_pc                0x00001129</span><br><span class="line">                      DW_AT_high_pc               &lt;offset-from-lowpc&gt; 24 &lt;highpc: 0x00001141&gt;</span><br><span class="line">                      DW_AT_frame_base            len 0x0001: 0x9c:</span><br><span class="line">                          DW_OP_call_frame_cfa</span><br><span class="line">                      DW_AT_call_all_calls        <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 2&gt;&lt;0x00000083&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  x</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x0000000f</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x916c:</span><br><span class="line">                            DW_OP_fbreg -20</span><br><span class="line">&lt; 2&gt;&lt;0x0000008e&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  y</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x00000016</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x9168:</span><br><span class="line">                            DW_OP_fbreg -24</span><br></pre></td></tr></table></figure>
<p>首先我们可以看到包含源代码位置信息的三元组（文件、行、列），然后是函数的高低内存范围，一般情概况下，我们默认函数的低内存地址（起始地址）为函数的入口。函数的返回类型，由类型属性指定。</p>
<p>这里需要注意的是<code>DW_OP_call_frame_cfa</code>指定的CFA<code>0x9c</code>。CFA就是函数执行时，其调用者的栈帧的栈顶位置，标志着一个函数栈帧的开始边界。以下图结构为例：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（高地址）</span><br><span class="line">+----------------------+</span><br><span class="line">| ...                  |</span><br><span class="line">| main 的局部变量       | &lt;--- main 函数的栈帧</span><br><span class="line">+----------------------+</span><br><span class="line">| 返回地址              | &lt;--- [!] hello 函数的 CFA 指向这里</span><br><span class="line">+----------------------+------ hello 函数栈帧的“边界”</span><br><span class="line">| 保存的 RBP (帧指针)   | &lt;--- 帧基址 (Frame Base) 常常指向这里</span><br><span class="line">+----------------------+</span><br><span class="line">| hello 的局部变量      |</span><br><span class="line">| ...                  |</span><br><span class="line">|  可能还有保存的寄存器  |</span><br><span class="line">+----------------------+ &lt;--- 当前 RSP 指向这里（栈顶）</span><br><span class="line">（低地址）</span><br></pre></td></tr></table></figure>
<p>在我们的示例中，DWARF信息指出<code>DW_AT_frame_base : DW_OP_call_frame_cfa</code>，所以这里我们的栈基址等于CFA值。基于栈基址，我们就可以对被调用栈帧中的变量进行访问。我们看到<code>DW_AT_location</code>的属性下，通常有<code>DW_OP_fbreg - 偏移值</code>的形式来计算参数在栈帧上的位置。</p>
<p>DWARF不定义函数的调用约定，这一部分有应用程序二进制接口规范确定（ABI）</p>
<h3 id="编译单元">编译单元</h3>
<p>大多数的程序室友多个文件构成的，每个文件会被独立编译，然后与系统库链接成最终的程序，DWARF将每个独立编译的源文件称为一个编译单元</p>
<p>每个编译单元的DWARF数据，都会从一个编译单元调试信息项开始。该调试信息项包含编译过程中的通用信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">0</span>&gt;&lt;<span class="number">0x0000000c</span>&gt;  DW_TAG_compile_unit</span><br><span class="line">                    DW_AT_producer              GNU C17 <span class="number">13.3</span>.<span class="number">0</span> -mtune=generic -march=x86<span class="number">-64</span> -g -O0 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection</span><br><span class="line">                    DW_AT_language              DW_LANG_C11</span><br><span class="line">                    DW_AT_name                  test.c</span><br><span class="line">                    DW_AT_comp_dir              /home/ylin/Program/test</span><br><span class="line">                    DW_AT_low_pc                <span class="number">0x00001129</span></span><br><span class="line">                    DW_AT_high_pc               &lt;offset-from-lowpc&gt; <span class="number">61</span> &lt;highpc: <span class="number">0x00001166</span>&gt;</span><br><span class="line">                    DW_AT_stmt_list             <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>包括：</p>
<ul>
<li>编译器和编译参数</li>
<li>源文件的目录路径和文件名称</li>
<li>编译单元在内存中的起始结束地址（如果编译单元在内存中是连续的）</li>
<li>编译单元占用内存的地址列表（如果编译单元在内存中非连续）</li>
<li>指向调试器行号的指针(DW_AT_stmt_list)</li>
</ul>
<p>编译单元调试信息项是所有该编译单元调试信息的父项。一般情况下，调试信息会先描述数据类型，接着是全局数据，然后再是子函数。</p>
<p>至此基本的DWARF信息就介绍到这里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/100-%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/100-%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">100:感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 20:18:05" itemprop="dateCreated datePublished" datetime="2025-11-22T20:18:05+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:19" itemprop="dateModified" datetime="2025-11-29T13:49:19+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>也是好不容易水到第100篇了，我本来准备了好多台词的，但是不知道说什么。我就记录一下我的几个感悟吧</p>
<h3 id="学会放弃">学会放弃</h3>
<p>刚开始觉得只要努力学就会有所收获吧，如果没学会就是自己比较笨什么的。但事实不是这样的，认知一个领域的过程是循序渐进的，就像游戏里的科技树一样，解锁一个科技需要一大堆前置科技。有时候一些知识也是这样，所以一开始学不会一些东西很正常，这个时候应该先放一放，去试试其他的方向，或者是从前置的内容开始学。</p>
<p>关于这一点我的感受就很明显吧，我每次遇到学不会的东西，就会放弃然后去学其他的东西。但是过一段时间之后再来看这些内容反而有一种水到渠成的感觉，我猜测一个是知识体系上的补齐，还有一个是你对这个领域的认知能力也在慢慢变强。你能对一些内容做出自己的解释，能说服自己我认为是理解一个知识的开始吧。不管你的猜想是不是对的，只要他能补齐你对这方面的认识，你就可以视作自己理解了。之后随着需求和认知的提升，再一步步完善自己对这方面的理解吧。</p>
<p>我发现生活中也有很多这样的事情，给你一种无从下手或者无能为力的感觉。如果实在不行就放弃吧，可以之后再试试，先把其他的事情做好，也许很多事情时间会给出答案，因为我们每天都在慢慢长大。只要不放弃从头再来的决心，迟早有一天也能找到自己的答案。</p>
<h3 id="主动学习">主动学习</h3>
<p>大家都在学习凭什么，也不存在谁比谁笨，为什么有的人能学会有的人不能呢？我认为这不是努不努力的事情，大家回宿舍都是打游戏，如果能认真学下去，活该他学的好。我觉得更多是对于这个知识的态度吧，有的人是被动的接受的，有的人是主动的接受的。主动接受的话你就会发现很多问题啥的，就是你的脑子里的东西和答案不一样，或者你脑子里没有这个东西。在这个不断碰撞思考的过程中，你的知识体系会被答案说服或者补全，这样你的认知体系就会慢慢完善，感觉这个就是高中老师说的框架/查漏补缺，这个就是主动学习。但是大多数人就是书上讲得是啥就是啥，老师说啥就是啥，一上来就记住正确答案，对知识很内容知其然不知其所以然，这种效率就很差。中国传统的应试教育就是这样的，所以大家都是这样的，我也是这样的。</p>
<p>这也是为什么比起看网课我更喜欢看书，看网课的时候，老师叽里咕噜讲个不停，你很难有自己思考的时间，更别说有时候发呆什么的。但是看书不一样，你不懂得时候可以对着书上得那句话发呆，等你发完呆它还在那里，你就有充分得时间去理解它，或者再来一遍。就是这个时候你的大脑是属于你自己的，你的想法不是跟着别人走的，更自由一点。这样你就能做出更多自己的思考。</p>
<p>我知道这样子很不好，但是有时候动脑子真的好累，偶尔主动学习一些重要的东西也还行。我的话有时候突然想做项目或者刷视频看到什么好帅的东西，我会迫不及待的去了解一下。主要是对游戏方面感兴趣一点</p>
<h3 id="要有耐心">要有耐心</h3>
<p>就是电视上和老师经常说的要坐的住冷板凳吧，有时候学一些东西确实挺牢的，就是很无聊，知识从脑袋里滑走了。这个时候就是看你有没有耐心了，感觉这个和我第一条说的是相反的，按道理这种情况是要放弃的，但是有时候就是不太想放弃，你就需要耐心一点。所以这么看来放弃是一件很理性的事情，坚持反而是一件很感性的事情。回到正题，我想说的是，人生的常态就是失败和无聊，但是不耐心去做一件事的话就会错过很多东西。什么时候放弃，什么时候坚持是一件很哲学的问题吧。我到这里也不知道说什么好了。</p>
<p>今天就暂时写到这些吧，希望之后的时间也能继续加油。现在虽然学了很多东西，但是没办法把知识串联在一起，也有点迷茫。有时候分析一些问题的时候，反而会因为知道的太多而被绕进去。就像之前不知道从哪里看到的三大境界：</p>
<ul>
<li>看山是山 看水是水</li>
<li>看山不是山 看水不是水</li>
<li>看山还是山 看水还是水</li>
</ul>
<p>我现在可能介于一二之间吧，很难受，技术不到家，看很多东西都是残破不堪的，漏洞百出，我自己也知道。希望以后能慢慢解决这个这个问题吧。还有就是我现在也遇到了一些生活中难以解决的问题，我也不知道怎么做，在迷茫的时候还是要坚定的提升自己，也许以后时间会给出答案吧。之后也要继续加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">241k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:37</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
