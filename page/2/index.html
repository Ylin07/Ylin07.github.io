<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/01/102-%E6%97%A5%E5%90%8E%E5%AE%89%E6%8E%92/" class="post-title-link" itemprop="url">102:日后安排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-01 12:01:20 / 修改时间：12:36:00" itemprop="dateCreated datePublished" datetime="2025-12-01T12:01:20+08:00">2025-12-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>795</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近思绪有点乱，感觉要做的事情很多，但是不知道何从下手，所以我要从头缕一缕现在的问题。</p>
<p>首先是分析一下现阶段我要做的事情，按优先级进行分类：</p>
<ul>
<li>课程任务：（这几门课是这个学期的大头）
<ul>
<li><strong>离散数学</strong>：这个课我现在最大的问题就是没有明确的学习路线（对着书硬啃？找个网课学？）</li>
<li><strong>概率论</strong>：这个课我的进度很慢，但是有一高数的课程可以跟着学习，可以从现在开始每天学一点</li>
<li>操作系统：这个课我学的还行，但是我对自己有一定的要求，不想只是简单学会</li>
<li><strong>计算机组成原理</strong>：这个课的应试考法我也不是很熟悉，对于数据的部分不是很熟悉，其他的还可以，但是我对自己也有一定的有要求</li>
<li>数据结构：这门课学的还行，但是不熟悉应试的考法</li>
<li>密码学：目前不清楚考试考察的方向，需要花时间巩固</li>
<li>Python：现在要开始准备大作业</li>
<li><strong>Java</strong>：需要对着PPT再进一步学习，需要准备大作业</li>
<li>毛思想：需要了解一下考什么，和题型。考前需要花时间学习一下</li>
</ul></li>
<li>课外任务：
<ul>
<li><strong>科研任务</strong>：科研训练从和开始入手，怎么去查看论文，怎么去找创新点，怎么去构建项目。</li>
<li>个人任务：
<ul>
<li>锻炼身体：需要加强身体的锻炼和饮食的均衡</li>
<li>练习英语：提升英语水平</li>
<li>CTF二进制安全竞技水平</li>
<li>学习新知识</li>
<li>看书阅读</li>
</ul></li>
</ul></li>
</ul>
<p>这里加粗的部分是需要着重注意的地方，那么我该怎么安排呢？</p>
<h3 id="生活上的安排">生活上的安排</h3>
<p>首先是睡眠，每天十二点必须上床，手机最多玩到十二点半就要睡觉。有早八就七点一十起床，没早八就八点起床。周日可以休息久一点</p>
<p>每天早上至少喝一瓶牛奶，还有早餐。在寝室的期间要喝热水。平时尽量不喝奶茶喝其他饮料，也要控制自己的饮食，不能像以前一样想怎么吃就怎么吃。</p>
<p>平时要坚持锻炼，一周至少锻炼4次，两次耐力，两次力量。没事的时候可以在寝室举哑铃</p>
<p>每天要积极一点，心情不好就出去走一走，要开心。</p>
<p>节假日和周六晚上可以玩久一点游戏，平时尽量少玩一点。要珍惜现在的时间。</p>
<h3 id="学习上的安排">学习上的安排</h3>
<p>除掉周日，单日学概率论，双日学离散数学，每天至少完成一个章节的学习。在什么课上学什么的知识，不能拆东墙补西墙。</p>
<p>这周之内要开始科研训练的内容，首先给出自己一个项目的框架，可行demo</p>
<p>课余的时间学什么由自己决定，优先课程的任务。</p>
<h3 id="感情上的安排">感情上的安排</h3>
<p>别想太多 要接受分开的事实 继续走下去</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/24/101-Dwarf%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">101:DWADRF信息解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-24 10:26:27" itemprop="dateCreated datePublished" datetime="2025-11-24T10:26:27+08:00">2025-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:22" itemprop="dateModified" datetime="2025-11-29T13:49:22+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上个学期也尝试了解过这些，但是那个时候还没有接触编译链接，对DWARF信息的理解不够深刻。最近有计划了解一下调试器的原理，所以重新捡起来好好学一遍。</p>
<p>我参考的教程是DWARF的官方介绍文档<a
target="_blank" rel="noopener" href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf">Debugging
using DWARF</a>，作为对其的简单了解</p>
<h2 id="dwarf概述">DWARF概述</h2>
<p>一开始我并不知道怎么说明这一部分，AI给了我一个很好的比方。如果说程序是一个设计图纸（源代码），它事无巨细的包含一个城市的所有信息，那么编译器就是一个工程师，他根据设计图纸将建造出城市（可执行文件）。而DWARF信息，就相当于这个城市的地图，它告诉你每条街道（机器指令，数据信息）对应设计图中的哪个位置（源代码）。而调试器就是一个导游，它根据这个地图带你去任何地方。</p>
<p>现代的编程语言大多是块状结构的，一个实体往往包含着更多的实体，每个实体中可能都有若干个数据和函数定义，那么在这个实体中，就产生了词法的作用域。这个定义仅在被定义的作用域中有意义。</p>
<p>我们可以用一个常见的文件结构来描述这种特征：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源文件</span><br><span class="line">├── 函数A</span><br><span class="line">│   ├── 变量x</span><br><span class="line">│   ├── 语句块1</span><br><span class="line">│   │   ├── 变量y (只在当前块内有效)</span><br><span class="line">│   │   ├── 函数C</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── 函数B</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure>
<p>对于数据和函数一类的内容，我们按照编译链接的习惯，称之为符号。一般情况下，一个符号的作用域属于当前块（也可以通过关键词指定作用域范围）。所以我们要查找特定符号的定义，先从当前作用域中查找定义，然后从连续的外层定义域中依次查找，直到找到该符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var;          <span class="comment">// 全局作用域</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">()</span> &#123;     <span class="comment">// 函数作用域</span></span><br><span class="line">    <span class="type">int</span> local_var;       <span class="comment">// 函数内有效</span></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="type">int</span> block_var;   <span class="comment">// 只在if块内有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block_var 在这里结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在编译链接的过程中，这些信息会被抛弃或者是简化。因为编译器只在乎对内存和寄存器的管理和操作，所以我们很难根据机器指令去恢复这些信息。</p>
<p>所以这里我们就需要DWARF信息来保存这些信息，DWARF和程序语义一样，通过树状结构来组织信息。DWARF中的所有描述性实体都包含在一个父条目中，且实体中还可以包含更多节点，这些节点可能表示类型，变量或是函数…一个常见的结构可以是下面这样的：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译单元 (CU)</span><br><span class="line">├── 函数: main</span><br><span class="line">│   ├── 类型: int</span><br><span class="line">│   ├── 变量: argc</span><br><span class="line">│   ├── 变量: argv</span><br><span class="line">│   └── 代码位置: 0x400500-0x400600</span><br><span class="line">├── 函数: add</span><br><span class="line">│   ├── 参数: a (int)</span><br><span class="line">│   ├── 参数: b (int) </span><br><span class="line">│   ├── 局部变量: result (int)</span><br><span class="line">│   └── 代码位置: 0x400610-0x400650</span><br><span class="line">└── 全局变量: global_counter</span><br></pre></td></tr></table></figure>
<p>而接下来，我们将学习怎么去理解这些常见的DWARF信息</p>
<h2 id="调试信息条目die">调试信息条目（DIE）</h2>
<h3 id="标签与属性">标签与属性</h3>
<p>DWARF 中的基本描述实体是<strong>调试信息条目</strong>。一个 DIE
包含一个<strong>标签</strong>——用于指定该 DIE
描述的是什么，以及一个<strong>属性列表</strong>——用于填充细节并进一步描述该实体。除了最顶层的
DIE 外，每个 DIE 都包含在或归属于一个父 DIE，并且可能拥有兄弟 DIE 或子
DIE。属性可以包含各种值：常量（例如函数名）、变量（例如函数的起始地址），或者指向另一个
DIE 的引用（例如函数返回值的类型）</p>
<p>例如下图中就展示了一个简单的程序的DWARF信息：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/Gs3CVb6do4cpXUL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最上面的是CU编译单元，它作为DWARF信息的根节点，包含了两个下级DIE。其中一个描述main的信息，如返回类型、行号、函数起始地址…另一个DIE描述的是int类型，通过子程序DIE中的Type属性而被引用。</p>
<h3 id="die类型">DIE类型</h3>
<p>DIE可以分为两种通用类型：</p>
<ul>
<li>一类用来描述数据的DIE</li>
<li>另一类用来描述函数或者其他可执行代码</li>
</ul>
<h2 id="基础类型-数据类型">基础类型-&gt;数据类型</h2>
<p>大多数语言都有复杂的数据类型体系，例如内置数据类型、指针、数据结构、自定义结构等类型。这些基于语言底层设计的主要类型我们称之为<strong>基础类型</strong>，其他的数据类型都由这些基础类型构造而成。</p>
<p>一个具名变量由一个拥有多种属性的 DIE
描述，其中一个属性是对类型定义的引用。下图就描述了一个名为<code>x</code>的整型变量：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/BOJYREo8Zib5m9w.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>int</code>
的基础类型将其描述为一个占用四个字节的有符号二进制整数。用于变量
<code>x</code> 的 <code>DW_TAG_variable</code> DIE
给出了它的名称和一个类型属性，该属性引用了基础类型 DIE。</p>
<p>同样的，DWARF
也可以使用基础类型通过组合来构建其他数据类型定义。一个新类型是作为对另一个类型的补充而创建的。以下面这个<code>int* px</code>的DIE信息为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/7O2vFEV9fsyQbSK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个 DIE 定义了一个指针类型，指明其大小为四个字节，并继而引用了
<code>int</code> 基础类型。</p>
<p>还可以更复杂的，比如加上关键词去限定这个变量的属性和类型，也可以将更多类型的DIE链接在一起以描述更复杂的数据类型，例如<code>const char ** argv</code>的DIE信息如下：</p>
<figure>
<img src="https://s2.loli.net/2025/11/19/frAqTD1J3j2dmNK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>总的来说，在DWARF信息中，我们通过组合基本类型的方式来表示程序语言中的数据类型。这样我们无需了解所有程序语言的数据结构，也可以描述出数据类型的信息。</p>
<h2 id="常见类型">常见类型</h2>
<h3 id="数组">数组</h3>
<p>数组类型由<code>DW_TAG_array_type</code>表示，对于<code>int arr[10]</code>，其一般DWARF结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_array_type</span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x00000045</span>&gt;</span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_subrange_type</span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000003e</span>&gt;</span><br><span class="line">                        DW_AT_upper_bound           <span class="number">9</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000003e</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_unsigned</span><br><span class="line">                      DW_AT_name                  <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000045</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000004c</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  arr</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000005</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x034040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004040</span><br></pre></td></tr></table></figure>
<p>其中<code>DW_TAG_subrange_type</code>用来存储描述数组维度的范围（下标范围），这里不仅指示了下标的上界<code>DW_AT_upper_bound 9</code>也指明了下标的数据类型<code>DW_AT_type &lt;0x0000003e&gt;</code></p>
<p>我们可以看到左边的<code>&lt;1&gt; &lt;2&gt;</code>的符号，这代表当前条目在条目树结构中的深度。</p>
<p>理解了数据类型的结构分析之后，我们看到变量的定义信息：</p>
<ul>
<li>DW_AT_name：变量名</li>
<li>DW_AT_decl_line：变量的定义行</li>
<li>DW_AT_decl_column：变量的定义列</li>
<li>DW_AT_type：变量定义类型</li>
<li>DW_AT_external：变量的作用域范围（全局符号）</li>
<li>DW_AT_location：变量在内存中的存储位置</li>
</ul>
<p>通过这些信息，我们就可以还原出数组的数据类型、存储结构、以及在源代码中的定义位置等信息</p>
<h3 id="结构类联合体接口">结构、类、联合体、接口</h3>
<p>大多数的语言都支持将各种数据类型的组合到一个结构体中，只不过不同的语言叫法不一样而已，这里的我们就简单的介绍一下结构体和类的标签。</p>
<p>结构体相较于类更加纯粹，它主要对数据进行封装，将不同的数据类型整合成一个大的结构体，在结构体中通过字段对这些数据进行索引，我们可以看下它的DWARF结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002e</span>&gt;    DW_TAG_structure_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  age</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000002</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x00000009</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000052</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000044</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000b</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000059</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000052</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000059</span>&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000008</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000005f</span>&gt;</span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000005f</span>&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000001</span></span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000066</span>&gt;    DW_TAG_variable</span><br><span class="line">                      DW_AT_name                  student</span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/./test.c</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000004</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000002</span></span><br><span class="line">                      DW_AT_type                  &lt;<span class="number">0x0000002e</span>&gt;</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_location              len 0x0009: 0x032040000000000000:</span><br><span class="line">                          DW_OP_addr 0x00004020</span><br></pre></td></tr></table></figure>
<p>结构体类型由<code>DW_TAG_structure_type</code>进行表示，这里我们定义的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读到以下结构体的属性：</p>
<ul>
<li>DW_TAG_member：结构体的成员</li>
<li>DW_AT_data_member_location：字段在结构体中偏移值，我们可以通过这个值访问结构体中的成员</li>
<li>DW_AT_byte_size：结构体的大小（这里可以看出内存对齐了）</li>
<li>还有典型的一些属性…</li>
</ul>
<p>然后是类的，类相当于结构体的plus版，既可以组合数据类型，也可以包含函数方法，不过对于类的内存分布，我暂时也不是很清楚。我们可以看看类的<code>DWARF</code>信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x0000002a</span>&gt;    DW_TAG_class_type</span><br><span class="line">                      DW_AT_name                  Student</span><br><span class="line">                      DW_AT_byte_size             <span class="number">0x00000010</span></span><br><span class="line">                      DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                      DW_AT_decl_line             <span class="number">0x00000003</span></span><br><span class="line">                      DW_AT_decl_column           <span class="number">0x00000007</span></span><br><span class="line">                      DW_AT_sibling               &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000037</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  ID</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000005</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000d</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x0000006d</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">0</span></span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000043</span>&gt;      DW_TAG_member</span><br><span class="line">                        DW_AT_name                  name</span><br><span class="line">                        DW_AT_decl_file             <span class="number">0x00000001</span> /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             <span class="number">0x00000008</span></span><br><span class="line">                        DW_AT_decl_column           <span class="number">0x0000000f</span></span><br><span class="line">                        DW_AT_type                  &lt;<span class="number">0x00000074</span>&gt;</span><br><span class="line">                        DW_AT_data_member_location  <span class="number">8</span></span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">&lt; <span class="number">2</span>&gt;&lt;<span class="number">0x00000051</span>&gt;      DW_TAG_subprogram</span><br><span class="line">                        DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_name                  getID</span><br><span class="line">                        DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.cpp</span><br><span class="line">                        DW_AT_decl_line             0x00000009</span><br><span class="line">                        DW_AT_decl_column           0x0000000d</span><br><span class="line">                        DW_AT_linkage_name          _ZN7Student5getIDEv</span><br><span class="line">                        DW_AT_type                  &lt;0x0000006d&gt;</span><br><span class="line">                        DW_AT_accessibility         DW_ACCESS_public</span><br><span class="line">                        DW_AT_declaration           <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                        DW_AT_object_pointer        &lt;0x00000066&gt;</span><br><span class="line">&lt; 3&gt;&lt;0x00000066&gt;        DW_TAG_formal_parameter</span><br><span class="line">                          DW_AT_type                  &lt;0x00000080&gt;</span><br><span class="line">                          DW_AT_artificial            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 1&gt;&lt;0x0000006d&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000004</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed</span><br><span class="line">                      DW_AT_name                  <span class="type">int</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000074&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x00000079&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000079&gt;    DW_TAG_base_type</span><br><span class="line">                      DW_AT_byte_size             0x00000001</span><br><span class="line">                      DW_AT_encoding              DW_ATE_signed_char</span><br><span class="line">                      DW_AT_name                  <span class="type">char</span></span><br><span class="line">&lt; 1&gt;&lt;0x00000080&gt;    DW_TAG_pointer_type</span><br><span class="line">                      DW_AT_byte_size             0x00000008</span><br><span class="line">                      DW_AT_type                  &lt;0x0000002a&gt;</span><br><span class="line">&lt; 1&gt;&lt;0x00000085&gt;    DW_TAG_const_type</span><br><span class="line">                      DW_AT_type                  &lt;0x00000080&gt;</span><br></pre></td></tr></table></figure>
<p>类的类型由<code>DW_TAG_class_type</code>进行表示，这里我们定义的类是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    private:</span><br><span class="line">        <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以阅读以下类的信息：</p>
<ul>
<li>DW_TAG_subprogram：这里表示这是类的一个方法，之后会详细描述一下这个标签</li>
<li>DW_AT_accessibility：用来指出数据和方法的成员属性（公/私），默认为私有，<code>DW_ACCESS_public</code>为公有</li>
<li>DW_AT_object_pointer：这个是隐含得参数指向this指针参数。</li>
</ul>
<p>类由还有很多标签，但是这里不过多进行讲解。</p>
<h3 id="变量">变量</h3>
<p>变量通常相当简单。它们有一个名称，代表一块可以存储某种值的内存（或寄存器）。变量可以包含的值的种类，以及对其修改方式的限制（例如，是否为
<code>const</code>），都由变量的类型来描述。</p>
<p>区分变量的关键在于其值的存储位置和其作用域。变量的作用域定义了变量在程序中的哪些位置是已知的，并在某种程度上由变量声明的位置决定。在
C
语言中，在函数或块内声明的变量具有函数或块作用域。在函数外声明的变量具有全局或文件作用域。这允许在不同文件中定义同名的变量而不会冲突，也允许不同的函数或编译单元引用同一个变量。</p>
<p>DWARF
将变量分为三类：<strong>常量</strong>、<strong>形式参数</strong>和<strong>变量</strong>。</p>
<ul>
<li><strong>常量</strong>用于那些语言本身包含真正具名常量的情况，例如
Ada 参数。（C 语言本身没有将常量作为语言的一部分。声明一个
<code>const</code>
变量只是表示你不能在没有使用显式类型转换的情况下修改变量。）</li>
<li><strong>形式参数</strong>表示传递给函数的值。我们稍后再讨论这个。</li>
</ul>
<p>大多数变量都有一个<strong>位置属性</strong>，用于描述变量的存储位置。</p>
<ul>
<li>在最简单的情况下，变量存储在内存中并具有<strong>固定地址</strong>。</li>
<li>但是许多变量，例如在 C
函数内声明的变量，是<strong>动态分配</strong>的，定位它们需要进行一些（通常简单的）计算。例如，一个局部变量可能在栈上分配，定位它可能简单到只需给帧指针加上一个固定偏移量。</li>
<li>在其他情况下，变量可能存储在<strong>寄存器</strong>中。</li>
<li>其他变量可能需要更复杂一些的计算来定位数据。作为 C++
类成员的变量可能需要更复杂的计算来确定基类在派生类中的位置。</li>
</ul>
<h3 id="可执行代码段函数与子程序">可执行代码段：函数与子程序</h3>
<p>这里的函数和子程序实际上是同一个东西，硬要细分的话，函数是有返回值的，而子程序没有（我们更多是利用子程序的副作用）。我们可以看一下函数会包含的DWARF信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">1</span>&gt;&lt;<span class="number">0x00000065</span>&gt;    DW_TAG_subprogram</span><br><span class="line">                      DW_AT_external              <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_name                  hello</span><br><span class="line">                      DW_AT_decl_file             0x00000001 /home/ylin/Program/test/test.c</span><br><span class="line">                      DW_AT_decl_line             0x00000001</span><br><span class="line">                      DW_AT_decl_column           0x00000005</span><br><span class="line">                      DW_AT_prototyped            <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">                      DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                      DW_AT_low_pc                0x00001129</span><br><span class="line">                      DW_AT_high_pc               &lt;offset-from-lowpc&gt; 24 &lt;highpc: 0x00001141&gt;</span><br><span class="line">                      DW_AT_frame_base            len 0x0001: 0x9c:</span><br><span class="line">                          DW_OP_call_frame_cfa</span><br><span class="line">                      DW_AT_call_all_calls        <span class="title function_">yes</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&lt; 2&gt;&lt;0x00000083&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  x</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x0000000f</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x916c:</span><br><span class="line">                            DW_OP_fbreg -20</span><br><span class="line">&lt; 2&gt;&lt;0x0000008e&gt;      DW_TAG_formal_parameter</span><br><span class="line">                        DW_AT_name                  y</span><br><span class="line">                        DW_AT_decl_file             0x00000001</span><br><span class="line">                        DW_AT_decl_line             0x00000001</span><br><span class="line">                        DW_AT_decl_column           0x00000016</span><br><span class="line">                        DW_AT_type                  &lt;0x0000005e&gt;</span><br><span class="line">                        DW_AT_location              len 0x0002: 0x9168:</span><br><span class="line">                            DW_OP_fbreg -24</span><br></pre></td></tr></table></figure>
<p>首先我们可以看到包含源代码位置信息的三元组（文件、行、列），然后是函数的高低内存范围，一般情概况下，我们默认函数的低内存地址（起始地址）为函数的入口。函数的返回类型，由类型属性指定。</p>
<p>这里需要注意的是<code>DW_OP_call_frame_cfa</code>指定的CFA<code>0x9c</code>。CFA就是函数执行时，其调用者的栈帧的栈顶位置，标志着一个函数栈帧的开始边界。以下图结构为例：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（高地址）</span><br><span class="line">+----------------------+</span><br><span class="line">| ...                  |</span><br><span class="line">| main 的局部变量       | &lt;--- main 函数的栈帧</span><br><span class="line">+----------------------+</span><br><span class="line">| 返回地址              | &lt;--- [!] hello 函数的 CFA 指向这里</span><br><span class="line">+----------------------+------ hello 函数栈帧的“边界”</span><br><span class="line">| 保存的 RBP (帧指针)   | &lt;--- 帧基址 (Frame Base) 常常指向这里</span><br><span class="line">+----------------------+</span><br><span class="line">| hello 的局部变量      |</span><br><span class="line">| ...                  |</span><br><span class="line">|  可能还有保存的寄存器  |</span><br><span class="line">+----------------------+ &lt;--- 当前 RSP 指向这里（栈顶）</span><br><span class="line">（低地址）</span><br></pre></td></tr></table></figure>
<p>在我们的示例中，DWARF信息指出<code>DW_AT_frame_base : DW_OP_call_frame_cfa</code>，所以这里我们的栈基址等于CFA值。基于栈基址，我们就可以对被调用栈帧中的变量进行访问。我们看到<code>DW_AT_location</code>的属性下，通常有<code>DW_OP_fbreg - 偏移值</code>的形式来计算参数在栈帧上的位置。</p>
<p>DWARF不定义函数的调用约定，这一部分有应用程序二进制接口规范确定（ABI）</p>
<h3 id="编译单元">编译单元</h3>
<p>大多数的程序室友多个文件构成的，每个文件会被独立编译，然后与系统库链接成最终的程序，DWARF将每个独立编译的源文件称为一个编译单元</p>
<p>每个编译单元的DWARF数据，都会从一个编译单元调试信息项开始。该调试信息项包含编译过程中的通用信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="number">0</span>&gt;&lt;<span class="number">0x0000000c</span>&gt;  DW_TAG_compile_unit</span><br><span class="line">                    DW_AT_producer              GNU C17 <span class="number">13.3</span>.<span class="number">0</span> -mtune=generic -march=x86<span class="number">-64</span> -g -O0 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection</span><br><span class="line">                    DW_AT_language              DW_LANG_C11</span><br><span class="line">                    DW_AT_name                  test.c</span><br><span class="line">                    DW_AT_comp_dir              /home/ylin/Program/test</span><br><span class="line">                    DW_AT_low_pc                <span class="number">0x00001129</span></span><br><span class="line">                    DW_AT_high_pc               &lt;offset-from-lowpc&gt; <span class="number">61</span> &lt;highpc: <span class="number">0x00001166</span>&gt;</span><br><span class="line">                    DW_AT_stmt_list             <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>包括：</p>
<ul>
<li>编译器和编译参数</li>
<li>源文件的目录路径和文件名称</li>
<li>编译单元在内存中的起始结束地址（如果编译单元在内存中是连续的）</li>
<li>编译单元占用内存的地址列表（如果编译单元在内存中非连续）</li>
<li>指向调试器行号的指针(DW_AT_stmt_list)</li>
</ul>
<p>编译单元调试信息项是所有该编译单元调试信息的父项。一般情况下，调试信息会先描述数据类型，接着是全局数据，然后再是子函数。</p>
<p>至此基本的DWARF信息就介绍到这里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/100-%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/100-%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">100:感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 20:18:05" itemprop="dateCreated datePublished" datetime="2025-11-22T20:18:05+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:19" itemprop="dateModified" datetime="2025-11-29T13:49:19+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>也是好不容易水到第100篇了，我本来准备了好多台词的，但是不知道说什么。我就记录一下我的几个感悟吧</p>
<h3 id="学会放弃">学会放弃</h3>
<p>刚开始觉得只要努力学就会有所收获吧，如果没学会就是自己比较笨什么的。但事实不是这样的，认知一个领域的过程是循序渐进的，就像游戏里的科技树一样，解锁一个科技需要一大堆前置科技。有时候一些知识也是这样，所以一开始学不会一些东西很正常，这个时候应该先放一放，去试试其他的方向，或者是从前置的内容开始学。</p>
<p>关于这一点我的感受就很明显吧，我每次遇到学不会的东西，就会放弃然后去学其他的东西。但是过一段时间之后再来看这些内容反而有一种水到渠成的感觉，我猜测一个是知识体系上的补齐，还有一个是你对这个领域的认知能力也在慢慢变强。你能对一些内容做出自己的解释，能说服自己我认为是理解一个知识的开始吧。不管你的猜想是不是对的，只要他能补齐你对这方面的认识，你就可以视作自己理解了。之后随着需求和认知的提升，再一步步完善自己对这方面的理解吧。</p>
<p>我发现生活中也有很多这样的事情，给你一种无从下手或者无能为力的感觉。如果实在不行就放弃吧，可以之后再试试，先把其他的事情做好，也许很多事情时间会给出答案，因为我们每天都在慢慢长大。只要不放弃从头再来的决心，迟早有一天也能找到自己的答案。</p>
<h3 id="主动学习">主动学习</h3>
<p>大家都在学习凭什么，也不存在谁比谁笨，为什么有的人能学会有的人不能呢？我认为这不是努不努力的事情，大家回宿舍都是打游戏，如果能认真学下去，活该他学的好。我觉得更多是对于这个知识的态度吧，有的人是被动的接受的，有的人是主动的接受的。主动接受的话你就会发现很多问题啥的，就是你的脑子里的东西和答案不一样，或者你脑子里没有这个东西。在这个不断碰撞思考的过程中，你的知识体系会被答案说服或者补全，这样你的认知体系就会慢慢完善，感觉这个就是高中老师说的框架/查漏补缺，这个就是主动学习。但是大多数人就是书上讲得是啥就是啥，老师说啥就是啥，一上来就记住正确答案，对知识很内容知其然不知其所以然，这种效率就很差。中国传统的应试教育就是这样的，所以大家都是这样的，我也是这样的。</p>
<p>这也是为什么比起看网课我更喜欢看书，看网课的时候，老师叽里咕噜讲个不停，你很难有自己思考的时间，更别说有时候发呆什么的。但是看书不一样，你不懂得时候可以对着书上得那句话发呆，等你发完呆它还在那里，你就有充分得时间去理解它，或者再来一遍。就是这个时候你的大脑是属于你自己的，你的想法不是跟着别人走的，更自由一点。这样你就能做出更多自己的思考。</p>
<p>我知道这样子很不好，但是有时候动脑子真的好累，偶尔主动学习一些重要的东西也还行。我的话有时候突然想做项目或者刷视频看到什么好帅的东西，我会迫不及待的去了解一下。主要是对游戏方面感兴趣一点</p>
<h3 id="要有耐心">要有耐心</h3>
<p>就是电视上和老师经常说的要坐的住冷板凳吧，有时候学一些东西确实挺牢的，就是很无聊，知识从脑袋里滑走了。这个时候就是看你有没有耐心了，感觉这个和我第一条说的是相反的，按道理这种情况是要放弃的，但是有时候就是不太想放弃，你就需要耐心一点。所以这么看来放弃是一件很理性的事情，坚持反而是一件很感性的事情。回到正题，我想说的是，人生的常态就是失败和无聊，但是不耐心去做一件事的话就会错过很多东西。什么时候放弃，什么时候坚持是一件很哲学的问题吧。我到这里也不知道说什么好了。</p>
<p>今天就暂时写到这些吧，希望之后的时间也能继续加油。现在虽然学了很多东西，但是没办法把知识串联在一起，也有点迷茫。有时候分析一些问题的时候，反而会因为知道的太多而被绕进去。就像之前不知道从哪里看到的三大境界：</p>
<ul>
<li>看山是山 看水是水</li>
<li>看山不是山 看水不是水</li>
<li>看山还是山 看水还是水</li>
</ul>
<p>我现在可能介于一二之间吧，很难受，技术不到家，看很多东西都是残破不堪的，漏洞百出，我自己也知道。希望以后能慢慢解决这个这个问题吧。还有就是我现在也遇到了一些生活中难以解决的问题，我也不知道怎么做，在迷茫的时候还是要坚定的提升自己，也许以后时间会给出答案吧。之后也要继续加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/99-%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/99-%E5%9B%BE/" class="post-title-link" itemprop="url">99:图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 11:15:14" itemprop="dateCreated datePublished" datetime="2025-11-22T11:15:14+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:11" itemprop="dateModified" datetime="2025-11-29T13:49:11+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天接着来认识一下图，结束了图的学习，数据结构的部分就告一段落了。之后就是涉及到一些基本的算法问题，感觉也会越来越难。</p>
<h1 id="图">图</h1>
<h2 id="认识图">认识图</h2>
<p>和之前的数据结构不同，图是一种非线性的结构，由顶点和边组成，以下面为例，我们可以将图G抽象的表示成一组顶点和一组边的集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">E = &#123;(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>)&#125;</span><br><span class="line">G = &#123;V,E&#125;</span><br></pre></td></tr></table></figure>
<p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数
据结构。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/6ASNIDxnhqC7tKo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="图的常见类型和术语">图的常见类型和术语</h3>
<p>结合不同的场景，我们可以从不同的角度对图进行分类：</p>
<ul>
<li>根据边是否具有方向，分为有向图和无向图</li>
<li>根据顶点直接是否全部联通，分为联通图和非联通图</li>
<li>根据边上的权重，非为无权图和有权图</li>
<li>….</li>
</ul>
<p>在不同的场景中我们选择合适的类型，来解决问题。</p>
<p>图的数据结构有以下常用术语：</p>
<ul>
<li><strong>邻接：</strong>当两顶点之间存在边相连时，称这两个顶点邻接</li>
<li><strong>路径：</strong>从顶点A到顶点B经过的边构成的序列被称为从A到B的路径</li>
<li><strong>度：</strong>一个顶点拥有的边数。对有向图，根据边的方向，还分为入度和出度。</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>图通常使用两种表示方式，我们这里均以无向图为例：</p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>设图的顶点数量为𝑛，邻接矩阵使用一个n×n大小的矩阵来表示图，每一行（列）代
表一个顶点，矩阵元素代表边，用1或0表示两个顶点之间是否存在边。</p>
<p>设邻接矩阵为𝑀、顶点列表为𝑉
，那么矩阵元素𝑀[𝑖,𝑗]=1表示顶点𝑉[𝑖]到顶点𝑉[𝑗]
之间存在边，反之𝑀[𝑖,𝑗]=0表示两顶点之间无边。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/3i1YVTLzGIZHjQr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>邻接矩阵有以下性质：</p>
<ul>
<li>在简单图中，顶点不能和自己相连，所以邻接矩阵主对角线上的元素是没有意义的</li>
<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称</li>
<li>将邻接矩阵的元素替换成权重就是有权图</li>
</ul>
<h4 id="邻接表">邻接表</h4>
<p>邻接表使用n个链表来表示图，链表节点表示顶点。第i个链表对应顶点i，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。如下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/1W6QDdhbJVTZUYE.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="两种表示方法的比较">两种表示方法的比较</h4>
<p>对于邻接矩阵，我们可以直接访问矩阵元素实现对边的CRUD，时间效率高达<span
class="math inline"><em>O</em>(1)</span>。但是矩阵存储的空间复杂度为<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></p>
<p>对于邻接表，由于表中只存储实际已存在的边数，而边数通常小于<span
class="math inline"><em>n</em><sup>2</sup></span>，所以空间存储的效率上来看，邻接表要更加的节省空间。但是对于CRUD的操作，邻接表需要通过遍历搜索的方式来进行，所以时间效率更差。</p>
<p>但是结合先前的只是，对于这种链表较长的情况，我们可以将它优化成哈希表或者AVL树等结构，实现对时间效率的优化，所以对于大规模的图的使用场景，邻接表也更加普遍。</p>
<h2 id="图的基本操作">图的基本操作</h2>
<p>图的操作主要可以分为对顶点和对边的操作，这里分别通过邻接矩阵和邻接表的方式进行实现。</p>
<h3 id="基于邻接矩阵的实现">基于邻接矩阵的实现</h3>
<p>给定给一个顶点数量为n的无向图，我们需要完成以下操作：</p>
<ul>
<li><strong>添加或删除边：</strong>直接在邻接矩阵修改指定的边，只不过要注意同时更新两个方向的边（无向图）</li>
<li><strong>添加顶点：</strong>在邻接矩阵的尾部添加一行一列，并初始化为0即可。</li>
<li><strong>删除顶点：</strong>在邻接举证中删除一行一列，将剩下的元素向左上补齐。对于最坏的情况（删除首行首列）需要移动<span
class="math inline">(<em>n</em> − 1)<sup>2</sup></span>个元素</li>
<li><strong>初始化：</strong>传入n个顶点，初始化长度为n的顶点列表和nxn大小的邻接矩阵</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/zKrGQMe1svBL9jY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMap</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vertices;           <span class="comment">// 顶点列表</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMat;     <span class="comment">// 邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphMap</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val : vertices)</span><br><span class="line">                <span class="built_in">addVertex</span>(val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;edge : edges)</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">            <span class="comment">// 向邻接矩阵中添加一行</span></span><br><span class="line">            adjMat.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row: adjMat)</span><br><span class="line">                row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除行</span></span><br><span class="line">            adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除列</span></span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat)</span><br><span class="line">                row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="基于邻接表的实现">基于邻接表的实现</h3>
<p>设无向图的顶点总数为n、边总数为m，我们需要完成以下操作：</p>
<ul>
<li><strong>添加边：</strong>在顶点对应链表的末尾添加边就行了。但是要注意无向图要加两个方向的边</li>
<li><strong>删除边：</strong>在顶点管理的链表中查找并删除指定的边。无向图中删两个方向。</li>
<li><strong>添加顶点：</strong>在邻接表中添加一个链表，并将新增顶点作为链表头节点</li>
<li><strong>删除顶点：</strong>遍历整个邻接表，删除包含指定顶点的所有边</li>
<li><strong>初始化：</strong>在邻接表中创建n个顶点和2m条边</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/eZVmQvChWyGikj2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>以下是邻接表的代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        unordered_map&lt;Vertex* ,vector&lt;Vertex*&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex*&gt; &amp;vec, Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i]==vet)&#123;</span><br><span class="line">                    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphList</span>(<span class="type">const</span> vector&lt;vector&lt;Vertex*&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;Vertex *&gt; &amp; edge: edges)&#123;</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            adjList[vet] = <span class="built_in">vector</span>&lt;Vertex*&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;adj : adjList)</span><br><span class="line">                <span class="built_in">remove</span>(adj.second,vet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">            adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet1],vet2);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet2],vet1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为了方便，我们使用动态数组代替了链表。用哈希表来表示邻接表结构。</p>
<p>同时需要注意在邻接表中我们使用<code>Vertex</code>类来表示顶点，也是为了方便。如果我们使用列表索引来区分不同德顶点的话，那么每当我们删除一个索引为i的顶点，就需要遍历整个邻接表，把所有索引大于i的顶点重新更新一遍，这样的话效率就很差。</p>
<h2 id="图的遍历">图的遍历</h2>
<p>树代表的是一对多的关系，图代表的是多对多的关系，所以我们可以将树视作图的一个特例。所以说树的遍历操作实际上也是图的遍历操作的一种特例。</p>
<p>和树类似的，我们有两种遍历方式实现对图的遍历操作：广度优先遍历和深度优先遍历</p>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外
扩张。以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/T2MS6rYJNOWeIGb.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻
接顶点，以此类推，直至所有顶点访问完毕。</p>
<h4 id="算法实现">算法实现</h4>
<p>BFS通常需要一个辅助队列来实现，通过队列先进先出的性质，实现BFS由近及远的思路。我们的实现流程如下：</p>
<ul>
<li>将遍历起始顶点<code>startVet</code>加入队列中，开始循环</li>
<li>在每次迭代中，弹出队首顶点并访问，将该顶点的所有邻接点加入到队列尾部</li>
<li>循环上一步，知道队列为空</li>
</ul>
<p>同时我们还需要一个哈希集合<code>visited</code>来记录哪些节点被访问，以防止重复遍历顶点。</p>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphBFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    vector&lt;Vertex*&gt; res;				<span class="comment">// 返回的顶点序列</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;		 <span class="comment">// 哈希集合,用来记录被访问过的顶点	</span></span><br><span class="line">    queue&lt;Vertex*&gt; que;					<span class="comment">// 辅助队列	</span></span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Vertex* vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> adjVet : graph.adjList[vet])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;				<span class="comment">// 跳过已访问的顶点</span></span><br><span class="line">            que.<span class="built_in">push</span>(adjVet);</span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过画图的方法帮助理解一下这个过程</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。以下图为例</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/4BcYNu6gOmpyzfa.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="算法实现-1">算法实现</h4>
<p>这种走到尽头并返回的样式，我们可以通过递归的方式实现。关键在于怎么设置边界条件，退出递归。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(GraphList &amp;graph, unordered_set&lt;Vertex*&gt; &amp;visited,</span></span></span><br><span class="line"><span class="params"><span class="function">         vector&lt;Vertex*&gt; &amp;res, Vertex * vet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 记录访问节点</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">    <span class="comment">// 标记已访问节点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet);</span><br><span class="line">	<span class="comment">// 遍历所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span>(Vertex* adjVet : graph.adjList[vet])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph,visited,res,adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphDFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex*&gt; res;</span><br><span class="line">    <span class="comment">// 以访问过的顶点</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph,visited,res,startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自己尝试手推一下这个过程，加深理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/18/98-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/18/98-%E5%A0%86/" class="post-title-link" itemprop="url">98:堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-18 15:07:44" itemprop="dateCreated datePublished" datetime="2025-11-18T15:07:44+08:00">2025-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:06" itemprop="dateModified" datetime="2025-11-29T13:49:06+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学一种新的数据结构——“堆”，但是貌似和底层原理中的堆并不一样。之前总是略有耳闻，但是一直都很少仔细去了解。</p>
<h1 id="堆">堆</h1>
<p>堆是一种满足特定条件的完全二叉树，根据性质可以分为两种类型：</p>
<ul>
<li>小顶堆：任意节点的值 &lt;= 子节点的值</li>
<li>大顶堆：任意节点的值 &gt;= 子节点的值</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/18/Zjx5Hnc4sqoQYiW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>堆作为完全二叉树的一个特例，有以下规则：</p>
<ul>
<li>最底层的节点靠左排列，其他层被节点填满。</li>
<li>二叉树的根节点被称为<strong>堆顶</strong>，二叉树底层靠右的节点称为<strong>堆底</strong></li>
<li>对于大(小)顶堆，堆顶元素的值是最大(小)的</li>
</ul>
<h2 id="堆的常用操作">堆的常用操作</h2>
<p>有一种抽象的数据结构——优先队列，定义为具有优先级排序的队列。通常我们会使用堆来实现优先队列，大顶堆就相当于元素按大到小的顺序出队的优先队列。这里我们将其视作等价的数据结构。</p>
<p>这里我们先通过优先队列来认识一下堆的一些操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minheap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxheap;</span><br><span class="line"></span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The size is &quot;</span> &lt;&lt; maxheap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> top = maxheap.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The top is &quot;</span> &lt;&lt; top &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEmpty = maxheap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的可以总结为以下几类：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/7Lgt6pdXfOrTP2V.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="堆的实现">堆的实现</h2>
<p>现在我们尝试从底层实现一个堆，这里我们用大顶堆演示，小顶堆只需要将所有的大小逻辑判断反转即可。</p>
<h3 id="堆的存储和表示">堆的存储和表示</h3>
<p>堆是一种完全二叉树，我们之前提到过完全二叉树十分适合用数组来进行存储，所以这里我们的底层实现选择用数组，和之前的实现一样。我们使用索引的映射公式来代替节点指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问堆顶元素">访问堆顶元素</h3>
<p>堆顶元素就是二叉树的根节点，也就是我们数组的首元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素入堆">元素入堆</h3>
<p>给定<code>val</code>，我们将其添加到堆底。但是此时插入的值可能会破坏当前到根节点的路径，导致堆的成立条件被破坏。所以我们需要遍历修复从插入节点到根节点路径上的所有节点，这个过程我们称之为<strong>堆化</strong></p>
<p>从入堆节点开始，我们从底执行堆化。我们依次比较当前节点和父节点的大小，如果插入节点更大就讲他们交换，知道修复所有的节点关系。</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/3OjBe9MCgLIG7sA.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过以下方式实现这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          heap.<span class="built_in">push_back</span>(i);</span><br><span class="line">          <span class="comment">// 从堆底开始堆化</span></span><br><span class="line">          <span class="built_in">siftUp</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">              <span class="type">int</span> p = <span class="built_in">parent</span>(i);</span><br><span class="line">              <span class="keyword">if</span>(p&lt;<span class="number">0</span> || heap[i] &lt;= heap[p])</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="built_in">swap</span>(heap[i],heap[p]);</span><br><span class="line">              <span class="comment">// 向上堆化</span></span><br><span class="line">              i=p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆顶元素出栈">堆顶元素出栈</h3>
<p>堆顶元素是二叉树的根节点，如果我们直接从数组中删除首元素，那么会破坏整个树的树状结构，这导致后续的堆化难以修复。所以我们采取以下步骤将堆顶元素出栈：</p>
<ul>
<li>交换堆顶元素（根节点）和堆底元素（最右元素）</li>
<li>交换完成之后，我们将堆底删除</li>
<li>从根节点开始自顶向底执行堆化</li>
</ul>
<p>自顶向下的堆化和自底向上的堆化逻辑相反，我们将当前节点和较大的子节点进行比较，然后进行交换，直到没有子节点或者无需再交换了：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/DhigaQdUJ3GnKW5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>出堆的实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// ma为较大的节点</span></span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">left</span>(i), r=<span class="built_in">right</span>(i), ma = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[l])</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[r])</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// l,r越界或者i已经是最大节点 则退出堆化</span></span><br><span class="line">        <span class="keyword">if</span>(ma==i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[ma]);</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建堆操作">建堆操作</h3>
<p>我们希望能直接根据一个列表中的所有元素来构建一个堆。我们有两种可行的方案：</p>
<ul>
<li>创建一个空堆，然后遍历列表，对每一个元素都进行入堆操作。但是对于n个元素执行复杂度为<code>O(logn)</code>的入堆操作，时间复杂度会增长到<code>O(nlogn)</code></li>
<li>另一个方法就是，将列表中的元素添加到完全二叉树中，尽管现在的堆的性质并没有被满足。接下来我们倒序遍历堆，并对每个非叶节点进行一次自顶向下的堆化。这样每当我们堆化一个节点之后，都会以该节点为根节点形成一个子堆。</li>
</ul>
<p>这里我们着重分析一下第二种方法。我们可以通过以下方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Heap</span>(vector&lt;<span class="type">int</span>&gt; vec)&#123;</span><br><span class="line">    heap = vec;</span><br><span class="line">    <span class="comment">// 倒序遍历的第一个非叶节点 就是最后一个叶节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">parent</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>); i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">siftDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法下的复杂度被优化到了<code>O(n)</code>，更加的便捷。</p>
<h2 id="top-k问题">Top-k问题</h2>
<p>所谓top-k问题，就是给定一个长度为n的无序数组<code>nums</code>，请返回数组中最大的k个元素。</p>
<p>对于这个问题我们有很多种解决方案：</p>
<h3 id="遍历选择">遍历选择</h3>
<p>我们可以像这样对一个长度为n的序列进行k次遍历，每轮遍历都提取出当前序列中的最大的数据。时间复杂度为<code>O(nk)</code>。当k接近n时，时间复杂度增长到<code>O(n^2)</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/18/upZYUAsJwrt2gcz.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="排序">排序</h3>
<p>先对数组<code>nums</code>进行排序，然后再返回最右边的k个数据。这个方法主要取决于对数组排序的时间复杂度，对于<code>std::sort</code>，这个方法的复杂度是<code>O(nlogn)</code></p>
<h3 id="堆-1">堆</h3>
<p>我们可以基于堆更加高效的完成这个任务，我们遵循以下步骤实现：</p>
<ul>
<li>初始化一个小顶堆，此时其堆顶元素最小。</li>
<li>然后将数组的前k个元素依次入堆</li>
<li>从第k+1个元素开始，如果当前元素大于堆顶元素，我们就将堆顶出堆，并将当前元素入堆。</li>
<li>遍历完成之后，堆中保存的就是最大的k个元素。</li>
</ul>
<p>我们可以写出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">topHeap</span>(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">top</span>() &lt; nums[i])&#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共进行了n轮入堆和出堆，由于堆大小是固定的k，所以我们只需要维护k个元素，所以实际上我们的计算复杂度只有<code>O(nlogk)</code>，在k较小时，我们的时间复杂度约等于<code>O(n)</code></p>
<p>由此可以看到通过堆的思路，对解决<code>TopK</code>问题的显著提升。尤其是对于这种方法，适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现
最大的𝑘个元素的动态更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="post-title-link" itemprop="url">97:平衡树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-17 20:45:51" itemprop="dateCreated datePublished" datetime="2025-11-17T20:45:51+08:00">2025-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:53" itemprop="dateModified" datetime="2025-11-29T13:48:53+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，接着研究一下AVL树。</p>
<h2 id="avl树">AVL树</h2>
<p>在二叉搜索树中，我们可以知道，在多次的插入和删除之后，二叉树的左右可能会失去平衡，从而导致退化成链表，在这样的情况下我们的算法的效率会从<code>O(logn)</code>退化到<code>O(n)</code>：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/5jRdMzbsJDmt3Z2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/hxU4EiZFm9HaNOk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>但是我们接下来将要提到的AVL树，将解决这些问题</p>
<h3 id="avl树的常见术语">AVL树的常见术语</h3>
<p>AVL树本质是二叉搜索树和二叉平衡树的结合，所以同时满足这两种树的性质：</p>
<ol type="1">
<li><strong>节点高度</strong></li>
</ol>
<p>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。这里我们让叶子节点的高度为<code>0</code>，把空节点的高度设置为<code>-1</code>。我们将根据这些性质来编写我们的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left&#123;&#125;;</span><br><span class="line">    TreeNode* right&#123;&#125;;</span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span>: val(x) &#123;</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的高度 = 最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left),<span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>节点的平衡因子</strong></li>
</ol>
<p>节点的平衡因子定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。对于AVL树，我们要求树中任意节点的平衡因子<code>-1&lt;=f&lt;=1</code>，否则这个树就进入了失衡状态。我们可以写出以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">balance</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的旋转">AVL树的旋转</h3>
<p>AVL树的精髓就在于旋转操作，当我们的树中存在失衡节点时，我们可以通过“旋转”操作，在不影响中序遍历序列的前提下，使失衡的节点重新回到平衡的状态。</p>
<p>我们将<code>|平衡因子| &gt; 1</code>的节点称为失衡节点，根据不同的失衡情况，我们有四种旋转操作：</p>
<h4 id="右旋">右旋</h4>
<figure>
<img src="https://s2.loli.net/2025/11/17/OHDbWSA6JQIgBc4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>结合这张图来看，从底至顶看，二叉树中首个失衡节点是“节点3”。我们关注以该失衡
节点为根节点的子树，将该节点记为 node ，其左子节点记为 child
，执行“右旋”操作。完成右旋后，子树
恢复平衡，并且仍然保持二叉搜索树的性质。</p>
<p>但是对于，当节点<code>child</code>有右节点（记作<code>grand_child</code>）的情况下，我们需在右旋中添加一步：将<code>grand_child</code>设置为<code>node</code>的左子节点。</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/J1BOAZhMKVXuwGl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过修改节点指针的方法来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    TreeNode* grandChild = child-&gt;right;</span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    <span class="comment">// 当grandChild为null时无影响</span></span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="comment">// 右旋后child作为左子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="左旋">左旋</h4>
<p>左旋作为右旋的镜像版本，对应右节点失衡的情况，同样是下面的两种情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/vSVYkineu6gU9ID.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/xqeXp4zbtHB3KIg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;right;</span><br><span class="line">    TreeNode* grandChild = child-&gt;left;</span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先左旋后右旋">先左旋后右旋</h4>
<p>对于下面这种情况，我们需要先对<code>child</code>进行左旋，再对<code>node</code>进行右旋：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/LzuXUe4dlR2GSaD.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="先右旋后左旋">先右旋后左旋</h3>
<p>这种情况依旧是上一种情况的镜像对称情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/q2JQknaz7PGlIci.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="旋转的选择">旋转的选择</h4>
<p>讲完了四种旋转的操作，现在我们需要分析，在什么情况下需要对我们的树进行哪些操作了，这里的话我推荐看一个视频：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&amp;vd_source=860ada84437562c4715775e08ac9e2ae">平衡二叉树(AVL树)_哔哩哔哩_bilibili</a></p>
<p>我们的步骤总结如下：</p>
<ul>
<li>先检查失衡节点的子节点<code>child</code>的平衡因子，大于0则需要进行右旋操作，小于0则需要进行左旋操作。</li>
<li>然后检查失衡节点<code>node</code>的平衡因子，大于1则需要进行右旋操作，小于1则需要左旋操作。</li>
<li>最后比较对子节点<code>chlid</code>和失衡节点<code>node</code>的需要进行的操作，如果相同则合并，不同则先操作子节点后操作失衡节点。</li>
</ul>
<p>我们也可以用一张表来进行这个判断：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/HInBOe2GjgZEXCo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>现在我们可以写出AVL树的平衡函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _balanceFactor = <span class="built_in">balance</span>(node);</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(_balanceFactor &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 右旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&lt;<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 先左旋</span></span><br><span class="line">            child = <span class="built_in">leftRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_balanceFactor &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 左旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 先右旋</span></span><br><span class="line">            child = <span class="built_in">rightRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 平衡</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的常用操作">AVL树的常用操作</h3>
<ol type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>AVL树的节点插入操作和二叉搜索树一样，只不过在AVL树插入节点之后，从这个节点到根节点的路径上可能会出现一系列的失衡节点。所以我们需要从这个节点开始，自底向上的执行平衡操作，知道所有的失衡节点都恢复平衡。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _insert(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _insert(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = _insert(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>删除操作</strong></li>
</ol>
<p>删除也是差不多，需要在删除的基础之上，从底部到顶部进行平衡操作，确保所有的失衡点都恢复平衡：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _remove(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _remove(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right =_remove(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>||node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* child = node-&gt;left==<span class="literal">nullptr</span> ? node-&gt;right : node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* tmp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left !=<span class="literal">nullptr</span>)</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            <span class="type">int</span> val = tmp-&gt;val;</span><br><span class="line">            node-&gt;right = _remove(node-&gt;right,tmp-&gt;val);</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>查找操作</strong></li>
</ol>
<p>和二叉搜索树一样，没有变化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">96:十一月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-16 16:54:07" itemprop="dateCreated datePublished" datetime="2025-11-16T16:54:07+08:00">2025-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:52:34" itemprop="dateModified" datetime="2025-11-29T13:52:34+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>841</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>十一月份已经过去了一半。回顾这个月我都做了什么，做到了什么呢？仔细一想是没有的，感觉时间过的好快，转眼间就过去了大半个学期，自己也是没什么收获，定下的很多目标都没有做到。</p>
<p>马上就要期中考试了，我希望能在各科都拿到一个比较好的成绩吧，因为这个学期对我的绩点来说是十分重要的。所以一定要好好加油，尤其是408相关的课程，一定要好好学，不能只是满足于书上的内容，不仅要掌握概念，也要会做题。要做好考研的准备吧，因为推免资格对我而言还是有点困难的，所以一定要好好加油。</p>
<p>这个月接触到了各种语言吧，学的很杂，接触到了Lua和他的游戏开发引擎，我之前说过想做一个游戏，但是思路上仍然是一头雾水，做一个什么样的游戏呢，要做哪些内容呢？我一点idea也没有，所以只能慢慢积累了，还有一些游戏开发相关的技术。所以我选择去了解一下星露谷物语的mod制作，它是用C#进行编写的，语法结构和Java差不多，所以我勉强能看懂一些，但是对于整个项目结构一点也不够了解。</p>
<p>我发现自己总是半途而废，我经常会突然想做什么，但是没办法一直做下去，我感觉要做的事情太多了，我不知道该怎么安排过来，所以也比较晕头转向的。接下来的一个月里，我打算好好夯实一下课内的知识吧，比如操作系统和数据结构，目前学习的过程中也明显感受到了清晰的需求。争取在这个学期把王道的课程也看掉一部分，感觉他讲的还是十分详细的。然后是概率论和离散数学，我也打算好好学一下了，每天坚持做一点题目，因为到现在为止，我对这两门科目都是不太了解。</p>
<p>还有的就是密码学 信息安全基础
程序设计一类的课程了，要想办法把平时分搞高一点，争取一下满绩吧。拉一拉我上上个学期拖得后腿。我发现密码学的很多知识还是比较有用的，因为会涉及到一些简单的数论和密码学体制。我以前总是抗拒听老师的课，但是其实我自己也不知道要做什么，何妨不听一听呢。</p>
<p>然后感觉最近心态好了很多吧，平时不会想那么多了。以后有空的话我也想试试出去旅游，然后玩一点剧情类的游戏。有空的话想拍一点游戏视频。尝试各种各样的事情。我想自己的人生开阔一点，可是我总是半途而废，总是做不到，但是既然有这样的想法就试一试吧。希望未来会越来越好，有很多开心的事在等着我。</p>
<p>我也想坚持锻炼身体，希望能健健康康的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/15/95-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/15/95-%E6%A0%91/" class="post-title-link" itemprop="url">95:树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-15 16:03:54" itemprop="dateCreated datePublished" datetime="2025-11-15T16:03:54+08:00">2025-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:46" itemprop="dateModified" datetime="2025-11-29T13:48:46+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打算系统性的学一下数据结构与算法，这个就相当于笔记做一下记录了。 #
树</p>
<h2 id="二叉树">二叉树</h2>
<p>二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。我们可以用以下数据结构表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里每个节点都有两个引用，分别为左右子节点，中间的节点为这两个节点的父节点。左右子树的概念也可以类推。<strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。</strong></p>
<h3 id="二叉树常用的术语">二叉树常用的术语</h3>
<p>二叉树中的性质较为复杂，所以我们需要记住许多相关的术语：</p>
<ul>
<li>根节点：位于二叉树顶层的节点，没有父节点。</li>
<li>叶节点：没有子节点的节点，其两个指针均指向 None</li>
<li>边：连接两个节点的线段，即节点引用（指针）</li>
<li>节点所在的层：从顶至底递增，根节点所在层为1。</li>
<li>节点的度：节点的子节点的数量。在二叉树中，度的取值范围是0、1、2。</li>
<li>二叉树的高度：从根节点到最远叶节点所经过的边的数量</li>
<li>节点的深度：从根节点到该节点所经过的边的数量。</li>
<li>节点的高度：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/15/79N3evPGgUXx6fw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的基本操作">二叉树的基本操作</h3>
<ol type="1">
<li><strong>初始化二叉树</strong></li>
</ol>
<p>​ 初始化节点，并构造引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode* n1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode* n2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode* n3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode* n4 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n5 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    n1-&gt;left = n2;</span><br><span class="line">    n1-&gt;right = n3;</span><br><span class="line">    n2-&gt;left = n4;</span><br><span class="line">    n2-&gt;right = n5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入与删除节点</strong></li>
</ol>
<p>​ 二叉树中的插入与删除节点可以通过修改指针实现，效果见下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/OBCUobELsv2yVSk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的类型">二叉树的类型</h3>
<h4 id="完美二叉树">完美二叉树</h4>
<p>完美二叉树的所有层的节点都被完全填满。且在完美二叉树中，叶节点的度为0，其余所有节点的度都为2；若树的高度为ℎ，则节点总数为2ℎ+1−1，呈现标准的指数级关系：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/wm5xDqf234QTkIc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>关于完美二叉树，我们需要注意到它的几个性质：</p>
<ul>
<li><strong>第i层的节点数量：</strong> <span
class="math inline">2<sup><em>i</em> − 1</sup></span></li>
<li><strong>高度为h的树的叶节点数量：</strong><span
class="math inline">2<sup><em>h</em></sup></span></li>
<li><strong>高度为h的树的节点总数：</strong> <span
class="math inline">2<sup><em>h</em> + 1</sup> − 1</span></li>
<li><strong>节点总数为n的树的高度：</strong><span
class="math inline"><em>l</em><em>o</em><em>g</em><sub>2</sub>(<em>n</em> + 1) − 1</span></li>
</ul>
<h4 id="完全二叉树">完全二叉树</h4>
<p>完全二叉树只有最底层的节点未被填满，且最底层的节点尽量靠左边。</p>
<p>注：完美二叉树是一种特殊的完全二叉树</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/tMZBKs3xRLaXTcu.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="完满二叉树">完满二叉树</h4>
<p>完满二叉树除了叶子节点之外，其余所有节点都有两个子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/LoBGgVvxW4miF7N.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="平衡二叉树">平衡二叉树</h4>
<p>平衡二叉树中的任意节点的左子树和右子树的高度之差的绝对值不超过1，<code>|左子树高度-右子树高度|&lt;=1</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/15/Ev6t13Msx24lpIo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="二叉树遍历">二叉树遍历</h2>
<p>常见的二叉树遍历有：层序遍历、前序遍历、中序遍历和后序遍历</p>
<h3 id="层序遍历">层序遍历</h3>
<p>层序遍历是从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。这种遍历方式本质上属于广度优先遍历，我们也称之为广度优先搜索：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/xAbY8fXjeuOtnRQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;		<span class="comment">// 用于存放遍历序列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();			<span class="comment">// 将需要处理的节点出列</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前中后序遍历">前中后序遍历</h3>
<p>相应的这种遍历方式实际上是一种深度优先的遍历，我们称之为深度有限的搜索。这里我们有三种不同的遍历顺序，我们可以通过简单的递归来实现，具体实现如下。就不做过多的说明，因为很直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pastOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    pastOrder(root-&gt;left);</span><br><span class="line">    pastOrder(root-&gt;right);    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的数组表示">二叉树的数组表示</h2>
<p>我们先前对二叉树的实现是通过链表进行实现的，节点之间则通过指针连接。但是实际上我们也可以通过数组实现二叉树的结构。</p>
<h3 id="表示完美二叉树">表示完美二叉树</h3>
<p>对于一颗完美二叉树，我们可以将所有的节点按照层序遍历的顺序存储一个数组中，则每个节点都对应唯一的数组索引，根据层序遍历的特性，我们也可以推导出父子节点之间的索引关系：</p>
<p><strong>若某节点的索引为𝑖，
则该节点的左子节点索引为2𝑖+1，右子节点索引为2𝑖+2</strong></p>
<p>这里的映射关系就相当于先前的指针，我们只需要知道当前的索引，就能找到其对应的左右节点</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/nKbiCcQN3fhk4al.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="表示任意二叉树">表示任意二叉树</h3>
<p>完美二叉树是一个特例，在实际情况中，我们的二叉树中间层有很多<code>None</code>，如果层序遍历不包含这些<code>None</code>，那么我们就无法根据一个数组来还原二叉树的形态：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/MJ9KjoOWAIVvtG1.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>所以我们尝试在层序遍历的序列中显式的写出所有的<code>None</code>:</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/ZXafdEGv3RcoBOl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>就可以清晰的表示一个二叉树的结构。当然需要注意的是，完全二叉树十分适合用数组来表示，我们知道其<code>None</code>只会出现在最底层的右边，一定出现在层序遍历序列的末尾。这意味着当我们对完全二叉树进行存储时，我们可以忽略所有的<code>None</code></p>
<h3 id="二叉树的数组实现">二叉树的数组实现</h3>
<p>现在我们尝试用数组实现二叉树的结构，我们需要支持以下操作：</p>
<ul>
<li>给定某节点，获取其值、左右子节点、父节点</li>
<li>获取前序、中序、后序遍历、层序遍历序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayBinaryTree</span>(vector&lt;<span class="type">int</span>&gt; arr)&#123;</span><br><span class="line">        tree = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> tree[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">val</span>(i)!=<span class="number">-1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pastOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>如下图所示，二叉搜索树需要满足以下条件：</p>
<ul>
<li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt;
右子树所有节点的值</li>
<li>任意节点的左右子树也时二叉搜索树，满足上一个条件</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/EUbMoqiVmQJug8Z.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉搜索树的操作">二叉搜索树的操作</h3>
<p>我们将二叉搜索树封装为一个类<code>BinarySerchTree</code>，并声明一个成员变量<code>root</code>，指向树的节点。</p>
<ol type="1">
<li><strong>查找节点</strong></li>
</ol>
<p>给定一个目标节点值<code>num</code>，我们可以很快的根据二叉搜索树的性质来查找，我们可以声明一个节点<code>cur</code>，从二叉树的根节点<code>root</code>出发，循环比较值，知道找到对应的节点。</p>
<p>二叉搜索树的查找操作实际上和二分查找差不多，循环次数最多为树的高度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val &gt; num)</span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> cur;</span><br><span class="line">       &#125;  </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>给定一个等待插入的元素<code>num</code>，为了保持二叉树的性质，我们进行以下步骤：</p>
<ul>
<li>查找插入位置：和查找操作相似，从根节点出出发，直到越过叶节点时退出循环。</li>
<li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>none</code>的位置。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/8GEtkeaMZ6B1SbU.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在编写的过程中我们需要注意两点：</p>
<ul>
<li>如果插入的数值已经存在，那么则不插入。</li>
<li>使用<code>pre</code>节点保存<code>cur</code>的上一个位置，以为我们指定插入位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               pre = cur;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">           <span class="keyword">if</span>(num &gt; pre-&gt;val)</span><br><span class="line">               pre-&gt;right = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pre-&gt;left = node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>删除节点</strong></li>
</ol>
<p>在二叉树中查找到目标节点，并将其删除，和插入节点类似，我们需要保证在删除操作完成之后仍然保持着二叉树的性质。所以我们需要根据目标子节点的数量，分为<code>0\1\2</code>三种情况进行相应的处理。</p>
<p>对于度为0的情况，我们只需要简单的删除：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/cNCLRi7B2nJhqmM.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当度为1时，我们需要将待删除的节点替换成其子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/WlRGE2JQf8zK47s.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于度为2的节点，我们则需要谨慎处理。首先我们需要找到一个能替换它的节点（左子树的最大值或是右子树的最小值），并将其删除，覆盖待删除的节点：</p>
<ul>
<li>找到待删除节点在中序遍历序列中的下一个节点，记为<code>tmp</code></li>
<li>用<code>tmp</code>的值覆盖待删除节点的值，并在书中递归删除节点<code>tmp</code></li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/kltzjwHXGmpd2EI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 度为0/1</span></span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span> || cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        TreeNode* child = cur-&gt;left==<span class="literal">nullptr</span>?cur-&gt;right:cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(cur!=root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;left==cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode* tmp = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 寻找后继节点</span></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        <span class="comment">// 递归删除后继节点</span></span><br><span class="line">        <span class="built_in">remove</span>(tmp-&gt;val);</span><br><span class="line">        cur-&gt;val = tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>中序遍历有序</strong></li>
</ol>
<p>由于搜索二叉树的性质，当我们对其进行中序遍历时，总是会优先遍历下一个最小节点，所以我们知道：<strong>搜索二叉树的中序遍历时升序的</strong>。所以我们可以直接得到搜索二叉树的有序数据。</p>
<h2 id="avl树">AVL树</h2>
<p>之后单独开一篇讲 感觉比较复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/" class="post-title-link" itemprop="url">94:c4编译器回顾(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 15:23:50" itemprop="dateCreated datePublished" datetime="2025-11-04T15:23:50+08:00">2025-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-09 16:16:32" itemprop="dateModified" datetime="2025-11-09T16:16:32+08:00">2025-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一章中，我们完成了对函数体的解析，现在我们需要进一步解析函数体中的语句，还有程序中的表达式。我们需要将程序中的语句解析成我们的虚拟机能直接执行的语句，所以这一章中会有一点难度：</p>
<h2 id="语句">语句</h2>
<p>我们的编译器中识别以下六种语句：</p>
<ul>
<li><code>if(...) &lt;statement&gt;; [else &lt;statement&gt;;]</code></li>
<li><code>while (...) &lt;statement&gt;;</code></li>
<li><code>&#123;&lt;statement&gt;;&#125;</code></li>
<li><code>return xxx;</code></li>
<li><code>&lt;;(empty statement)&gt;</code></li>
<li><code>expression(这个我们稍后单独讨论)</code></li>
</ul>
<p>现在我们要将这些语句转换成对应的汇编代码：</p>
<h3 id="if语句">IF语句</h3>
<p>IF语句的作用是跳转，根据条件表达式决定跳转的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &lt;statement&gt; [<span class="keyword">else</span> &lt;statement&gt;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&lt;cond&gt;)                   &lt;cond&gt;</span><br><span class="line">JZ a</span><br><span class="line">&lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</span><br><span class="line"><span class="keyword">else</span>:                         JMP b</span><br><span class="line">a:                           a:</span><br><span class="line">&lt;false_statement&gt;           &lt;false_statement&gt;</span><br><span class="line">b:                           b:</span><br></pre></td></tr></table></figure>
<p>对应的流程就是：</p>
<ul>
<li>先执行条件表达式<code>&lt;cond&gt;</code></li>
<li>如果条件失败，则跳转到<code>a</code>的位置，执行<code>else</code>语句</li>
<li>如果条件成功，则在执行<code>&lt;true_statement&gt;</code>之后，无条件跳转到<code>b</code>，结束判断。</li>
</ul>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==If)&#123;</span><br><span class="line">       match(If);</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       <span class="keyword">if</span>(token==Else)&#123;</span><br><span class="line">           match(Else);</span><br><span class="line">           *b = (<span class="type">int</span>)(text + <span class="number">2</span>);</span><br><span class="line">           *++text = JMP;</span><br><span class="line">           b = ++text;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从栈的视角进行解释，text始终是指向下一条要执行的指令的。我们希望<code>JZ</code>后面跟着的是<code>else</code>的代码块的入口或是<code>if</code>判断之后的地址。</p>
<p>这里我们使用了延迟绑定地址的方式，我们来看看以下两种情况：</p>
<ul>
<li>只有<code>if</code>，我们将在执行完<code>if_statement</code>之后，将<code>JZ</code>之后的跳转地址设置成下一条指令的地址<code>text</code></li>
<li>有<code>else</code>，我们希望能够跳转到<code>else</code>的起始地址，我们需要在当前<code>text</code>指向的地址基础上<code>+2</code>，因为我们需要跳过<code>JMP</code>和<code>出口地址</code>所占用的指令空间。同时我们需要将<code>if_statement</code>之后的地址设置成判断的出口，即<code>else_statement</code>的后一条指令</li>
</ul>
<h3 id="while语句">While语句</h3>
<p>While语句的汇编代码更加简单，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:                     a:</span><br><span class="line"><span class="keyword">while</span> (&lt;cond&gt;)        &lt;cond&gt;</span><br><span class="line">JZ b</span><br><span class="line">&lt;statement&gt;          &lt;statement&gt;</span><br><span class="line">JMP a</span><br><span class="line">b:                     b:</span><br></pre></td></tr></table></figure>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==While)&#123;</span><br><span class="line">       match(While);</span><br><span class="line">       a = text;</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       *++text = JMP;</span><br><span class="line">       *++text = (<span class="type">int</span>)a;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在跳转之前用<code>a</code>保存<code>expression</code>开始的指令，用于重新计算<code>cond</code>。然后延迟绑定地址<code>b</code>，作为<code>while</code>逻辑的出口</p>
<h3 id="return-语句">Return 语句</h3>
<p>遇到Return语句则代表函数将要退出了，这一部分很简单，实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Return)&#123;</span><br><span class="line">        match(Return);</span><br><span class="line">        <span class="keyword">if</span>(token!=<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            expression();</span><br><span class="line">        &#125;</span><br><span class="line">        *++text = LEV;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他语句">其他语句</h3>
<p>其他语句并不生成汇编代码，所以简单的匹配消耗即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">       <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>
<h2 id="expresion">expresion</h2>
<p>我们已经完成了对语句的解释，现在我们需要实现对表达式的解释，在此之前我们要明确什么是表达式？怎么解析我们的表达式，并计算他们。</p>
<h3 id="怎么计算表达式">怎么计算表达式</h3>
<p>对于表达式中的运算符，每一个符号都有自己的优先级，在进行运算的时候，我们希望运算符优先级高的子式先被计算。例如在<code>2 + 3 * 4</code>中，我们希望<code>*</code>先被计算，然后再是<code>+</code>。对于我们生成的汇编代码而言，我们应该优先为优先级高的运算符生成目标代码，所以如何确定一个表达式的优先运算顺序十分重要。</p>
<p>这里我们使用递归下降的方法实现对表达式运算符的解析，我们在一开始定义标识符时，实际上就对运算符的优先级进行了排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">    Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">    Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先明确，一元运算符的优先级始终是高于二元运算符的，所以这里我们需要，首先完成对一元运算符的解析，这里先罗列几个较为特殊的：</p>
<ul>
<li><code>Num</code> 当我们遇到一个数字时 要返回它的数值</li>
<li><code>"..."</code> 当我们遇到一个字符串时 要返回它的指针</li>
<li><code>PTR</code> 当我们遇到一个指针类型时
我们要正确的解析它的解引用</li>
<li><code>Func</code>
当我们遇到一个函数调用时，我们要正确的执行它，并返回返回值</li>
<li><code>Id</code> 当我们遇到一个变量时，需要返回它的存储的值</li>
<li>…</li>
</ul>
<p>然后，对一元预算符的判断结束后，我们需要对二元运算符的解析，但是对于二元运算符，我们需要考虑运算符号的优先级。我们给每一个运算符都设置一个当前的<code>level</code>，每次只对高于/等于当前<code>level</code>的运算符进行解析，每次解析完一个运算符之后，都将当前的优先级提高。这样我们就实现了对运算符的递归下降分析，我们的框架代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">    <span class="comment">// 解析一元运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 解析顺序按一元运算符优先级进行解析</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析二元运算符</span></span><br><span class="line">    <span class="keyword">while</span>(token&gt;=level)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们给出具体的实现：</p>
<h3 id="常量">常量</h3>
<p><code>Num</code>用<code>IMM</code>指令将其加载到ax中即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==Num)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是字符串常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = PTR;</span><br><span class="line">        <span class="comment">// while(token==&#x27;&quot;&#x27;) match(&#x27;&quot;&#x27;);</span></span><br><span class="line">        <span class="comment">// 对data段进行地址对齐</span></span><br><span class="line">        data = (<span class="type">char</span>*)(((<span class="type">int</span>)(data) + <span class="keyword">sizeof</span>(<span class="type">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意，如果你想支持<code>"Hello""World" = "HelloWorld"</code>的语法，那么你要设置<code>while(token=='"') match('"');</code>，这里我不想支持就不开了。</p>
<p>然后是<code>data = (char*)(((int)(data) + sizeof(int)) &amp; (-sizeof(int)));</code>，这一部分的作用是将数据段进行对齐，我们希望每次的<code>data</code>指针都是四字节对齐的，这样可以方便我们进行索引，或是避免了字符串访问越界的可能。</p>
<h3 id="sizeof">sizeof</h3>
<p>这个关键字我们也将其作为一元运算符进行处理，我们需要根据后面参数的类型，并返回它的大小。这里我们只支持<code>Int Char Ptr</code>三种类型，其中<code>Ptr</code>类型的大小同<code>int</code></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Sizeof)&#123;</span><br><span class="line">        match(Sizeof);</span><br><span class="line">        match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">            match(Int);</span><br><span class="line">            expr_type = INT;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            expr_type = CHAR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            expr_type = expr_type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = (expr_type==CHAR) ? <span class="keyword">sizeof</span>(<span class="type">char</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量与函数调用">变量与函数调用</h3>
<p>由于我们将函数和变量的值的词法分析都是以<code>Id</code>开头，所以我们对他们的目标代码生成也放在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Id)&#123;</span><br><span class="line">           match(Id);</span><br><span class="line">           id = current_id;</span><br><span class="line">           <span class="comment">// 函数调用</span></span><br><span class="line">           <span class="keyword">if</span>(token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">               tmp = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                   expression(Assign);</span><br><span class="line">                   *++text = PUSH;</span><br><span class="line">                   tmp++;</span><br><span class="line">                   <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class==Sys)&#123;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class==Fun)&#123;</span><br><span class="line">                   *++text = CALL;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数调用\n&quot;</span>,line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 清除栈上的变量</span></span><br><span class="line">               <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   *++text = ADJ;</span><br><span class="line">                   *++text = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Num)&#123;</span><br><span class="line">               *++text = IMM;</span><br><span class="line">               *++text = id-&gt;value;</span><br><span class="line">               expr_type = INT;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class = Glo)&#123;</span><br><span class="line">                   *++text = IMM;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Loc)&#123;</span><br><span class="line">                   *++text = LEA;</span><br><span class="line">                   *++text = -id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 未知变量类型\n&quot;</span>, line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">               *++text = (expr_type==CHAR) ? LC : LI;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针取值">指针取值</h3>
<p>说实话有点写不下去了，最近有点忙，心情也不好，写这个的过程中断断续续的，所以先到此为止吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/" class="post-title-link" itemprop="url">93:c4编译器回顾(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-30 16:26:49" itemprop="dateCreated datePublished" datetime="2025-10-30T16:26:49+08:00">2025-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-06 10:52:43" itemprop="dateModified" datetime="2025-11-06T10:52:43+08:00">2025-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们完成了对词法分析的获取函数<code>next()</code>，现在我们尝试根据token分析，和我们的语法规则，进行简单的语法分析。</p>
<h2 id="解析变量">解析变量</h2>
<p>我们的解释器的语法结构，可以用下面的EBNF的表示法直观的体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">program ::= &#123;global_declaration&#125;+</span><br><span class="line"></span><br><span class="line">global_declaration ::= enum_decl | variable_decl | function_decl</span><br><span class="line"></span><br><span class="line">enum_decl ::= <span class="string">&#x27;enum&#x27;</span> [id] <span class="string">&#x27;&#123;&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>] &#123;<span class="string">&#x27;,&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>&#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">variable_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123; <span class="string">&#x27;,&#x27;</span> &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">function_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id <span class="string">&#x27;(&#x27;</span> parameter_decl <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> body_decl <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">parameter_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123;<span class="string">&#x27;,&#x27;</span> type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id&#125;</span><br><span class="line"></span><br><span class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</span><br><span class="line"></span><br><span class="line">statement ::= non_empty_statement | empty_statement</span><br><span class="line"></span><br><span class="line">non_empty_statement ::= if_statement | while_statement | <span class="string">&#x27;&#123;&#x27;</span> statement <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">| <span class="string">&#x27;return&#x27;</span> expression | expression <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">if_statement ::= <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> statement [<span class="string">&#x27;else&#x27;</span> non_empty_statement]</span><br><span class="line"></span><br><span class="line">while_statement ::= <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> non_empty_statement</span><br></pre></td></tr></table></figure>
<p>对于我们的程序而言，一切都是从对<code>global_delartion</code>开始：</p>
<ul>
<li>变量定义</li>
<li>类型定义（目前只支持enum）</li>
<li>函数定义</li>
</ul>
<p>我们的<code>program()</code>作为语法解析函数，框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">while</span>(token &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        global_declaration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="global_declaration">global_declaration</h3>
<p>即全局定义的语句，我们通过递归下降的方法，来判断当前的定义类型，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">global_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    basetype = INT;</span><br><span class="line">    <span class="keyword">if</span>(token == Enum)&#123;</span><br><span class="line">        match(Enum);</span><br><span class="line">        <span class="keyword">if</span>(token != <span class="string">&#x27;&#123;&#x27;</span>) match(Id);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            enum_declaration();</span><br><span class="line">            match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">        match(Int);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">        match(Char);</span><br><span class="line">        basetype = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        type = basetype;</span><br><span class="line">        <span class="comment">// 指针处理</span></span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: duplicate global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Fun;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(text);</span><br><span class="line">            function_declaration();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current_id-&gt;class = Glo;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(data);</span><br><span class="line">            data += <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用的依旧是<code>lookahead</code>的思想，我们无法根据一个<code>token</code>信息就实现对这一部分的语法功能解析，所以我们需要结合之后的信息，来对定义进行判断。</p>
<p>我们的解释器同时也支持指针类型，我们这里使用<code>type = type+PTR</code>的方式，来表示其包含指针的信息。</p>
<h3 id="enum_declaration">enum_declaration</h3>
<p>主要用来解析用<code>,</code>分隔的变量，这里我们需要注意编译器对枚举变量的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enum_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的枚举变量声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(token!=Num)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 枚举变量赋值错误\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i = token_val;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Num;</span><br><span class="line">        current_id-&gt;type = INT;</span><br><span class="line">        current_id-&gt;value = i++;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数match">辅助函数match</h3>
<p>这里我们使用<code>match</code>来匹配并获取下一个<code>token</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token == tk)&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: 语法错误, 缺少 %c\n&quot;</span>, line, tk);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数定义的解析">函数定义的解析</h3>
<p>我们在先前的函数Id判断中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">current_id[Class] = Fun;</span><br><span class="line">current_id[Value] = (<span class="type">int</span>)(text); </span><br><span class="line">function_declaration();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在确定是函数类型之后，我们开始对函数结构的解析，我们对函数体的解析结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    function_parameters();</span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    function_body();</span><br><span class="line">    <span class="comment">// match(&#x27;&#125;&#x27;);</span></span><br><span class="line">    <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_id-&gt;class==Loc)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span>=</span>current_id-&gt;Bclass;</span><br><span class="line">            current_id-&gt;type=current_id-&gt;Btype;</span><br><span class="line">            current_id-&gt;value=current_id-&gt;Bvalue;</span><br><span class="line">        &#125;</span><br><span class="line">        current_id++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意两个点：</p>
<ul>
<li>一是在对函数体的分析结束之后，不需要<code>match("&#125;")</code>，因为函数体解析的函数会匹配他</li>
<li>二是在函数解析完毕之后，我们需要将用到的token信息还原。这是因为在函数体解析的过程中，同名的局部变量会把原来定义的全局变量信息覆盖。</li>
</ul>
<p>进一步的实现，则分别是对参数和函数体的内容的解析，首先是对参数的解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_parameters</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> params = <span class="number">0</span>;</span><br><span class="line">    type = basetype = INT;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(token==Int) match(Int);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            type = CHAR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数参数声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line"></span><br><span class="line">        current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">        current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">        current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line">        current_id-&gt;value = ++params;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要注意两点，首先是<code>index_of_bp</code>，这个变量用于确定参数在栈上的偏移值，因为从<code>bp</code>到函数传参之间隔着一个返回地址，所以在计算时需要将<code>index_of_bp</code>加一。</p>
<p>其次是，当我们遇到一个Id类型的token，我们将其所有的信息都备份一遍，并且将值赋值为<code>参数的索引</code></p>
<p>然后是对函数体的解析，我们可以进一步分成局部变量声明和语句部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_body</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos_local = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token==Int||token==Char)&#123;</span><br><span class="line">        basetype = (token==Int ? INT : CHAR);</span><br><span class="line">        match(token);</span><br><span class="line">        <span class="keyword">while</span>(token!= <span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            type = basetype;</span><br><span class="line">            <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">                match(Mul);</span><br><span class="line">                type = type + PTR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的局部变量声明\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            match(Id);</span><br><span class="line">            current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">            current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">            current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">            current_id-&gt;type = type;</span><br><span class="line">            current_id-&gt;value = ++pos_local;</span><br><span class="line">            <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = ENT;  <span class="comment">// 函数入口指令</span></span><br><span class="line">    *++text = pos_local; <span class="comment">// 局部变量大小</span></span><br><span class="line">    <span class="comment">// 语句处理</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        statement();</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = LEV;  <span class="comment">// 函数返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分需要注意的就是<code>*++text</code>的含义，相当于我们在栈上为局部变量预留了空间，后面的<code>LEV</code>则是用来返回函数调用。</p>
<p>至此我们对全局变量和函数定义的解析完成了，之后我们将着重实现对语句的实现，并为他们生成可用的字节码指令。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">247k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:57</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
