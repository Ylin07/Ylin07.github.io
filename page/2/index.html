<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/26/67-%E9%93%BE%E6%8E%A5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/26/67-%E9%93%BE%E6%8E%A5-3/" class="post-title-link" itemprop="url">67:链接(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-26 19:10:01" itemprop="dateCreated datePublished" datetime="2025-07-26T19:10:01+08:00">2025-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 13:17:13" itemprop="dateModified" datetime="2025-07-27T13:17:13+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>介绍完了目标文件是怎么链接到可执行程序的，我们不妨进一步学习可执行程序是怎么被加载到内存中并运行的。以及动态链接库是怎么和程序一起被加载的。</p>
<h2 id="可执行目标文件">可执行目标文件</h2>
<p>我们已经学习了链接器是怎么将多个目标文件合并成一个可执行目标文件的。我们的C程序，从一开始的一组ASCII文本文件，被转换成了一个二进制文件。这个二进制文件包含加载程序到内存并运行它所需的所有信息。一个典型的ELF可执行文件有以下内容：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/QkOnFtTLvVGSwC3.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>和可重定位目标文件还是有较大的区别。ELF头描述文件的总体格式。它还包括程序的入口点（entryPoint），也就是当程序运行时要执行的第一条指令的地址。<code>.text .rodata .data</code>节和可重定位目标文件中的节是相似的。此外，还有一个<code>.init</code>节，这个节中定义了一个小函数，叫做<code>_init</code>，程序初始化代码时会调用它。同时，因为可执行文件是完全链接的，所以不再需要<code>rel</code>节</p>
<p>ELF可执行文件被设计的很容易加载到内存中，可执行文件的连续的片被映射到连续的内存段。程序头部表则描述了这种映射关系。我们使用<code>objdump -p</code>来查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只读代码段</span></span><br><span class="line">LOAD off    0x0000000000001000 vaddr 0x0000000000401000 paddr 0x0000000000401000 align 2**12</span><br><span class="line">     filesz 0x000000000007d80d memsz 0x000000000007d80d flags r-x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读/写数据段</span></span><br><span class="line">LOAD off    0x00000000000a4f50 vaddr 0x00000000004a5f50 paddr 0x00000000004a5f50 align 2**12</span><br><span class="line">     filesz 0x0000000000005b60 memsz 0x000000000000b2d8 flags rw-</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>off：</strong>目标文件中的段的第一个节的偏移</li>
<li><strong>vaddr/paddr：</strong>虚拟地址/物理地址（物理地址在现代操作系统中无意义）</li>
<li><strong>align：</strong>指定的对齐要求，使得段能够有效率的传送到内存中</li>
<li><strong>filesz：</strong>目标文件中的段大小</li>
<li><strong>memsz：</strong>内存中的段大小</li>
<li><strong>flags：</strong>运行时的访问权限</li>
</ul>
<p>我们以读写数据段的加载为例。开始于内存地址<code>0xa4f50</code>处，总的内存大小为<code>0xb2d8</code>，于是从目标文件中偏移<code>0xa4f50</code>处开始的<code>.data</code>节中的<code>0x5b60</code>个字节初始化。该段剩下的字节对应于运行时将被初始化为0的<code>.bss</code>数据。</p>
<p>对于任何段s，链接器必须选择一个起始地址<code>vaddr</code>，使得：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vaddr mod align = off mod align</span><br></pre></td></tr></table></figure>
<p>off是段在可执行文件本身的起始位置。根据对齐要求对齐，是为了更好的优化加载的效率。会在虚拟内存中进一步学习。</p>
<h2 id="加载可执行文件">加载可执行文件</h2>
<p>当我们运行一个程序时:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br></pre></td></tr></table></figure>
<p>由于prog不是一个内置的shell命令，所以shell会将它视作一个可执行目标文件，通过调用驻留在存储器中称为<strong>加载器</strong>的操作系统代码来运行它。任何Linux程序，都可以通过调用<code>exevce</code>函数来调用加载器。</p>
<p>记载其将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序到内存并运行的过程叫<strong>加载</strong></p>
<p>为了解释加载器的运行，我们还需要认识以下每个Linux程序的内存映像：</p>
<figure>
<img src="https://s2.loli.net/2025/07/27/XVZWDh7G2uLUdCP.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在LInux
x86_64中，代码段总是从0x400000处开始的，后面是数据段。运行时堆在数据段之后，通过调用用malloc库向上增长。堆之后的区域则是为共享库模块保留的。用户栈是从最大合法与用户地址(2<sup>48</sup>-1)开始的，向低地址处生长。栈上的地址，从2<sup>48</sup>处开始，是为内核中的代码和数据保留的。</p>
<p>不过这只是简图，实际上的内存空间分布略有不同，由于对齐有要求，段之间会有一定的间隙。而且现代编译器使用地址空间布局随机化，使得每次程序运行时这些区域的地址都会改变，但他们的相对位置是不会改变的</p>
<p>当加载器运行时，它会一个内存映像。在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据毒啊。接下来加载器跳转到程序的入口，也就是<code>_start</code>函数的地址。这个函数在系统目标问及那<code>ctrl.o</code>中定义。<code>_start</code>函数调用系统启动函数<code>__libc_start_main</code>，该函数定义在libc.so中。它负责初始化执行环境，调用用户层的main函数，处理main函数的返回值，并在需要时将控制返回给内核。</p>
<p>加载器的具体工作原理实际上涉及到多个方面：进程、虚拟内存、内存映射。我们之后会回头重新理解分析这个过程。</p>
<h2 id="动态链接共享库">动态链接共享库</h2>
<p>静态库仍然面临着几个问题：</p>
<ul>
<li><strong>需要要更新和维护：</strong>这导致一个程序员如果想更新它的程序使用的库的最新版本。那他需要重新显式的链接一遍。</li>
<li><strong>占用较多的空间资源：</strong>我们需要明确计算机中的空间资源始终是稀缺的，我们要尽可能的利用好计算机中的磁盘空间。但是静态链接则不符合这个问题。静态链接将目标模块复制到每一个使用它的目标文件，这就导致一个系统里可能有上百个这个目标模块。</li>
</ul>
<p>为了解决这个问题，我们就要引入<strong>共享库</strong>的概念。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>，由一个叫做动态链接器的程序来执行，共享库也被称为共享目标，在LInux中以<code>.so</code>表示，在Windows中以<code>.dll</code>来表示</p>
<p>我们可以尝试构建一个动态链接库并使用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o libtest.so -fpic -shared addvec.c multvec.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fpic指示编译器生成位置无关代码	-shared指示链接器创建一个共享的目标文件</span></span><br><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog main.c ./libtest.so</span><br></pre></td></tr></table></figure>
<p>共享库的共享方式和静态库不同。在任何给定的文件系统中，对于一个库只有一个<code>.so</code>文件，所有引用这个库的可执行程序，共享这个文件中的数据和代码。在内存中，一个共享库的.text节的副本，可以被不同的正在要运行的进程共享。我们会在之后详细的研究这个过程。动态链接的过程如下:</p>
<figure>
<img src="https://s2.loli.net/2025/07/27/pvoukltrQNM4agO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当加载器加载和运行可执行文件prog时，加载器注意到prog中包含一个<code>.interp</code>节，这一节包含动态链接器的路径名，动态链接器本身就是有一个共享目标（ld-linux.so）。加载器不会直接将控制传递给应用程序，而是加载和运行这个动态链接器。然后动态链接器通过执行下面的重定位完成链接任务：</p>
<ul>
<li>重定位<code>libc.so</code>的文本和数据到某个内存段</li>
<li>重定位<code>libtest.so</code>的文本和数据到另一个内存段</li>
<li>重定位prog中所有堆由<code>libc.so</code>和<code>libtest.so</code>定义的符号的引用</li>
</ul>
<p>最后动态链接器将控制传递给应用程序。此时共享库的位置就固定了，在程序执行的过程中不再改变。</p>
<h2 id="从应用程序中加载和链接共享库">从应用程序中加载和链接共享库</h2>
<p>正常情况下，我们的动态链接是在程序加载之后，执行之前进行的。可是在一些特殊的情况下，我们需要在运行的过程中（比如热更新、插件拓展…）动态链接共享库。此时我们可以用到LInux系统为动态链接器提供的接口——允许应用程序在运行是加载和链接共享库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfnc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flag)</span>;	</span><br><span class="line"><span class="comment">// 成功则返回指向句柄的指针，失败则返回NULL</span></span><br><span class="line"><span class="comment">// dlopen函数用来将共享库映射到内存，如果在编译时设置了 -rdynamic 那么当前可执行文件里的全局符号也可以被共享库使用。此外，RTLD_GLOBAL 设置可以让此次打开的库里的符号能被后续加载的库使用。RTLD_NOW和RTLD_LAZY分别时立即解析和延迟解析。他们可以通过|和RTLD_GLOBAL拼接</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">dlsym</span><span class="params">(<span class="type">void</span>* handle, <span class="type">char</span>* symbol)</span>;</span><br><span class="line"><span class="comment">// 若成功则返回指向符号的指针，失败则返回NULL</span></span><br><span class="line"><span class="comment">// dlsym的输入是一个指向前面已经打开了的共享库的句柄和一个symbol的名字</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span>* handle)</span>;</span><br><span class="line"><span class="comment">// 如果成功返回0，失败则返回-1</span></span><br><span class="line"><span class="comment">// 如果没有其他共享库还在使用这个共享库，就关闭它</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 如果前面的几个函数的调用失败，则为错误信息。如果调用成功，则为NULL</span></span><br><span class="line"><span class="comment">// dlerror会返回有一个字符串，它描述调用时发生的最近的错误</span></span><br></pre></td></tr></table></figure>
<p>我们可与尝试编写一个程序来在运行过程中加载我们的共享库，然后调用它的<code>addvec</code>例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">void</span>* handle;</span><br><span class="line">	<span class="type">void</span> (*addvec)(<span class="type">int</span>*,<span class="type">int</span>*,<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line">	<span class="type">char</span>* error;</span><br><span class="line"></span><br><span class="line">	handle = dlopen(<span class="string">&quot;./libtest.so&quot;</span>,RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addvec = dlsym(handle,<span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,error);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addvec(x,y,z,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d %d %d %d]&quot;</span>,z[<span class="number">0</span>],z[<span class="number">1</span>],z[<span class="number">2</span>],z[<span class="number">3</span>],z[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(dlclose(handle)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后可以正常运行！我们简单的实现了运行过程中动态库的加载和更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/66-%E9%93%BE%E6%8E%A5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/66-%E9%93%BE%E6%8E%A5-2/" class="post-title-link" itemprop="url">66:链接(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-21 20:08:23" itemprop="dateCreated datePublished" datetime="2025-07-21T20:08:23+08:00">2025-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-26 15:04:19" itemprop="dateModified" datetime="2025-07-26T15:04:19+08:00">2025-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来我们要探讨学习一下<strong>符号解析</strong>和<strong>重定位</strong>实现的原理。</p>
<h2 id="符号解析">符号解析</h2>
<p>连接器解析符号引用，实际上就是将每个引用，和它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。当局部符号的引用和引用定义在相同模块的时候，符号解析简单明了。编译器只允许每个模块中每个局部符号只有一个定义，因此编译器要确保它们又唯一的名字。</p>
<p>不过，对于全局符号的引用解析就十分难以处理。当编译器遇到一个不是在当前模块定义的符号时，会假设这个符号已经被其他模块定义了，生成一个链接器符号表条目，将它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就会报错。比如我们尝试编译这个程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	foo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会毫无障碍的编译，但是链接器却无法解析对foo的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc test.c -o test -Wall -Og</span><br><span class="line">/usr/bin/ld: /tmp/ccKOmx5V.o: in function `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.c:(.text+0xe): undefined reference to `foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因此对于全局符号的处理比较困难，而且可能会出现多个目标文件定义相同名字的全局符号。此时，链接器要么选出一个定义抛弃其他定义，要么就给出一个错误。</p>
<h3
id="链接器如何解析多重定义的全局符号">链接器如何解析多重定义的全局符号</h3>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有的是局部的（只对本地模块可见），有的是全局的（对其他模块也可见）。但是如果多个模块的定义了同名的全局符号，Linux编译系统会怎么做？</p>
<p>在编译时，编译器向汇编器输出每个全局符号，或是强或是弱，而汇编器把这个信息隐含地编码在可重定位的目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>
<p>Linux链接器会根据以下规则来处理多重定义的符号名：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li>
</ul>
<p>我们可以看下各个规则的具体表现：</p>
<ul>
<li><strong>规则一</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">/usr/bin/ld: /tmp/ccYSd6rb.o: in function `main&#x27;:</span><br><span class="line">2.c:(.text+0x0): multiple definition of `main&#x27;; /tmp/ccogxBxO.o:1.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>这是因为强符号<code>main</code>被定义了多次，造成了冲突。下面也是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">514</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">/usr/bin/ld: /tmp/cc9GFQfr.o:(.data+0x0): multiple definition of `x&#x27;; /tmp/ccljmBRr.o:(.data+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>这里是因为被初始化的全局变量（强符号）<code>x</code>出现了多次，造成冲突。</p>
<ul>
<li><strong>规则二</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">514</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br><span class="line">514</span><br></pre></td></tr></table></figure>
<p>这里虽然没有造成冲突，但是可以看到另一个模块对x的使用，修改了它的值。</p>
<ul>
<li><strong>规则三</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">114</span>;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">514</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br><span class="line">514</span><br></pre></td></tr></table></figure>
<p>结果和上面基本一致，但是我们并不知道最终使用了哪个符号，因为它们都是弱符号，是随机的。</p>
<p>当然现代的编译器为了避免多重定义的全局符号给我们带来的错误，往往在编译时，会开启<code>GCC-fno-common</code>选项，以保证遇到多重定义的全局符号时，会发生错误，无法通过链接。</p>
<p>在上一篇中我们提到了编译器会按规则将符号分配到<code>COMMON</code>或<code>.bss</code>，但是我们并不清楚为什么要这样做。现在我们知道了，在编译器翻译一个模块时，对于一个弱全局符号，它并不知道其他模块是否也定义了相同的符号。如果是的话，它无法预测链接器会使用多重定义中的哪一个，所以编译器将它这个弱全局符号放入COMMON中，交给链接器来决定。如果这个符号被初始化为0的话，那么它就是一个强符号，编译器就可以直接将它分配为<code>.bss</code>。相似的，对于静态变量(不用考虑多重定义)，也是如此放入<code>.bss</code>或<code>.data</code>。</p>
<h3 id="与静态库链接">与静态库链接</h3>
<p>到目前为止，我们都是假设链接器会读取一组可重定位目标文件，并将其链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都支持一种机制——把所有相关的目标模块打包成为一个单独的文件，被称为<strong>静态库</strong>。当链接器要构造一个输出的可执行文件时，它只会复制静态库中被程序引用的目标模块。这么做有以下好处：</p>
<ul>
<li>如果将模块合并到一个可重定位目标文件中，会导致程序每次链接都会包含一份完整的标准库。其中大部分的模块并不会被使用，这导致程序占用的磁盘空间会更大。</li>
<li>如果将标准函数内联至编译器，这虽然很便捷。但是会导致编译器开发的难度更大。且每次标准库的更新都需要修改编译器</li>
<li>如果为每个标准函数都创建一个独立的可重定位文件，将他们放在一个目录下。这会导致链接时需要大量的显式链接合适模块到可执行文件中。</li>
</ul>
<p>所以链接库的概念被提出来。相关的函数可以被编译为独立的目标模块然后封装在一个单独的静态库文件。然后应用程序可以在命令行中指定单独的文件名字来使用这些在库中定义的函数。</p>
<p>在链接时，链接器将只复制被程序引用的模块，这就减少了可执行文件在磁盘和内存中的大小。且减少了程序员对库文件引用次数。</p>
<p>在Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件时一组连接起来的可重定位目标文件集合，它的头部来描述每个成员目标文件的大小和为止。存档文件的后缀为<code>.a</code></p>
<p>我们可以简单的实现一下这个过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addvec.c</span></span><br><span class="line"><span class="type">int</span> addcnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span>*x,<span class="type">int</span>*y,<span class="type">int</span>*z,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    addcnt++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//multvec.c</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span>*x,<span class="type">int</span>*y,<span class="type">int</span>*z,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    multvec++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        z[i] = x[i]*y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用这两个函数创建一个静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -c addvec.c multvec.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">addvec.c  addvec.o  multvec.c  multvec.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ar rcs libtest.a addvec.o multvec.o</span><br></pre></td></tr></table></figure>
<p>然后我们可以利用这个静态库来编写我们的程序，来验证是否只调用了我们需要的目标模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span>	<span class="comment">//包含两个函数的原型</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> y[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> z[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        multvec(x,y,z,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d %d %d]&quot;</span>,z[<span class="number">0</span>],z[<span class="number">1</span>],z[<span class="number">2</span>],z[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc -static -o prog main.o -L . -ltest</code>编译（其中<code>-static</code>是静态链接，<code>-L</code>指定静态库的查询目录，<code>-ltest</code>是<code>./libtest.a</code>的缩写），我们使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ objdump -d prog | grep &quot;addvec&quot;</span><br></pre></td></tr></table></figure>
<p>发现程序中并没有<code>addvec目标模块</code>，静态库的链接很好的完成了工作。整个过程我们可以用这个图来大致的表现。</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/iWRXFasmOHUq76P.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3
id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用</h3>
<p>解释一下静态库使用的原理和可能遇到的一些问题。</p>
<p>Linux链接器在解析外部引用的时候，是从左往右按照编译器驱动程序命令行上的顺序来扫描，可重定位目标文件和存档文件（驱动程序会自动将源程序文件翻译成可重定位目标文件）。在扫描中，链接器会维护一个可重定位目标文件中的集合E(该集合文件中的目标文件会被链接成可执行文件)，一个未解析的符号集合U（引用了但是尚未定义的符号），一个在前面的输入文件中已定义的符号集合D。初始时，E、U、D均为空：</p>
<ul>
<li>对于命令行上的每个输入文件<code>f</code>，链接器会判断它的类型，是目标文件还是存档文件。如果是目标文件，则将其放入E中，然后修改U和D来反映<code>f</code>中符号定义和引用，并继续下一个输入文件。</li>
<li>如果<code>f</code>是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且修改U和D来反映m的符号定义和引用。对存档文件中的每一个程序进行这个尝试，知道U和D都不再变化。此时不包含在E中的目标文件被丢弃。开始处理下一个输入文件。</li>
<li>如果链接器处理完所有的输入文件之后，U是非空的，链接器就会输出一个错误并停止。反之，则合并重定位E中的目标文件，构建输出的可执行文件。</li>
</ul>
<p>不过因此，命令行上的库和目标文件的顺序也很重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不会被解析，链接会失败。对于存档文件之间的顺序也是如此。如果一个库a中的引用在另一个库b中被定义，那么要先a后b。反之，如果库直接都是相互独立的，就可以不在乎输入顺序。</p>
<h2 id="重定位">重定位</h2>
<p>当链接器完成了符号解析，代码中的每个符号引用和它的符号定义（即目标模块中的符号表条目）就会被关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以重定位操作了，在这个步骤中，将合并输入模块，并为每个符号分配运行时的地址。</p>
<ul>
<li><p><strong>重定位节和符号定义:</strong></p>
<p>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给每个节的每个符号。当这一步完成时。程序中的每条指令和全局变量都有唯一的运行时内存地址。</p></li>
<li><p><strong>重定位节中的符号引用：</strong></p>
<p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时的地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构，我们接下来将会描述这种数据结构。</p></li>
</ul>
<h3 id="重定位条目">重定位条目</h3>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码在运行时会被存放在内存中的哪个位置。也不知道模块引用的外部定义的函数或全局变量的位置在哪里。所以，当汇编器遇到最终位置未知的目标引用，他就会生成一个重定位条目（用来为链接器修正未知提供“导航”），用来告诉链接器，在合并目标模块时如何修改这个引用。代码的重定位条目存放在<code>.rel.text</code>，数据的重定位条目存放在<code>.rel.data</code></p>
<p>下面是一个典型的重定位条目格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,</span><br><span class="line">    	symbol:<span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> addend;</span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>offset：</strong>需要被修改的引用的节偏移</li>
<li><strong>type：</strong>如何修改新的引用</li>
<li><strong>symbol：</strong>被修改的引用应该指向的符号</li>
<li><strong>addend：</strong>一个有符号常数，个别类型的重定位需要使用它对被修改引用的值做偏移调整</li>
</ul>
<p>ELF定义了32中不同的重定位类型，但是我们需要考虑两种最常见的类型：</p>
<ul>
<li><p><strong>R_X86_64_PC32：</strong></p>
<p>重定位一个使用32位PC相对地址的引用。一个PC相对地址就是据PC当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，他就将在指令中编码的32位值加上当前的PC值，得到<strong>有效地址</strong>，PC值通常是下一条指令在内存中的地址</p></li>
<li><p><strong>R_X86_64_32:</strong></p>
<p>重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址</p></li>
</ul>
<h3 id="重定位符号引用">重定位符号引用</h3>
<p>根据重定位算法，来分析一下重定位的过程。下面展示重定位算法的伪代码，为了方便表示，假设每个节s是一个字节数组，每个重定位条目r都是一个类型为Elf64_Rela的结构。用<code>ADDR()</code>来获取对应的运行时的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (section:s)&#123;</span><br><span class="line">    <span class="keyword">for</span> (relocation_entry:r)&#123;</span><br><span class="line">        refptr = s + r.offset;	<span class="comment">//重定位编码的地址</span></span><br><span class="line">        <span class="comment">//相对PC地址引用</span></span><br><span class="line">        <span class="keyword">if</span>(r.type == R_X86_64_PC32)&#123;</span><br><span class="line">            refaddr = <span class="built_in">ADDR</span>(s) + r.offset;	<span class="comment">//运行时的待重定位地址</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(<span class="built_in">ADDR</span>(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//绝对PC地址引用        </span></span><br><span class="line">        <span class="keyword">if</span>(r.type == R_X86_64_32)</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(<span class="built_in">ADDR</span>(r.symbol) + r.addend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下面这个反汇编代码为例，我们来分析一下链接器是怎么重定位这些引用的：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/i61CN8W5OpJQLR4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="重定位pc相对引用">重定位PC相对引用</h4>
<p>第6行，call开始于节偏移值为<code>0xe</code>的地方，包括1字节的操作码<code>0xe8</code>，还有四个字节的占位符。其中sum的重定位条目r为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = <span class="built_in">sum</span></span><br><span class="line">r.<span class="built_in">type</span> = R_X86_64_PC32</span><br><span class="line">r.addend = -<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器修改开始于偏移量<code>0xf</code>的32位PC相对引用，在运行时它会指向sum例程。此时链接器已知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = <span class="number">0x4004d0</span></span><br><span class="line">ADDR(r.symbol) = ADDR(<span class="built_in">sum</span>) = <span class="number">0x4004e8</span></span><br></pre></td></tr></table></figure>
<p>我们重定位的过程应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">    	= <span class="number">0x4004d0</span> + <span class="number">0xf</span></span><br><span class="line">    	= <span class="number">0x4004df</span></span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x4004e8</span> + (<span class="number">-4</span>) - <span class="number">0x4004df</span>)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x5</span>)</span><br></pre></td></tr></table></figure>
<p>最终得到<code>4004de: e8 05 00 00 00  callq 4004e8 &lt;sum&gt;</code></p>
<h4 id="重定位绝对引用">重定位绝对引用</h4>
<p>第4行，mov开始于节偏移值位<code>0x4</code>的地方，包括1字节的操作码<code>0xbf</code>，还有四个字节的arrary地址的占位符。其中array的重定位条目r为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span></span><br><span class="line">r.symbol = array</span><br><span class="line">r.<span class="built_in">type</span> = R_X86_64_32</span><br><span class="line">r.addend = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器要修改从偏移量<code>0xa</code>开始的绝对引用，这样在运行时它会指向arrary的第一个字节。此时链接器已知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDR(r.symbol) = ADDR(array) = <span class="number">0x601018</span></span><br></pre></td></tr></table></figure>
<p>我们重定位的过程为是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend)</span><br><span class="line">     	= (<span class="type">unsigned</span>) (<span class="number">0x601018</span> + <span class="number">0</span>)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x601018</span>)</span><br></pre></td></tr></table></figure>
<p>最终得到<code>4004d9: bf 18 10 60 00  mov $0x601018,%edi</code>。最终的效果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/YIWXe4917imDMgn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/65-%E9%93%BE%E6%8E%A5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/65-%E9%93%BE%E6%8E%A5-1/" class="post-title-link" itemprop="url">65:链接(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-21 10:52:19 / 修改时间：16:39:47" itemprop="dateCreated datePublished" datetime="2025-07-21T10:52:19+08:00">2025-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始学习新的章节——链接。我们现在要研究在gcc调用的过程中，到底有哪些过程是被我们所忽略的，在编译的过程中它们又有着什么作用呢？</p>
<h2 id="编译器驱动程序">编译器驱动程序</h2>
<p>我们以下面的这段代码为例，将以此来分析整个编译的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数编译系统都会提供一个编译驱动程序，在用户需要时调用语言处理器，编译器，汇编器，链接器。比如我们要用GNU编译系统进行编译时，我们就需要使用<code>gcc</code>编译驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -Og -o test main.c sum.c</span><br></pre></td></tr></table></figure>
<p>但是实际上省略了很多中间过程并没有让我们看到，我们可以通过加入<code>-v</code>参数来观察这个过程：</p>
<figure>
<img src="https://s2.loli.net/2025/07/21/lQcAwLsiMN4v2zm.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>红色框出来的分别时<code>ccl as ld</code>的调用，我们之后会分析这几个程序的作用。现在我们可以将从ASCIII源码到执行文件的编译驱动的过程总结一下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/21/Sdly6v84LWu1JTX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>首先预处理器cpp(预处理器实际上和编译器是集成在一起的)将ASCII源文件翻译成一个ASCII码的中间文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ cpp main.c -o main.i</span><br></pre></td></tr></table></figure>
<p>然后驱动程序运行C编译器ccl（这里我们使用gcc实现），将中间文件翻译成汇编语言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -S main.i</span><br></pre></td></tr></table></figure>
<p>接着驱动程序运行汇编器as，将main.s翻译成一个可重定位目标文件main.o:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ as main.s -o main.o</span><br></pre></td></tr></table></figure>
<p>然后对sum.c进行同样的操作，得到sum.o。然后驱动程序运行链接器程序ld（在<code>gcc -v</code>的过程中可以看到链接过程使用的是collect2，实际上是ld的封装用法），将main.o和sum.o以及一些必要的系统目标文件编译起来，创建一个可执行的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ld -o test sum.o main.o</span><br></pre></td></tr></table></figure>
<p>最后当我们执行编译出来的<code>test</code>程序时，shell会调用一个名为加载器loader的函数，将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ./test</span><br></pre></td></tr></table></figure>
<p>不过实际上，这些中间过程是被什么略的，其中生成的中间文件会被存放在<code>\tmp</code>下，待编译结束后被清理。</p>
<h2 id="静态链接">静态链接</h2>
<p>像<code>ld</code>这样的静态连接器以一组可重定位目标文件个命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输出的可重定位目标文件由各种不同的代码和数据节<code>section</code>组成，每一节都是一个连续的字节序列。指令在一个节中，初始化了的全局变量在另一个节中，而未初始化的变量又在另一个节中…</p>
<p>为了构建一个可重定位文件，链接器要实现一下的功能：</p>
<ul>
<li><p><strong>符号解析：</strong></p>
<p>目标文件会定义和引用符号。每个符号可能对应一个全局变量、一个函数或一个静态变量（static声明的变量），符号解析则是将每个符号的引用和它的定义联系起来。</p></li>
<li><p><strong>重定位：</strong></p>
<p>编译器和汇编器会生成从地址0开始的代码和数据节。链接器通过把每个符号的定义和一个内存位置关联起来，从而重定位这些节，然后修改这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位信息条目的详细指令给，进行这些重定位操作</p></li>
</ul>
<p>之后我们会详细的分析这几个过程。实际上我们只需要清除，目标文件实际上就是字节块的集合。这些块中，有的包含程序代码，有的包含程序数据，其他的则包含引到链接器和加载器的数据结构。链接器负责将这些块连接起来，确定被连接块的运行时的位置，并且修改代码和数据块中的各种位置。</p>
<h2 id="目标文件">目标文件</h2>
<p>目标文件有三种形式：</p>
<ul>
<li><p><strong>可重定位目标文件：</strong></p>
<p>主要包含二进制代码和数据，其形式可以在链接时与其他的可重定位目标文件合并起来，创建一个可执行目标文件。</p></li>
<li><p><strong>可执行目标文件：</strong></p>
<p>包含二进制代码和数据，其形式可以直接被复制到内存中并执行。</p></li>
<li><p><strong>共享目标文件：</strong></p>
<p>一种特殊类型的可重定位目标文件，可以在加载或者运行时，被动态地加载进内存并链接。</p></li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。</p>
<p>从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存储在磁盘中的目标模块。本质上它们是一样的。</p>
<p>不同的系统有不同的目标文件格式，如：</p>
<ul>
<li>Unix ：a.out格式</li>
<li>Windows ：可移植可执行格式（PE）</li>
<li>Mac ：Mach-O格式</li>
<li>现代Linux/Unix ：可执行可链接格式（ELF）</li>
</ul>
<h2 id="可重定位目标文件">可重定位目标文件</h2>
<figure>
<img src="https://s2.loli.net/2025/07/21/SGLuOf3gCEZp4Bc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是一个典型的ELF可重定位目标文件的格式。我们从ELF头开始说起，我们可以使用<code>readelf -h</code>来获取一个程序的ELF头信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ readelf -h test</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1040</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14016 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure>
<p>以一个16字节长的字节序列Magic开始，这个序列用于系统判断是否为ELF文件格式（字节序和位宽），ELF头的其他部分则包含了帮链接器语法分析和解释目标文件的信息。其中包括</p>
<ul>
<li>ELF头的大小 –&gt; Size of this header</li>
<li>目标文件的类型 –&gt; Type</li>
<li>机器类型 –&gt; Machine</li>
<li>节头部表的文件偏移 –&gt; Start of section headers</li>
<li>节头部表条目的大小和数量 –&gt; Number of section headers + Size of
section headers</li>
</ul>
<p>不同节的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定的条目（entry）。夹在ELF头和节头部表中间的都是节。一个典型的ELF可重定位目标文件包含以下的节：</p>
<ul>
<li><p><strong>.text</strong></p>
<p>已编译程序的机器代码</p></li>
<li><p><strong>.rodata</strong></p>
<p>只读数据(常量数据，运行期间不可更改)</p></li>
<li><p><strong>.data</strong></p>
<p>已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，不被保存在节</p></li>
<li><p><strong>.bss</strong></p>
<p>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据任何实际的空间，仅仅是一个占位符。区分已初始化和未初始化是为了空间效率，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0</p></li>
<li><p><strong>.symtab</strong></p>
<p>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。和使用<code>-g</code>编译出的程序得到的符号表信息不同，<code>.symtab</code>中不包含局部变量的条目</p></li>
<li><p><strong>.rel.text</strong></p>
<p>重定位节。一个<code>.text</code>节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。这个时候<code>.text</code>中有哪些地址/符号需要在链接或加载时被修正的内容，就记录在<code>.rel.text</code>中。</p></li>
<li><p><strong>.rel.data</strong></p>
<p>数据的重定位节。记录<code>.data</code>中哪些变量/指针需要链接器修改地址</p></li>
<li><p><strong>.debug</strong></p>
<p>调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有在使用gcc时加上<code>-g</code>选项，才可以得到这张表</p></li>
<li><p><strong>.line</strong></p>
<p>原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有使用<code>-g</code>时得到。</p></li>
<li><p><strong>.strtab</strong></p>
<p>一个字符串表，内容包括其他节中的字符串信息。它自己不包含逻辑结构，只是被其他节按索引引用，用来存放符号名，段名，动态库名等文本。因此其他节只需要存放对应字符串的偏移索引就行了，真正的字符内容放在<code>.strtab</code>.</p></li>
</ul>
<h2 id="符号和符号表">符号和符号表</h2>
<h3 id="符号">符号</h3>
<p>每个可重定位模块m都有一个符号表，它包含m定义和引用的符号的信息。在连接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块引用的<strong>全局符号</strong>。全局符号对应于非静态的C函数和全局变量。</li>
<li>由其他模块定义并被模块m引用的全局符号，称之为<strong>外部符号</strong>，对应于在其他模块中定义的非静态C函数和全局变量</li>
<li>只被模块m定义和引用的<strong>局部符号</strong>。它们对应于带<code>static</code>属性的C函数和全局变量。这些符号在模块m中任何位置可见但是，不能被其他模块引用。</li>
</ul>
<p>链接器不关心本地局部变量。同样的<code>.symtab</code>中的符号表也不包含对应于本地非静态程序变量的任何符号。这些符号在运行时由栈管理。不被链接器考虑。</p>
<p>不过定义为带有C<code>static</code>属性的本地过程变量时不在栈中管理的（使用static属性可以隐藏模块内部的变量和函数声明，就像class中使用private，来保护变量和函数只能被本地模块使用）。相反，编译器在<code>.data</code>或<code>.bss</code>中会为每个定义分配空间，并在符号表中创建一个有唯一名字的本地连接符号。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会向汇编器输出两个不同名字的局部链接符号。比如，可以用<code>x.1</code>表示函数f中的定义，用<code>x.2</code>表示函数g中的定义。</p>
<h3 id="符号表">符号表</h3>
<p>符号表是由汇编器构造的，使用的是编译器给出的符号。ELF符号表被存放在<code>.symtab</code>中。这个符号表包含着一个<strong>条目</strong>的数组，其条目结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> name;			</span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>;		</span><br><span class="line">    	 binding:<span class="number">4</span>;		</span><br><span class="line">    <span class="type">char</span> reversed;		</span><br><span class="line">    <span class="type">short</span> section;		</span><br><span class="line">    <span class="type">long</span> value;			</span><br><span class="line">    <span class="type">long</span> size;			</span><br><span class="line">&#125;ELF64_symbol;</span><br></pre></td></tr></table></figure>
<p>它们的作用分别是：</p>
<ul>
<li><strong>name：</strong>字符串表中的字节偏移，指向符号的字符串名字</li>
<li><strong>type：</strong>表示符号的种类（数据/函数）</li>
<li><strong>binding：</strong>表示符号的可见性（本地/全局）</li>
<li><strong>reverse：</strong>暂时无用，留作数据对齐。</li>
<li><strong>section：</strong>节头部表的索引，用于定位节</li>
<li><strong>value：</strong>指定节中的偏移，相当于一个绝对运行时的地址</li>
<li><strong>size：</strong>目标的大小（字节大小）</li>
</ul>
<p>每个符号都会被分配到目标文件的某个节中。由<code>section</code>字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节，它们在节头部表中并没有条目：</p>
<ul>
<li>ABS，表示符号值是绝对的，不应该被重定位</li>
<li>UNDEF，表示符号未定义，就是在本模块中使用，但是在其他地方定义的符号。</li>
<li>COMMON，表示未被分配位置的未初始化的数据目标 &gt;
只有在可重定位目标文件中才有伪节，可执行目标文件中没有</li>
</ul>
<p>对于COMMON符号，value给出的是对齐要求，size给出的是最小的大小。</p>
<p>这么一看COMMON和<code>.bss</code>似乎差不多。现代的汇编器根据以下规则来将符号分配到COMMON和<code>.bss</code>中：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMON  未初始化的全局变量</span><br><span class="line">.bss	未初始化的静态变量，以及初始化为<span class="number">0</span>的全局变量和静态变量</span><br></pre></td></tr></table></figure></p>
<p>之后我们会详细解释这个设置的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/64-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/64-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">64:存储器层次结构与性能利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-18 20:13:30" itemprop="dateCreated datePublished" datetime="2025-07-18T20:13:30+08:00">2025-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-21 16:43:16" itemprop="dateModified" datetime="2025-07-21T16:43:16+08:00">2025-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">存储器层次结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们学习一下现代计算机中的存储器架构，以及它的一些具体实现。我们该如何利用存储器的性能来实现对局部性的高效利用？它背后的原理又是什么呢？</p>
<h2 id="存储器存储结构">存储器存储结构</h2>
<p>不同的存储器有着不同的存储技术和存储性能，可喜的是，它们的属性很好的互相补齐各自的不足，利用这个性质，出现了一种组织存储器系统的方法，称之为存储器层次结构。</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/3uLzemwU7fWyakJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从高层往底层走，存储器的容量、成本、速度都越来越慢。所以我们以下面为基础，不断的向上层提供数据。其中我们就不得不提到存储器结构中最为关键的
<strong>缓存</strong></p>
<h3 id="缓存">缓存</h3>
<p>存储器之间的属性有着较大的差异，通常我们需要在其之间设置一个缓冲，以更好的实现数据的读取和转移。其中，<strong>高速缓存</strong>就是一种小而迅速的存储设备，它作为更大、更慢的存储器设备的数据的缓存区域。而使用高速缓存的过程我们就称之为<strong>缓存</strong>。缓存的基本原理如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/xz59LVFONkpycWg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于缓存，我们还要理解它的各个状态：</p>
<h4 id="缓存命中">缓存命中</h4>
<p>当程序需要k+1层的某个数据对象d时，它首先到k层中去查找，如果找到了，则此时数据d<strong>缓存命中</strong>。</p>
<h4 id="缓存不命中">缓存不命中</h4>
<p>相反，如果k层没有找到数据d时，我们则发生<strong>缓存不命中</strong>。此时k层的缓存从第k+1层中取出包含d的块。如果此时k层的缓冲已经满了，就会覆盖其中的一个块，这个过程叫做替换/牺牲。具体替换哪个块由替换策略所决定。</p>
<h4 id="缓存不命中的状态">缓存不命中的状态：</h4>
<ul>
<li>强制不命中（冷不命中）：此时缓存为空，无论什么数据都不会命中。</li>
<li>容量不命中：当前的工作集的大小大于缓存的大小。</li>
<li>冲突不命中：有些替换策略会将符合同一规则的块指定替换到上层换从中的指定块，这种策略比较简洁容易实现。此时就可能会出现同组的块互相冲突。类似于哈希表中的哈希冲突。</li>
</ul>
<p>存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。所以在每一层中，都需要有某种形式的逻辑来管理缓存（将缓存分块，在不同层之间传送块，判定是否命中，并处理它们），不论是硬件还是软件。下面有一张表，大致的说明了各个缓存的管理实现：</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/Fa1w6TYjCsQM3h9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="高速缓存存储器">高速缓存存储器</h3>
<p>为了更好的理解存储器缓存的原理，我们需要介绍一下高速缓存存储器的组织架构。</p>
<p>计算机的地址数量通常由存储器的位数所决定，当存储器的位数为m时，计算机的内存空间就有2<sup>m</sup>个地址。而高速缓存存储器的结构如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/1VcKdQSgRA7W3CT.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>一个高速缓存存储器被分作S(2<sup>s</sup>)个高速缓存组，每个高速缓存组有E个高速缓存行，每个高速缓存行中有B(2<sup>b</sup>)个数据块。我们通过对地址字段进行划分，从而实现对高速缓存的定位。</p>
<p>当我们拿到一个地址，想要尝试从高速缓存存储器中取出一个数据块时，都要经历以下过程：</p>
<ul>
<li><strong>读组索引：</strong>根据地址中的s位的数据来确定数据所在的缓存组</li>
<li><strong>标记比对：</strong>当数据行有效时，与其比较t位标记值，如果标记相同则确定数据存储行。</li>
<li><strong>读块索引：</strong>根据地址中的b位数据确定数据在缓存块中的偏移地址。</li>
<li><strong>缓存不命中：</strong>则重复上述的步骤向下取需要的数据。</li>
</ul>
<p>你可能会好奇，为什么使用中间的几位作为组索引，而不是高位呢？这是为了避免高位的一致性从而导致连续的内存空间被分配到一个组，从而引发冲突不命中，下图很好的说明了这一点：</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/63JE5yiz9P7Wlun.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>同时，根据每个组的高速缓存行的数量，也可以分成以下高速缓存存储器类型：</p>
<ul>
<li><p><strong>直接映射高速缓存</strong></p>
<p>E=1，每组高速缓存行只有一行，所以不需要再组中查找对应的缓存行，且实现起来比较简单。但是对于冲突不命中的应对上效果很差，因为每个组只能取一条数据。</p></li>
<li><p><strong>全相联高速缓存</strong></p>
<p>S = 0，E =
C/B。所有的缓存行都存储在一个组中，由于没有固定的映射关系，所以任何主存块可以存储在缓存的任何位置。灵活性很高，很好的避免了冲突的关系。但是由于结构复杂，且每次访问时，需要匹配缓存行，消耗了大量的时间，访问速度慢。</p></li>
<li><p><strong>组相联高速缓存</strong></p>
<p>相当于直接映射和全相联的中和版本。每个组有一定的缓存行。</p></li>
</ul>
<h4 id="高速缓存层次结构分析">高速缓存层次结构分析</h4>
<p>我们给出一个真实的高速缓存层次结构</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/eRbqK4Nzot6y2Gj.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实际上高速缓存存储器不仅存储数据，同时存储着指令，只不过指令是只读的，数据则可读可写。芯片上的每个核有着自己的高速缓存，同时共享一个高速缓存和主存。在复杂的资源共享管理下，实现工作</p>
<h4 id="高速缓存参数的性能影响">高速缓存参数的性能影响</h4>
<p>定性的分析高速缓存的影响参数：</p>
<ul>
<li><p><strong>高速缓存大小</strong></p>
<p>较大的高速缓存可以提高缓存的命中率，但也意味着会造成更大的运行开销，这也是为什么越上层的存储器越小，这可以减少访问的时间。</p></li>
<li><p><strong>块大小</strong></p>
<p>大的块可以更好的利用程序中的空间局部性。但是在缓存空间给定的情况下，较大的块会导致较少的缓存内存行，会加剧数据冲突。从而导致时间局部性所受到的损耗大于空间局部性带来的好处。</p></li>
<li><p><strong>相联度</strong></p>
<p>即高速缓存行数E的选择，较高的相联度可以减少冲突不命中导致的不命中处罚，但是访问速度低，而且较大的块也会导致更严重的不命中处罚。而较低的相联度虽然访问速度快，但是也会导致更多的不命中处罚。所以需要根据不同的情况选择不同的相联度。</p>
<p>在L1中，通常使用相联度低的存储方式，因为不命中的处罚较小（数据较少）。但是对于底层的主存等区域，每次不命中的处罚很严重，所以要提高相联度，尽可能的减少不命中。</p></li>
<li><p><strong>写策略</strong></p>
<p>直写（立即将高速缓存块写入第一层的存储器中）比较容易实现，而且可以使用写缓冲区进行内存更新，但是会导致总线的流量增大。写回（尽可能的推迟更新，只有该块被替换的时候才将数据块更新到第一层的存储器中）引起的传送会更少。此外，越往底层走，传送的时间更长。所以在下层，会尽可能的使用写回。</p></li>
</ul>
<h2 id="局部性">局部性</h2>
<p>一个具有良好局部性的程序，通常会有着更好的效率。它们倾向于使用离它们较近的数据项，或是最近引用过的数据项，这被称为局部性原理。</p>
<p>局部性别分为<strong>空间局部性</strong>和<strong>时间局部性</strong>。对于一个良好的时间局部性程序，被引用过一次的内存位置会在不久后再次被引用。对于一个良好的空间局部性程序，如果一个内存位置被使用，那么它领近的内存位置也会被使用。</p>
<h3 id="对程序数据引用的局部性">对程序数据引用的局部性</h3>
<p>我们以一个简单的程序为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于sum，由于它在每次迭代中都被使用，所以我们称它有良好的时间局部性，但是它是一个标量，所以不存在空间局部性。对于向量v，它是被顺序读取的，所以我们称它有良好的空间局部性，但是由于每个位置只访问一次，所以我们说v的时间局部性很差。</p>
<p>我们说像sumvec这样顺序访问一个向量每个元素的函数，是具有步长为1的引用模式（相对于元素的大小）。有时我们称步长为1的引用模式为顺序引用模式。一个连续向量中，每隔k个元素进行访问，就称为步长为k的引用模式，步长越长，空间局部性就越差。</p>
<h3 id="取指令的局部性">取指令的局部性</h3>
<p>程序指令存放在内存中，CPU需要取出这些指令，所以我们也可以评价一个程序关于取指令的局部性。对于循环，通常是在连续的空间中进行的，所以它有良好的空间局部性，由于它会被反复调用，所以也有着良好的时间局部性。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// clang-format off</span><br><span class="line">hotblock1:</span><br><span class="line">    Stmts; // &lt;-- 热！</span><br><span class="line">    if (/* 边界条件不成立 */ true)</span><br><span class="line">        goto hotblock2; // 经常发生！ ------+</span><br><span class="line">coldblock:                           /*   |   */</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |  跨越了大量指令，代价高昂！</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">hotblock2:                          /*    |   */</span><br><span class="line">    Stmts; // &lt;- 热！           &lt;----------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// clang-format off</span><br><span class="line">hotblock1:</span><br><span class="line">    Stmts; // &lt;-- 热！</span><br><span class="line">    if (/* 边界条件 */ false)</span><br><span class="line">        goto coldblock; // 很少发生</span><br><span class="line">hotblock2:                         /*   |  低代价！  */</span><br><span class="line">    Stmts; // &lt;- 热！  &lt;-----------------+</span><br><span class="line">coldblock:</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br></pre></td></tr></table></figure>
<p>代码区别于程序数据的一点在于，在运行时它是不能被修改的，CPU只从内存中读取指令，并不修改它。</p>
<h3 id="编写高速缓存友好的代码">编写高速缓存友好的代码</h3>
<p>明白了高速缓存的工作原理之后，我们可以更准确的描述局部性了，局部性较好的程序通常意味着较高的命中率，不命中率较低的程序往往运行的会更快。所以编写局部性好的程序实际上是编写对高速缓存友好的程序。</p>
<p>下面就是我们用来确保代码高速缓存友好的基本方法：</p>
<ul>
<li><strong>让常见的情况运行得快</strong>，程序通常把大部分时间花在少量的核心函数上，而这些函数通常把大部分时间花在了少量的循环上，所以要把注意力击中在核心函数的循环上，忽略其他部分。</li>
<li><strong>尽量减少每个循环内部的缓存不命中数量</strong>，在其他条件相同的情况下（加载存储操作次数），不命中率低的程序通常循环运行的更快。</li>
</ul>
<p>同时还有几个重要问题：</p>
<ul>
<li>对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器中（时间局部性）</li>
<li>步长为1的顺序引用是好的，因为存储器层次结构中所有层次上的缓存都是讲数据存储为连续的块（空间局部性）</li>
</ul>
<p>我们这里以n*n矩阵相乘为例：</p>
<p>让 C = A x B，我们通常会写出以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            C[i][j] = A[i][k]*B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据i,j,k不同的循环顺序，实际上我们可以写出六个版本的矩阵乘法，但是它们是否互相等价呢？</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/EgcLfyzU24imTY1.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以分析，对于循环的过程中，我们总是希望步长是尽可能小的。所以我们优先考虑B矩阵的数据，对于<code>B[k][j]</code>的迭代，我们希望是kj顺序的，此时是顺序执行，空间局部性良好。对于左边的<code>A[i][k]</code>，我们应该优先考虑对k的迭代，以保证步长尽可能的小，所以使用ik顺序迭代。综上所述，ikj循环才是性能最好的，其他的就不过多赘述。反向分析即可。</p>
<p>在对程序空间局部性的分析过程中，我们要考虑到缓存时是行缓存存储的，所以应该尽可能的让要使用的数据在空间上是连续接近的。同时将目光聚焦于内循环（程序中迭代次数最多的代码块）中，以获得最好的局部性。对于新引入的数据对象，我们也应该多使用它，利用好时间局部性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/16/63-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/16/63-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="post-title-link" itemprop="url">63:螺旋矩阵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-16 13:02:33 / 修改时间：14:51:44" itemprop="dateCreated datePublished" datetime="2025-07-16T13:02:33+08:00">2025-07-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>螺旋矩阵题型总结。我刷了几道螺旋矩阵相关的题目，这里我们介绍一下一些常见的解法。</p>
<h1 id="螺旋矩阵">螺旋矩阵</h1>
<h2 id="方形矩阵">方形矩阵</h2>
<p>当我们遇到<code>n*n</code>的方形矩阵时，可以用一种特殊的解法来遍历实现，以下面这道题为例：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵
II</a></p>
<p>我们可以定义几个变量用来控制遍历的行为：</p>
<ul>
<li>startX：每次循环的起点的行数</li>
<li>startY：每次循环的起点的列数</li>
<li>offset：每循环一圈，用偏移量表现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span> , startX = <span class="number">0</span> , startY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n/<span class="number">2</span>;k++)&#123;		<span class="comment">//循环次数就是圈数</span></span><br><span class="line">            <span class="keyword">for</span>(j=startY;j&lt;n-offset;j++)	<span class="comment">//左上-&gt;右上（从此以下都是左闭右开）</span></span><br><span class="line">                ans[startX][j] = val++;</span><br><span class="line">            <span class="keyword">for</span>(i=startX;i&lt;n-offset;i++)	<span class="comment">//右上-&gt;右下</span></span><br><span class="line">                ans[i][j] = val++;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;startY;j--)				<span class="comment">//右下-&gt;左下	</span></span><br><span class="line">                ans[i][j] = val++;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startX;i--)				<span class="comment">//左下-&gt;右上</span></span><br><span class="line">                ans[i][j] = val++;</span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;	<span class="comment">//实际上更新offset就是在更新每次循环的边界（缩小）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>)&#123;	<span class="comment">//如果矩阵的边长为奇数，最中间的值会没法遍历到</span></span><br><span class="line">            ans[offset<span class="number">-1</span>][offset<span class="number">-1</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时还可以将方形矩阵视作一种特殊的矩形矩阵，以下对矩形矩阵的所有解法对方形都适用。</p>
<h2 id="矩形矩阵">矩形矩阵</h2>
<p>有时候我们会发现矩阵是矩形的，或者只有一层，这个时候就需要用几个通用的方法，来实现。例题：</p>
<p><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">LCR
146. 螺旋遍历二维数组</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54.
螺旋矩阵</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-iv/">2326.
螺旋矩阵 IV</a></p>
<h3 id="模拟路径法">模拟路径法</h3>
<p>我们先分析我们的转向条件：（1）当前进的方向上碰到了边界（2）当前进的方向上是已经走过的路径</p>
<p>第一个条件比较好解决，第二条件我们需要维护一个和数组相同大小的矩阵，走过的路线我们设置为true，没走过的设置为false.</p>
<p>由于我们的转向动作是有序的，是顺时针，所以我们可以使用一个数组来存储我们的方向。当到达转向条件时，设置成下一个转向动作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">empty</span>()||array[<span class="number">0</span>].<span class="built_in">empty</span>())	<span class="comment">//判断数组是否为空，注意先后顺序，array[0]在array为空时是不能访问的</span></span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> row = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = row*col;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">use</span>(row,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col,<span class="number">0</span>));	<span class="comment">//路径表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(total,<span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; direction&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;	<span class="comment">//方向表（顺时针）</span></span><br><span class="line">        <span class="type">int</span> directionIdx = <span class="number">0</span>;	<span class="comment">//方向表索引</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;total;k++)&#123;</span><br><span class="line">            ans[k] = array[i][j];</span><br><span class="line">            use[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> ni = i + direction[directionIdx][<span class="number">0</span>];	<span class="comment">//预更新i</span></span><br><span class="line">            <span class="type">int</span> nj = j + direction[directionIdx][<span class="number">1</span>];	<span class="comment">//预更新j</span></span><br><span class="line">            <span class="keyword">if</span>(ni&lt;<span class="number">0</span>||ni&gt;=row||nj&lt;<span class="number">0</span>||nj&gt;=col||use[ni][nj]==<span class="literal">true</span>)&#123;	<span class="comment">//根据预更新状态判断转向条件</span></span><br><span class="line">                directionIdx = (directionIdx<span class="number">+1</span>)%<span class="number">4</span>;	<span class="comment">//转向则把方向索引设置到下一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//实际更新</span></span><br><span class="line">            i = i + direction[directionIdx][<span class="number">0</span>];</span><br><span class="line">            j = j + direction[directionIdx][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="层级遍历法边界收缩">层级遍历法（边界收缩）</h3>
<p>这个和刚刚用来解决方形矩阵的方法是相同的，只不过更新方式和更新条件要更加复杂。</p>
<p>一开始先设定好边界，当移动到边界的时候就转向，然后收缩边界。这样的好处在于我们不用再特意维护一个数组来判断路径是否被走过
了。因为走过的路径被我们收缩了，所以就不用在考虑。只需要在边界做检测就好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;	</span><br><span class="line">        <span class="type">int</span> bottom = m<span class="number">-1</span>;	<span class="comment">//-1是因为索引和实际位置的差值</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;	<span class="comment">//如果相等就说明，边界收缩了，遍历结束了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)	</span><br><span class="line">                ans[top][i] = val;</span><br><span class="line">            top++;							<span class="comment">//左上-&gt;右上 top边界收缩</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++)</span><br><span class="line">                ans[i][right] = val;</span><br><span class="line">            right--;						<span class="comment">//右上-&gt;右下 right边界收缩</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                ans[bottom][i] = val;</span><br><span class="line">            bottom--;						<span class="comment">//右下-&gt;左下 bottom边界收缩</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--)</span><br><span class="line">                ans[i][left] = val;</span><br><span class="line">            left++;							<span class="comment">//左下-&gt;右上 left边界收缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="螺旋生成矩阵">螺旋生成矩阵</h2>
<p>这个算是一个小特例，大多数题目是给你一个矩阵让你去螺旋遍历，但是有的题目需要你自己螺旋生成一个矩阵。我们看到下面的例题：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-iii/">885.
螺旋矩阵 III</a></p>
<figure>
<img src="https://s2.loli.net/2025/07/16/72iYyZ8Gxdj9fFO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这道题需要我们形成一个螺旋的路径，然后返回矩形内的位置的坐标。难点在于这个螺旋路径的生成，因为转向的条件和每次前进的步长综合考虑起来条件会非常的复杂。下面的话给出两种方法。</p>
<h3 id="边界扩展法">边界扩展法</h3>
<p>和我们之前所做的边界收缩相反，我们先界定好边界，然后每次转向时宽展这个方向上的边界。通过这种方式来动态的生成一个螺旋的路径</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DIR[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> rStart, <span class="type">int</span> cStart) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> total = rows*cols;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = rStart,j = cStart;	<span class="comment">//令i,j记录路径的实时位置</span></span><br><span class="line">        <span class="type">int</span> left = cStart - <span class="number">1</span>,right = cStart + <span class="number">1</span>,top = rStart - <span class="number">1</span>,bottom = rStart + <span class="number">1</span>;	<span class="comment">//确定边界</span></span><br><span class="line">        <span class="type">int</span> dir=<span class="number">0</span>;	<span class="comment">//记录方向</span></span><br><span class="line">        <span class="keyword">while</span>(num &lt;= total)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;cols)&#123;	<span class="comment">//当路径到达矩阵内部时，记录当前位置</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir==<span class="number">0</span>&amp;&amp;j==right)&#123;	<span class="comment">//如果向右移动触碰右边界</span></span><br><span class="line">                dir+=<span class="number">1</span>;				<span class="comment">//则转向</span></span><br><span class="line">                right++;			<span class="comment">//并拓展右边界</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir==<span class="number">1</span>&amp;&amp;i==bottom)&#123;	<span class="comment">//如果向下移动触碰下边界</span></span><br><span class="line">                dir+=<span class="number">1</span>;						<span class="comment">//则转向</span></span><br><span class="line">                bottom++;					<span class="comment">//并拓展下边界</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir==<span class="number">2</span>&amp;&amp;j==left)&#123;		<span class="comment">//...</span></span><br><span class="line">                dir+=<span class="number">1</span>;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dir==<span class="number">3</span>&amp;&amp;i==top)&#123;		<span class="comment">//...</span></span><br><span class="line">                dir=<span class="number">0</span>;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            i += DIR[dir][<span class="number">0</span>];		<span class="comment">//根据方向来更新位置</span></span><br><span class="line">            j += DIR[dir][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="规律法">规律法</h3>
<p>我们可以观察螺线路径的一个显著规律：每转向两次会更新一次前进的步长</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DIR[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">    	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> dir=<span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> run=<span class="number">2</span>;	<span class="comment">//步长计数器</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &lt; R * C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; run / <span class="number">2</span>; i ++)&#123;   <span class="comment">//遍历步长，每转两下就会增加一步</span></span><br><span class="line">                <span class="keyword">if</span>(r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;r0, c0&#125;), ++ num;</span><br><span class="line">                r0 += DIR[dir][<span class="number">0</span>];</span><br><span class="line">                c0 += DIR[dir][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            pos = (pos + <span class="number">1</span>) % <span class="number">4</span>;	<span class="comment">//每遍历一次步长，就转向</span></span><br><span class="line">            run++;		<span class="comment">//利用取整的性质，每转向两次才会增加一次步长</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>螺旋矩阵的关键在于边界的检测和变换，还有转向条件的判断。比较简单。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/15/62-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/15/62-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-3/" class="post-title-link" itemprop="url">62:程序性能优化(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-15 13:23:20 / 修改时间：19:34:50" itemprop="dateCreated datePublished" datetime="2025-07-15T13:23:20+08:00">2025-07-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">程序性能优化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们已经尽可能的实现各种程度的优化了，但所谓知己知彼，百战不殆。我们不仅要了解程序的性能怎么去优化，同时也要了解制约程序进一步优化的因素是什么。</p>
<h2 id="限制因素">限制因素</h2>
<p>关键路径指明了执行程序所需时间的基本下界。如果程序中有某条数据相关链，这条链上的所有的延迟之和等于T，那么程序至少需要T个周期才能执行完。我们还看到功能单元的吞吐量界限也是程序执行的一个下界。也就是说，假设一个程序一共需要N个某种运算的计算，而微处理器只有C个能执行这个操纵的功能单元，并且这些单元的发射时间为I，那么这个程序的执行至少需要<code>N*I/C</code>个周期。</p>
<p>不过以上是理想状态，实际过程中，我们仍然需要考虑其他的制约因素。</p>
<h3 id="寄存器溢出">寄存器溢出</h3>
<p>循环并行性的好处受汇编代码描述计算的能力限制（如果代码描述不出来，说明寄存器不够用了）。如果并行度p超过了可用的寄存器数量，那么编译器就会<strong>溢出</strong>。将某些临时值放到内存中，在堆栈上分配空间。比如下面的例子：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/Ec3IKetFuOAW1lL.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>为啥<code>20*20</code>的循环展开反而不如<code>10*10</code>呢？现代x86-64处理器可以使用16个YMM寄存器来保存浮点数。一旦数量超过了可用的寄存器的数量，程序就必须在栈上分配变量。内存写入读取的过程会造成不必要的开销。不过大多数循环会在出现寄存器溢出之前就会达到吞吐量的极限。</p>
<h3 id="分支预测和预测错误处罚">分支预测和预测错误处罚</h3>
<p>指令在进行分支预测时，往往会使用投机执行的机制，但是预测错误意味着很大的代价。虽然代价是无法避免的，但是我们是否可以减少这个代价呢？在x86-64的程序处理中有条件传送的指令。我们可以在进行分支跳转的时候，通过将条件转移编译成条件传送来，减少这个代价。我们直接结算出两个方向上的可能的值，然后根据条件传送选择期望的值。这样，我们就不用考虑条件是否满足了，因为没有代价。</p>
<p>抛开编译器的优化，我们又该如何编写能够减少分支预测处罚的代码呢?</p>
<h4 id="不要过分关心可以预测的分支">不要过分关心可以预测的分支</h4>
<p>错误的分支预测影响可能很大，但是并不意味着所有的程序分支都会减缓程序的运行。现代处理器的分支预测逻辑十分先进，对于循环语句的分支，往往会被预测为选择分支，这样只有最后一次才会导致预测错误。</p>
<p>所以在程序性能优化（1）中的这个现象可以解释：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/hqyzVcUIZb1jRwK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们为了减少<code>get_vec_element</code>中的边界检测的延迟，改进成了<code>combine3</code>，发现程序性能几乎没什么改变，这是因为对于i的边界检测，是高度可预测的，对于计算机而言影响微乎其微。这些检测并不会影响程序的关键路径，或是起不到决定性作用。</p>
<h4 id="书写适合用条件传送实现的代码">书写适合用条件传送实现的代码</h4>
<p>分支预测对于循环这种有规律的模式还行，但是程序中的大多数测试时完全不可预测的，依赖于数据的任意性，分支预测逻辑会表现得很糟糕。我们无法保证编译器会在编译中使用条件数据传送而不是条件控制转移，但是我们可以引导编译器进行我们想要的编译。</p>
<p>以一个程序为例，给定两个整数数组<code>a</code>和<code>b</code>，对于每个位置<code>i</code>，我们想要将<code>a[i]</code>设置为<code>a[i]</code>和<code>b[i]</code>中较小的那个，将<code>b[i]</code>设置成较大的那个。</p>
<p>首先是我们常用的风格：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">minmax1</span><span class="params">(<span class="type">long</span> a[],<span class="type">long</span> b[],<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[i])&#123;</span><br><span class="line">            <span class="type">long</span> t = a[i];</span><br><span class="line">            a[i] = b[i];</span><br><span class="line">            b[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里可以看到，我们是在分支预测之后才执行交换的过程。这会扩大分支预测的代价。可是我们尝试另一种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">minmax2</span><span class="params">(<span class="type">long</span> a[],<span class="type">long</span> b[],<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> min = a[i] &lt; b[i] ? a[i] : b[i];</span><br><span class="line">        <span class="type">long</span> max = a[i] &lt; b[i] ? b[i] : a[i];</span><br><span class="line">        a[i] = min;</span><br><span class="line">        b[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话相当于去除了条件分支，先把每个位置的最大值和最小值计算出来，然后分别赋值给a[i]和b[i]。通过合理的安排代码，我们也可以更好的帮助编译器优化代码。</p>
<h2 id="理解内存性能">理解内存性能</h2>
<p>内存性能实际上也是很重要的决定性因素，在之前的测试中，实际上访问的内存都十分少量。所有的现代处理器都包含一个或多个高速缓存存储器，以对少量的存储器提供快速的访问。接下来我们要进一步讨论加载和存储操作的程序的性能印象。不过我们默认所有的数据都是存放在高速缓存中的情况。</p>
<h3 id="加载的性能">加载的性能</h3>
<p>一个包含加载操作的程序性能既依赖于流水线的能力，也依赖于加载单元的延迟。在之前的合并函数中，无论什么数据类型和合并操作都无法让CPE下降到0.5以下。这是因为，每一个被计算的元素，所有的示例都需要熊内存中独一个值，对于两个加载单元而言，其每个时钟周期都只能启动一条加载操作，所以CPE不可能小于0.5</p>
<p>到目前为止我们并没有在示例中看到加载操作的延迟产生的影响。加载操作的地址只依赖于循环索引<code>i</code>，所以加载操作不会称为限制性能的关键路径的一部分。</p>
<p>但是我们可以手动构造一个由一系列加载操作构成的计算，一个加载操作的结果决定下一条操作的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125;list_ele,*list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_ptr ls)</span>&#123;</span><br><span class="line"> 	<span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里变量<code>ls</code>的每个后续只依赖于指针引用<code>ls-&gt;next</code>读出的值。我们可以关键部分的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L3:</span><br><span class="line">	addq $1,%rax</span><br><span class="line">	movq (%rdi),%rdi	;ls = ls-&gt;next</span><br><span class="line">	testq %rdi,%rdi</span><br><span class="line">	jne .L3</span><br></pre></td></tr></table></figure>
<p>我们可以可以看到<code>movq</code>是整个循环中关键的瓶颈，且每次循环都会依赖加载出来的<code>%rdi</code>的值，此时的程序的CPE是由加载操作的延迟决定的。我们之后在存储器部分会详细讨论。</p>
<h3 id="存储的性能">存储的性能</h3>
<p>和其他的操作不一样，存储操作不会影响任何寄存器的值。一系列的存储操作并不会产生数据相关。只有加载操作会受存储操作结果的影响，因为只有加载操作才能从由存储操作写的那个位置读回值。</p>
<p>我们可以做一个实验来体现这种影响：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span>* src,<span class="type">long</span>* dst,<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt)&#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src)+<span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们分别使用两种不同的调用方式：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/cN6frKdTbxOkGlY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>最终的结果是示例A的CPE=1.3远快于示例B的CPE =
7.3。这背后的原因就是因为在调用<code>write_read</code>时，参数<code>src</code>和<code>dst</code>指向了同一个内存位置，导致产生了<strong>写/读相关</strong>——一个内存读的结果依赖于一个最近的内存写。</p>
<p>为了理解这背后具体的原理，我们需要更加仔细的看看加载和存储执行单元：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/wFyNYVbO4XGz78g.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>存储单元实际上会包含一个存储缓冲区，它包含已经被发射到存储单元而又还没完成的存储操作（这里的完成包括更新数据高速缓存）的地址和数据。提供这么一个缓冲区，使得一系列存储操作不必等待每个操作都更新高速缓存就能执行。当一个加载操作发生时，它必须检查存储缓存区中的条目，看看有没有地址匹配。如果有就取出相应的数据条目作为加载操作的结果。</p>
<p>其机器代码形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; src in %rdi , dst in %rsi , val in %rax</span><br><span class="line">.L3:				; loop:</span><br><span class="line">	movq %rax,(%rsi)	;write val to dst</span><br><span class="line">	movq (%rdi),%rax	;t = *src</span><br><span class="line">	addq $1,%rax		; val = t+1</span><br><span class="line">	subq $1,%rdx		;cnt--</span><br><span class="line">	jne .L3				;if != 0,goto loop</span><br></pre></td></tr></table></figure>
<p>这里的<code>movq (%rdi),%rax</code>在实际的过程中被翻译成了两个操作：</p>
<ul>
<li>s_addr指令计算存储操作的地址，在存储缓冲区创建一个条目，并设置该条目的地址字段</li>
<li>s_data操作设置该条目的数据字段。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/07/15/wIjBQlN7uvA2VZ5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这两个计算时独立执行的，不过它们之间有隐含的相关，实际上<code>s_addr</code>的操作必须在<code>s_data</code>之前。同时由于load操作需要检查所有未完成的存储操作的地址，所以s_addr到load之间也会存在数据相关。还有一个有条件的数据相关，存在于<code>s_data</code>和<code>load</code>之间（当%rsi和%rdi相等，即读写的地址相同），此时load操作必须等待直到<code>s_data</code>将它的结果存放到存储缓冲区中。反之，则继续进行。</p>
<p>我们依旧可以图形化抽象<code>write_read</code>的操作，来分析它的关键路径：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/oHGcxfDZ6Er2uiJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>右边是最简情况，只保留了使用一次迭代中的值为下一次迭代产生的值的操作。</p>
<p>现在我们可以理解函数<code>write_read</code>的性能特征了，下面是内循环多次迭代形成的数据相关：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/iHgpjR7TNbuWlZn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在示例A的情况下，有不同的源和目的地址，加载和存储操作都可以独立进行，因此唯一的关键路径是减少变量造成的，因此这个程序的CPE为1.0。对于示例B的情况下，源地址和目的地址相同，导致s_data和load指令之间的数据相关使得关键路径形成。其中包括了存储，加载，增加数据等操作，导致程序的CPE为7.0。</p>
<p>这个例子说明了，内存操作的细微之处。对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响那些指令了。但是对于内存操作，只有到计算出加载和存储的地址被计算出来后，处理器才能确定那些指令会影响哪些。</p>
<p>我们可以通过设置中间变量的方式来避免写/读相关。例如：</p>
<p>我们有a，p两个数组，令p[0] = a[0]，p[i] = p[i-1] +
a[i]，我们正常写出来的程序会是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">long</span> a[],<span class="type">long</span> p[],<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里的<code>p[i]=p[i-1] + a[i]</code>存在着读/写相关。我们可以引入一个中间的存储变量，来避免这种数据上的依赖：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">long</span> a[],<span class="type">long</span> p[],<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> last_val,val;</span><br><span class="line">    last_val = p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        val = last_val + a[i];</span><br><span class="line">        p[i] = val;</span><br><span class="line">        last_val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结性能提高技术">总结：性能提高技术</h2>
<ul>
<li><strong>高效设计：</strong>为遇到问题选择适当的算法和数据结构，避免使用会渐进的产生糟糕性能的算法或编码技术。</li>
<li><strong>基本编码原则：</strong>避免限制优化的因素，这样编译器就能产生高效的代码。
<ul>
<li><strong>消除连续的函数引用：</strong>必要时，将计算移到循环外面。</li>
<li><strong>消除不必要的内存引用：</strong>引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中</li>
</ul></li>
<li><strong>低级优化：</strong>结构化代码以利用硬件功能。
<ul>
<li>展开循环，降低开销，并且使得进一步的优化称为可能</li>
<li>通过使用例如多个累计变量和重新结合等技术，提高指令的并行性</li>
<li>用功能性的风格重写条件操作，使得编译采用条件数据传送</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/15/61-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/15/61-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-2/" class="post-title-link" itemprop="url">61:程序性能优化(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-15 10:31:17 / 修改时间：13:23:56" itemprop="dateCreated datePublished" datetime="2025-07-15T10:31:17+08:00">2025-07-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">程序性能优化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上次我们分别从简单的过程调用的优化到了机器级层面的关键路径优化。在此基础之上，我们可以尝试更进一步的优化。</p>
<h2 id="循环展开">循环展开</h2>
<p>循环展开通过增加每次迭代计算的元素的数量，减少循环的迭代次数。它从两个方面改进了程序的性能：</p>
<ul>
<li>减少了循环索引的计算和条件分支的判断</li>
<li>提供了一些方法，进一步的变化代码，减少整个计算中关键路径上的操作数量</li>
</ul>
<p>比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;limit;i+=<span class="number">2</span>)</span><br><span class="line">        acc = (acc OP data[i]) OP data[i+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length;i++)</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们每次迭代都进行了两次迭代，我们可以看到一定程度上的性能优化：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/bOAV3UZqBGITL2K.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实际上循环展开也有许多需要注意的地方，比如循环展开的边界条件。我们设我们的按<code>k</code>次进行迭代，也就是说每次会将从<code>i</code>到<code>i+k-1</code>的数据进行计算，但是可能会出现一个情况。我们的原迭代次数可能无法被<code>k</code>整除，这意味着我们可能会出现漏处理的情况，需要额外设置一个循环。那么第一个循环的边界应该到哪里为止呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i+k-1 &lt; n --&gt; i &lt; n-k+1 --&gt; limit = n-k+1</span><br></pre></td></tr></table></figure>
<p>推断可知<code>i</code>只能小于我们得到的<code>limit</code>，以确保程序能够正常迭代。剩下的未能完全迭代的部分，我们使用另一个循环来继续计算。</p>
<p>但是循环展开的次数越多，性能的优化效果就越好吗？我们看到并非如此：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/iyEvMconeNuQPTF.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>要理解为什么程序没法进一步的优化，我们需要分析程序的关键路径，我们将<code>k=2 data_t=double OP=*</code>时的关键代码转化成图形化表示：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/1WrQ7Y6oFHBCMZ9.png"
alt="image.jpg" />
<figcaption aria-hidden="true">image.jpg</figcaption>
</figure>
<p>我们进一步的化简，可以看到关键路径的状态：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/NieWAf1HG9MYFx5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>无论怎么展开，关键路径上还是有n个mul操作，由于数据的依赖关系，这里的乘法操作在每次展开中实际上并不能并行处理。为了进一步的提高程序的性能，我们要想办法提高数据的并行性。</p>
<h2 id="提高并行性">提高并行性</h2>
<p>硬件通常有多个相同的硬件组成，实际上硬件有更高速率执行加法和乘法的潜力，但是我们的代码无法实现这个功能，这是因为我们将累计的值放在一个单独的变量中，在前一个操作结束前，我们都无法进行下一个整数操作，所以我们需要相办法打破这种顺序相关，来更好的利用硬件的并行性能。</p>
<h3 id="多个累计变量">多个累计变量</h3>
<p>对于一个可交换可结合的合并运算来说，我么可以通过将一组合并运算拆分成多个部分，最后合并结果，来提高性能，比如对于：</p>
<p>P<sub>n</sub> = a<sub>1</sub> * a<sub>2</sub> * …… * a<sub>n</sub>
我们可以将其拆分成 PO<sub>n</sub> = a<sub>1</sub> * a<sub>3</sub> * …… *
a<sub>2i+1</sub> 和 PE<sub>n</sub> = a<sub>2</sub> * a<sub>4</sub> * ……
* a<sub>2i</sub>，最后合并得到 P<sub>n</sub> = PO<sub>n</sub> *
PE<sub>n</sub></p>
<p>我们可以用代码实现，这种既做循环展开，又做两路并行的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;limit;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length;i++)</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    *dest = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/3VHpri24aXFPuoI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们的增加并行计算后的程序性能超过了延迟界限，相较于之前提升了两倍，这意味着我们很好的利用了并行计算的优势，我们可以根据对关键路径的分析中很好的看到这一点：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/POTzqlZ8syJkFYV.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>combine6</code>中的两路并行优化将原来的一条关键路径拆分成了两条关键路径，现在每条关键路径上的mul操作变成了<code>n/2</code>次。使得程序的性能极大的提升，对于我们进行<code>k*k</code>的优化，我们可以在下图中看到效率的提升：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/MTAua8GXodt9E5r.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看到随着k的增加，甚至可以使程序的性能逼近吞吐量的界限。</p>
<p>但是，这样的并行计算一定很好吗？它也有着一定的副作用，受四舍五入和溢出的影响，可能会一定程度上改变程序的行为，造成一定的误差。需要酌情处理。</p>
<h3 id="重新结合变换">重新结合变换</h3>
<p>现在我们需要探讨另一种打破顺序相关的方式以将性能提高到延迟界限之外。我们只需进行对<code>combine5</code>的循环逻辑进行微小的合并变换即可得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;limit;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="comment">//原：acc = (acc OP data[i]) OP data[i+1];</span></span><br><span class="line">        acc = acc OP (data[i] OP data[i+<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length;i++)</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去并没有发生什么改变，但是实际测量的性能却得到了很好的提升：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/GqeUBKSW7c2n3iz.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们还是分析关键路径：</p>
<figure>
<img src="https://s2.loli.net/2025/07/15/EAnr3Bjs6ZeJQcw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以看到，每次迭代的第一个乘法实际上不存在顺序相关的问题，它的每次计算不依赖于上一次的迭代寄存器，所以关键路径上只有一次乘法操作，另一次乘法操作始终可以并行操作。所以通过这种方式，关键路径上只有<code>n/2</code>次mul操作。</p>
<p>随着展开次数的增多，程序的性能也可以接近吞吐量界限。总的来说重新结合变换会减少计算中关键路径上操作的数量，通过更好的利用功能单元的流水线能力得到更好的性能。要注意的问题和上面一样。</p>
<h2 id="优化合并小结">优化合并小结</h2>
<p>通过以上的例子，我们应该意识到现代处理器强大的计算能力，可是现代编译器因为种种原因始终不能完全的利用这些能力，但是我们可以按一些非程式化的方式来编写程序以激发这些能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/12/60-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/12/60-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/" class="post-title-link" itemprop="url">60:程序性能优化(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-12 13:28:39" itemprop="dateCreated datePublished" datetime="2025-07-12T13:28:39+08:00">2025-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-14 13:55:37" itemprop="dateModified" datetime="2025-07-14T13:55:37+08:00">2025-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">程序性能优化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于特定的程序而言，尤其是要长时间多次运行的程序而言，我们需要尽可能的优化他的效率。如计算效率，空间效率…大多数时候编译器会帮助我们完成这个工作，但是特定的场景中，我们需要自己实现程序的优化设计。</p>
<h2 id="优化编译器的能力和局限性">优化编译器的能力和局限性</h2>
<p>在现代编译器中，编译器往往会通过各种复杂的算法，根据程序中的值，被计算被使用的过程，来优化程序的实现。其中以GCC为例，编译器为我们提供了一系列指定优化级别，如<code>-Og</code>是使用一些基本的优化。使用<code>-O1 -O2 -O3</code>则会使用更多的优化。但是可能会导致一些未定义的复杂的情况出现。</p>
<p>我们需要保证编译器对程序只进行 <strong>安全</strong>
的优化，也就是说对于程序所有可能遇到的情况，在C语言标准之下，优化后得到的程序和优化前得到程序应该有相同的行为。我们可以看下面的一个范例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">twiddle1</span><span class="params">(<span class="type">long</span> *xp,<span class="type">long</span> *yp)</span>&#123;</span><br><span class="line">    *xp += *yp;		<span class="comment">//两次读一次写</span></span><br><span class="line">    *xp += *yp;		<span class="comment">//两次读一次写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddle2</span><span class="params">(<span class="type">long</span> *xp,<span class="type">long</span> *yp)</span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span>* *yp	<span class="comment">//两次读一次写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去，两个程序似乎有这相同的行为，而且看起来<code>twiddle2</code>有着更好的效率。但是实际上，当我们考虑<code>xp=yp</code>的情况时。我们发现<code>twiddle1</code>和
<code>twiddle2</code>的结果并不一样。所以编译器不应该将<code>twddle2</code>做为<code>twiddle1</code>的优化版本。</p>
<p>这种两个指针可能指向同一个内存位置的情况，我们称之为<strong>内存别名使用</strong>。在编译器优化中，我们必须假设不同的指针可能会指向内存中的同一个位置。这是妨碍优化的第一个因素。</p>
<p>第二妨碍优化的因素是<strong>函数调用</strong>，我们假设下面的这个范例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f()+f()+f()+f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们乍一看可能认为func1和func2效果是相同的，实际上，当我们考虑如下情况时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候就会产生不一样的结果，这是因为这个函数有<strong>副作用</strong>——它修改了全局程序状态的一部分。改变调用它的次数，会的改变程序的行为。</p>
<p>如果编译器不会试图判断一个函数有没有副作用，那可能会被错误的优化成func2。相反，则会保持函数调用不变。不过还有现代编译器也会使用一种特殊的手段来实现这种优化——<strong>内联函数替换</strong>。如func1可能会被内联替换成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func1in</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> t = counter++; 	<span class="comment">//+0</span></span><br><span class="line">    t += counter++;			<span class="comment">//+1</span></span><br><span class="line">    t += counter++;			<span class="comment">//+2</span></span><br><span class="line">    t += counter++;			<span class="comment">//+3</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话就减少了函数调用的开销。同时我们可以实现进一步的优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func1opt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> t = <span class="number">4</span>*counter + <span class="number">6</span>;</span><br><span class="line">    counter += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在gcc中使用<code>-finline</code>和<code>-O1</code>以上等级的优化实现这个优化。但是这个优化也有一定的代价，我们将函数调用的过程优化掉了，意味着我们不能在调试器中，跳转到对应的程序，这意味程序行为一定程度上的失真。</p>
<h2 id="程序示例">程序示例</h2>
<p>为了说明一个抽象的程序是如何被系统地转换成更有效的代码的，我们使用一个基于下面的是向量数据结构的运行示例。</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/8y2FXeORU1CntfM.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>向量有两个内存块组成：头部和数据数组，其中头部的结构声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">data_t</span> *data;</span><br><span class="line">&#125; vec_rec,*vec_ptr;</span><br></pre></td></tr></table></figure>
<p>这个声明由data_t来表示基本元素的数据类型，我们可以指定类型给data_t。同时，我们还会分配一个len个data_t类型对象的数组，来存放实际的向量元素。</p>
<p>我们给出一个生成向量，访问向量元素，以及确定向量长度的基本过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成指定长度的向量数组</span></span><br><span class="line">vec_ptr <span class="title function_">new_vec</span><span class="params">(<span class="type">long</span> len)</span>&#123;</span><br><span class="line">	<span class="comment">//分配向量头部的空间</span></span><br><span class="line">    vec_ptr result = (vec_ptr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec_rec));</span><br><span class="line">    <span class="type">data_t</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//分配失败</span></span><br><span class="line">    result-&gt;len = len;</span><br><span class="line">    <span class="comment">//分配数组的空间</span></span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        data = (<span class="type">data_t</span>*)<span class="built_in">calloc</span>(len,<span class="keyword">sizeof</span>(<span class="type">data_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!data)&#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="type">void</span> *)result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//分配失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;data = data;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问向量中的指定元素并存储在指定空间中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_vec_element</span><span class="params">(vec_ptr v,<span class="type">long</span> index,<span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=v-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *dest = v-&gt;data[index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回向量的长度</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">vec_length</span><span class="params">(vec_ptr v)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在此基础上实现一个合并运算的实现，通过对基本元素IDENT和合并运算OP的不同声明，我们测量这个函数对不同运算的性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IDENT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP +</span></span><br><span class="line"><span class="comment">//#define IDENT 1</span></span><br><span class="line"><span class="comment">//#define OP *</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec_ptr v,<span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; vec_length(v);i++)&#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element(v,i,&amp;val);</span><br><span class="line">        *dest = *dest OP val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们会给出程序的CPE效率（数值越小性能越好），以参考：</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/emqAZ7WEdOUvczg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="消除循环的低效率">消除循环的低效率</h3>
<p>我么可以看到过程combine1调用函数vec_length作为for循环的测试条件。这导致每次循环测试的过程中我们都会有一次函数调用开销，我们可以通过以下方式来减少这个开销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec_ptr v,<span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    </span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element(v,i,&amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/wivQ4OErRkq7ZgH.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个优化是一个常见的优化，叫做<strong>代码移动</strong>。这类优化包括识别要执行多次，但是计算结果不会改变的计算。因为可以将计算移动到不会被多次求值的部分。</p>
<p>很遗憾的是，现在的编译器并不能很好的实现这一点。这个看起来无足轻重的代码，实际上在循环次数高的使用环境下，极大的影响了程序的效率。</p>
<h3 id="减少过程的调用">减少过程的调用</h3>
<p>正如我们刚刚所提到的，在循环测试中的过程调用会导致程序的性能下降，同样的在循环体中的过程调用也会导致性能的开销。在我们的代码中，可以看到每次循环迭代都会调用<code>get_vec_element</code>，这个函数会对索引做边界检测，然后再获取指定的数据。</p>
<p>在这里我们可以简化这个过程，我们定义一个新的函数以获取向量的起始位置，然后通过数组索引访问，从而实现对元素的访问。避免在循环体中的过程调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">data_t</span>* <span class="title function_">get_vec_start</span><span class="params">(vec_ptr v)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v,<span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    </span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/rWdajJQXTf87ZYI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>令我们吃惊的是，性能并没有明显的提升。事实上，整数求和的性能还略有下降。显然是内存循环中的其他操作形成了瓶颈，限制性能超过调用<code>get_vec_element</code>我们之后还会在此回头看看这个现象。看看为什么combine2中反复的边界检查不会让性能更差。</p>
<h3 id="消除不必要的内存引用">消除不必要的内存引用</h3>
<p>combine3的代码将合并运算的值累积在指针dest指定的位置。通过检查编译出来的内循环代码我们可以看出，每次我们对指定位置的计算都需要先从内存中取出，再重新存入。在此我们给出的数据类型为double,合并运算为乘法的汇编为：</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/veRKaH1hjGSzXCU.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在这里我们可以看出每次迭代都需要从内存中读出再写入内存。这样的内存读写十分浪费，我们应该先用一个临时寄存器来存储每次迭代后的值，等到迭代结束后，再将值写入内存，从而避免不必要的内存引用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/12/BG8hyRzvslbtu53.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以看到程序性能显著的提升。但是遗憾的是，编译器无法实现这个简单的变换，因为在大多数情况下，编译器并不能判断函数会在什么情况下被调用，以及程序员的本意是什么。所以在编译的过程中，往往只能进行保守的读写内存。</p>
<h2 id="理解现代处理器">理解现代处理器</h2>
<p>到现在为止，我们所运用的优化都是不依赖于目标机器的任何特性的。这些优化只是简单的降低了过程调用的开销，以及消除了一些妨碍优化的因素。但是随着进一步提高性能，我们必须考虑利用处理器<strong>微体系结构</strong>的优化，也就是处理器用来执行指令的底层系统设计。</p>
<p>实际上处理器的实际操作与通过观察机器级程序所察觉到的大相径庭。在代码级别上，我们认为程序是一条一条执行的，实际上，在实际的处理器中，使同时对多条指令求值的，我们称这个现象叫做<strong>指令并行</strong>.</p>
<p>我们对指令并行的认识来理解是什么限制了程序的最大性能：</p>
<ul>
<li>当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限</strong>，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令并行的功能时，延迟界限能够限制程序性能</li>
<li><strong>吞吐量界限</strong>刻画了处理器功能单元的原始计算能力。这个界限时程序性能的终极限制。</li>
</ul>
<h3 id="整数操作">整数操作</h3>
<figure>
<img src="https://s2.loli.net/2025/07/12/jGNozU4eY6VgXfr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是现代微处理器的一个简单的示意图。这和我们认知的处理器结构并不一样，我们称这种处理器是<strong>超标量</strong>的，意味着它可以在每个时钟周期执行多个操作，而且是<strong>乱序</strong>的——意味着指令执行的顺序并不一定要和它们在机器级程序中的顺序是一样的。整个设计由两个主要部分：控制单元和执行单元。前者负责从内存中读出指令序列，并根据指令序列生成一组针对程序数据的基本操作；后者负责执行这些操作。</p>
<p>ICU（控制单元）从指令高速缓存中读取指令，指令高速缓存是一个特殊的存储器，它包含最近访问的指令。ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间译码，并把操作发送到EU（执行单元）。同时处理器会使用分支预测预测目标地址，并使用投机执行的技术，处理器会开始取出位于它预测分支的地址的指令，在预测之前正确之前就执行这些操作。如果之后发现预测错误，则将状态重新设置到分支点的状态，并开始取出并执行另一个方向上的指令。</p>
<p>指令译码逻辑将接受实际的程序指令，并将它们转换成一系列的微操作。然后EU接受来自取指单元的操作。通常每个时钟周期会接受多个操作。这些操作被分配到功能单元中执行。</p>
<p>读写内存是由加载和存储单元实现的。加载单元处理从内存读数据到处理器的操作。存储单元处理从内存读数据到处理器的操作。这两个单元都有一个加法器来完成地址的计算。图中的数据高速缓存是一个高速存储器，存放着最近访问的数值。</p>
<p>使用投机执行结束对操作求值，但是最终结果不会存放在程序寄存器和数据内存中，直到处理器确定（确定预测是否正确）实际应该执行这些指令，分支操作被送到EU。如果预测错误，EU会丢弃分支点之后计算出来的结果。它还会发送信号告诉分支单元，说预测是错误的，并指出正确的目的和分支。</p>
<p>在ICU中，退役单元记录正在进行的处理，确保它们遵守机器级程序的顺序语义。退役单元控制这些寄存器的更新。指令译码时，关于指令的信息被防止在一个先进先出的队列中。这个信息会一直保持在队列中，直到发生：</p>
<ul>
<li>一条指令的操作完成了，而且所有引起这条指令的分支点也都被确认为预测正确，那么这条指令就<strong>退役</strong>了，所有对程序寄存器的更新都可以被实际执行了。</li>
<li>如果引起该指令的某个分支点预测错误，这条指令会被清空，丢弃所有计算出来的结果。这样预测错误就不会改变程序的状态。</li>
</ul>
<p>由于任何对程序寄存器的更新都是在指令退役的时候进行。为了加速从一条指令到另一条指令的结果的传送，许多信息都是在执行单元之间进行交换的，原理和之前的转发原理相同，只不过更加复杂精细。</p>
<p>实现操作数在执行单元间传送的常用机制是<strong>寄存器重命名</strong>。当一条更新寄存器<code>r</code>的指令译码时，产生一个标记<code>t</code>（一个执行该操作结果的唯一的标识符）。条目（r，t）被加入一张表中，这个表维护着每个程序寄存器与会更新该寄存器的操作的标识符间的关系。当某个执行单元执行完一个操作时，会产生一个结果（v，t）指明标记为<code>t</code>的操作产生值<code>v</code>。所有等待<code>t</code>为源的操作都能使用<code>v</code>作为源值，这就是一种形式的数据转发。</p>
<p>通过这个机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件中再读出来，使得第二个操作能够再第一个操作完成后尽快开始。重命名表只包含关于有未进行写操作的寄存器条目。如果一条被译码的指令需要某寄存器，但是又没有标记与这个寄存器相关联，那么可以直接从寄存器文件中获取这个操作数。</p>
<h2 id="性能瓶颈">性能瓶颈</h2>
<p>想要理解程序的性能，首先我们要能理解程序中的<strong>关键路径延迟</strong>。在迭代中，影响性能瓶颈的是迭代寄存器（在迭代中被更新，既作为操作数又作为结果的寄存器）的更新速度。因为其他的操作是可以利用现有的数据进行并行计算的，我们可以以下面的一个问题为例：</p>
<ul>
<li>多项式求值</li>
</ul>
<p>a<sub>0</sub> + a<sub>1</sub>X + a<sub>2</sub>X<sup>2</sup> + ……. +
a<sub>n</sub>X<sup>n</sup></p>
<p>这个求多项式的过程可以用下面的函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">poly</span><span class="params">(<span class="type">double</span> a[],<span class="type">double</span> x,<span class="type">long</span> degree)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> xpwr = x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=degree;i++)&#123;</span><br><span class="line">        result += a[i]*xpwr;</span><br><span class="line">        xpwr = x*xpwr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Horner法多项式求值(减少乘法数量)</li>
</ul>
<p>a<sub>0</sub> + X ( a<sub>1</sub> + X (a<sub>2</sub> + …… + X
(a<sub>n-1</sub> + Xa<sub>n</sub>) … ))</p>
<p>这个求值过程，我们可以使用下面的函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">polyh</span><span class="params">(<span class="type">double</span> a[],<span class="type">double</span> x,<span class="type">long</span> degree)</span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[degree];</span><br><span class="line">    <span class="keyword">for</span> (i=degree<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        result = a[i] + x*result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看我们会认为下面的方法更加高效，因为相较于上面的程序，它只使用了一次乘法。但是事实真的是这样的嘛，我们测得<code>poly</code>的CPE比<code>polyh</code>更低。这是为什么呢？</p>
<figure>
<img src="https://s2.loli.net/2025/07/14/HsuMbr2679qRjCd.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以判断程序的性能瓶颈主要体现在循环迭代的过程中，而迭代的性能是由迭代寄存器的更新的速度决定的。我们可以看到两个函数对迭代寄存器的更新情况：</p>
<ul>
<li><strong>poly：</strong>他有两个迭代对象，分别是<code>result</code>和<code>xpwr</code>，由于数据的关联性，两个数据的迭代是互不干扰的。而制约迭代性能的关键则是<code>xpwr</code>的更新——一次乘法。</li>
<li><strong>polyh：</strong>它只有一个迭代对象<code>result</code>，它的每次更新需要一次乘法和一次加法，由于数据依赖的关联性，加法与乘法并不能并行处理。</li>
</ul>
<p>所以综上所述，程序的性能实际上是由<strong>关键路径延迟</strong>所决定的，而不是由整体的运算量决定的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/11/59-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/11/59-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">59:二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-11 10:47:05" itemprop="dateCreated datePublished" datetime="2025-07-11T10:47:05+08:00">2025-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-14 17:30:57" itemprop="dateModified" datetime="2025-07-14T17:30:57+08:00">2025-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>980</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始算法的简单学习，今天先从二分查找法开始</p>
<h2 id="二分查找">二分查找</h2>
<h3 id="代码实现">代码实现：</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">        mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是常用的二分法的代码实现，但是在这里我们仍然有很多要注意的地方：</p>
<h3 id="while的循环条件与start-end更新">while的循环条件与start
end更新</h3>
<p>有时候会疑惑循环不变量中我们什么时候使用<code>&lt;</code>或<code>&lt;=</code>。而在start和end的更新中不知道什么时候使用<code>+1</code>或<code>-1</code>或不变。我们需要理解什么情况下怎么去使用。</p>
<p>当有序数组的数据呈闭区间的时候，即<code>[start,end]</code>。我们令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(start &lt;= end)		<span class="comment">//当我们考虑start=end时，条件必须成立，所以等于关系也是其中的一种情况</span></span><br><span class="line">...</span><br><span class="line">start = mid + <span class="number">1</span>		<span class="comment">//由于每一次的比较中，先前mid的值经过了一次比较，所以需要+1-1来避免重复比较</span></span><br><span class="line">...</span><br><span class="line">end = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当有序数组存在开区间时，如<code>[) (] ()</code>，实际上它们都隐含了一个信息——start!=end，否则区间是不成立的，因此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(start &lt; end)	<span class="comment">//当start=end时，搜索区间实际上是不成立的</span></span><br><span class="line">...</span><br><span class="line">start = ？？？	<span class="comment">//这个和左右的开闭性相关，要考虑什么时候该包括，什么时候不该包括，应该明确有效的搜索区间的范围是什么</span></span><br><span class="line">end = ？？？</span><br></pre></td></tr></table></figure>
<h3 id="二分法解题思路">二分法解题思路</h3>
<p>我们刚刚实现的是<code>bsearch</code>，即二分查找匹配的数值，实际上更多时候我们需要查找的是一个区间，即在数组内查找第一个不小于X的数值的下标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	right = mid <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果程序要求我们返回数组中一个<code>=\&gt;\&gt;=\&lt;\&lt;=</code>某个数的起始下标，实际上可以根据数组的有序性，将他们联系起来：</p>
<ul>
<li><strong>&gt;=</strong>
这个是最基本的我们<code>binary_search</code>的返回值X就是它的左边界，得到答案
X</li>
<li><strong>&gt;</strong> 我们可以把这个问题的转换成，&gt;= x+1
，得到答案X+1</li>
<li><strong>&lt;</strong> 实际上就是&gt;=问题的补集，得到答案(&gt;=x) -
1</li>
<li><strong>&lt;</strong>= 是&gt;问题的补集，我们可以得到答案
（&gt;x）-1</li>
</ul>
<p>以后遇到这种问题，都可以通过这种转换的思想来实现</p>
<h3 id="练习">练习：</h3>
<h4 id="二分查找-1"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704.
二分查找</a></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> mid = end + (start-end)/<span class="number">2</span>;	<span class="comment">//这里的除法我一开始使用了位运算，但是由于这里会涉及到有符号整数的运算，所以不能使用位运算</span></span><br><span class="line">            <span class="type">int</span> num = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(target &gt; num)</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; num)</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.
在排序数组中查找元素的第一个和最后一个位置</a></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">lower_bound</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || left == nums.<span class="built_in">size</span>() || nums[left]!=target )&#123;</span><br><span class="line">            <span class="comment">//当left==len(nums)时，说明数组中没有&gt;=target的数</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">lower_bound</span>(nums,target<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;left,right&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回&gt;=target的第一个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">         <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (end - start)/<span class="number">2</span> + start;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="排列硬币"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/arranging-coins/">441.
排列硬币</a></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">long</span> mid = start + ((end - start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mid*(mid<span class="number">+1</span>)/<span class="number">2</span> &lt;= n)	<span class="comment">//更新比较条件</span></span><br><span class="line">                start = mid <span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start<span class="number">-1</span>;		<span class="comment">//由于得到的是大于n的阶层数，所以想要得到能完整标识的阶层数要-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="有效的完全平方数"><a
target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/">367.
有效的完全平方数</a></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = num;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="type">long</span> mid = start + ((end -start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mid*mid==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &gt;num)&#123;</span><br><span class="line">                end = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid <span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/07/58-Y86-64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/07/58-Y86-64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-4/" class="post-title-link" itemprop="url">58:Y86-64处理器的实现(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-07 13:53:36" itemprop="dateCreated datePublished" datetime="2025-07-07T13:53:36+08:00">2025-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-08 21:18:02" itemprop="dateModified" datetime="2025-07-08T21:18:02+08:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">处理器体系结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接着上一次的内容，中间有一段时间在忙着搞大作业的内容，所以就没继续搞这个了。今天我们将具体实现Y86-64的设计。</p>
<h2 id="异常处理">异常处理</h2>
<p>异常控制流导致程序正常的执行流程被破坏掉。异常可以有程序内部产生，也可以由某个外部中断产生。我们的指令集主要包括三种类型：</p>
<ul>
<li>halt指令</li>
<li>非法指令和功能码组合的结果</li>
<li>取指或数据读写访问了非法地址</li>
</ul>
<p>我们需要考虑的问题也比较简单：</p>
<ol type="1">
<li><p>可能有多条指令引起异常。例如取指阶段遇到halt指令，然后访存阶段遇到了非法地址的访问。这个时候我们的处理器应该向操作系统返回哪个异常呢？我们的基本原则是：<strong>由流水线中最深的指令引起的异常，优先级最高</strong>，所以这里我们应该返回非法地址访问的异常</p></li>
<li><p>当取出一条指令时，开始执行时，导致了一个异常，而后来由于分支预测错误，取消了该指令。例如：</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	xorq %rax,%rax</span><br><span class="line">	jne target			;处理器默认选择分支</span><br><span class="line">	irmovq $1,%rax</span><br><span class="line">	halt</span><br><span class="line">target:</span><br><span class="line">	.byte oxFF			;非法地址</span><br></pre></td></tr></table></figure>
<p>流水线默认选择分支，在译码阶段会发现一个非法指令异常。但是之后又会发现不应该预测分支，流水线控制逻辑会取消该指令。但是我们想要避免这个异常</p>
<ol start="3" type="1">
<li>流水线化的处理器会在不同的阶段更新系统状态的不同部分。有可能会出现这个情况，一个指令导致了一个异常，可是后面的指令在这个异常前改变了部分的状态。比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">irmovq $1,%rax</span><br><span class="line">xorq %rsp,%rsp		;CC=b100</span><br><span class="line">pushq %rax			;假设此时的栈顶在0xfffffffffffffff8</span><br><span class="line">addq %rax,%rax		;CC=b000</span><br></pre></td></tr></table></figure>
<p>当push时，由于栈顶的移动会导致地址异常，同时addq此时位于执行阶段，它将条件码设置成了新的值。这就违反了异常指令之后所有指令不能影响系统状态的要求。</p>
<p>现在我们明确了我们需要解决的问题，首先需要避免由于分支预测错误取出的指令造成异常。所以我们要在每个流水线寄存器中包括一个状态码stat。如果一个指令在某个阶段中产生了一个异常，这个状态字段就被设置为异常的种类。异常和其他信息一起随着流水线传播，直到写回才发现异常，停止执行。</p>
<p>为了避免异常指令之后的指令更新任何程序员可见的状态，当访存或写回阶段中导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或是数据内存。</p>
<p>所以综上所述，当流水线有一个或多个阶段产生异常时，信息只是简单的存放在流水线寄存器的状态字段中。异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线后面的指令更新程序员可见的状态（条件码寄存器和内存），直到异常指令到最后的写回阶段。由于指令到达写回阶段的顺序就是异常发生的顺序，所以我们可以保证第一个发生异常的指令可以第一个到达写回阶段。如果取出了某条指令，过后又被取消了，那么所有的关于这条指令的异常信息都会被取消。所有导致异常的指令后面的指令都不能改变程序员可见的状态。携带指令的异常状态以及所有其他信息通过流水线的简单原则是处理异常的简单可靠的机制。</p>
<h2 id="pipe各个阶段实现">PIPE各个阶段实现</h2>
<p>PIPE的具体实现和之前SEQ的实现基本差不多，只不过PIPE的每个状态都叫上了前缀。如”<code>D_</code>“表示源值，信息来自流水线D寄存器，而<code>"d_"</code>表示结果值，表明它是在译码阶段产生的。</p>
<h3 id="pc选择和取指阶段">PC选择和取指阶段</h3>
<p>这个阶段用于选择程序计数器的当前值，用于预测下一个PC值。由于从内存中读取指令和抽取不同的字段的硬件单元一样，我就不重复了。</p>
<figure>
<img src="https://s2.loli.net/2025/07/07/WHL6fJeNjBOUvdQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>PC选择逻辑从三个程序计数器源中进行选择。当程序分支预测错误时，从M_valA中读出valP(不跳转的话本应执行的地址)。当ret指令进入写回阶段时，会从W_valM中读出返回地址。其他情况则会使用F阶段寄存器中的predPC的值，我们可以选择PC的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f_pc </span></span><br><span class="line"><span class="comment"># 分支预测有误则回退</span></span><br><span class="line"><span class="keyword">if</span> M_icode == JXX &amp;&amp; !M_Cnd:</span><br><span class="line">    f_pc = M_valA</span><br><span class="line"><span class="comment"># RET在写回阶段</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> W_icode == RET:</span><br><span class="line">    f_pc = W_valM</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    f_pc = F_predPC</span><br></pre></td></tr></table></figure>
<p>PC的预测逻辑则很简单。当函数为调用或跳转时，使用valC。否则用valP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># F_predPC</span></span><br><span class="line"><span class="keyword">if</span> f_icode <span class="keyword">in</span> [JXX,CALL]:</span><br><span class="line">    F_predPC = valC		</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    F_predPC = valP</span><br></pre></td></tr></table></figure>
<p>关于<code>Instr valid  Need regids  Need valC</code>的逻辑块则和SEQ一样。</p>
<p>同时我们需要根据这些信息来确定程序的状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f_stat</span></span><br><span class="line"><span class="comment"># 检查指令地址越界</span></span><br><span class="line"><span class="keyword">if</span> imem_error:</span><br><span class="line">    f_stat = SADR</span><br><span class="line"><span class="comment"># 检查icode是否存在</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> !instr_valid:</span><br><span class="line">    f_stat = SINS</span><br><span class="line"><span class="comment"># 检查手动中断</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> f_icode == HALT:</span><br><span class="line">    f_stat = SHLT</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    f_stat = SAOK</span><br></pre></td></tr></table></figure>
<h3 id="译码和写回阶段">译码和写回阶段</h3>
<figure>
<img src="https://s2.loli.net/2025/07/07/7U8ZdiBPtMAqXRr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>标号为<code>"srcA" "srcB" "dstM" "dstE"</code>的逻辑块我们在SEQ中已经实现过，基本不需要什么改动。不过我们也需要注意到，dstE和dstM写端口的寄存器ID不再是直接使用译码阶段所产生的，而是使用来自写回阶段的信号（W_dstE和W_dstM），这是因为我们希望写的目的寄存器是由写回阶段产生的。</p>
<p>不过这个阶段难在转发逻辑的实现上，尤其是”Sel+FwdA”块，不仅要实现valA的转发逻辑，还要实现valA和valP的合并。这两个信号之所以可以合并是因为，只有call和跳转指令才会用到valP的值，且不需要寄存器文件中读出来的值。这个选择通过icode信号可以控制实现。</p>
<p>接下来我们整理一下转发源和目的寄存器的关系以实现转发逻辑：</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>数据字</strong></th>
<th style="text-align: center;">寄存器ID</th>
<th style="text-align: center;">源描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">e_valE</td>
<td style="text-align: center;">e_dstE</td>
<td style="text-align: center;">ALU输出</td>
</tr>
<tr>
<td style="text-align: center;">m_valM</td>
<td style="text-align: center;">M_dstM</td>
<td style="text-align: center;">内存输出</td>
</tr>
<tr>
<td style="text-align: center;">M_valE</td>
<td style="text-align: center;">M_dstE</td>
<td style="text-align: center;">访存阶段未对E进行的写</td>
</tr>
<tr>
<td style="text-align: center;">W_valM</td>
<td style="text-align: center;">W_dstM</td>
<td style="text-align: center;">写回阶段未对M进行的写</td>
</tr>
<tr>
<td style="text-align: center;">W_valE</td>
<td style="text-align: center;">W_dstE</td>
<td style="text-align: center;">写回阶段未对E进行的写</td>
</tr>
</tbody>
</table>
<p>如果不满足任何的转发条件，就是用原来的<code>d_rvalA</code>作为输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d_valA</span></span><br><span class="line"><span class="comment"># 注意这里的判断是有优先级的，阶段越浅的数据优先级越高，因为后执行的指令可能会覆盖先执行的指令的数据内容。同阶段的优先级需要特殊考虑</span></span><br><span class="line"><span class="keyword">if</span> D_icode <span class="keyword">in</span> [JXX,CALL]:</span><br><span class="line">    d_valA = D_valP</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcA == e_dstE:</span><br><span class="line">    d_valA = e_valE</span><br><span class="line"><span class="comment"># popq %rsp会试图将两个值写入同一个寄存器中，valE是计算后的数据，有限考虑会造成冲突，与事实不符</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcA == M_dstM:</span><br><span class="line">    d_valA = m_valM</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcA == M_dstE</span><br><span class="line">	d_valA = M_valE</span><br><span class="line"><span class="comment"># 内存访问的值W_valM比计算出的值W_valE更&quot;新鲜&quot;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcA == W_dstM:</span><br><span class="line">    d_valA = W_valM</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcA == W_dstE:</span><br><span class="line">    d_valA = W_valE</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    d_valA = d_rvalA</span><br></pre></td></tr></table></figure>
<p>同理我们可以写出d_valB的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d_valB</span></span><br><span class="line"><span class="keyword">if</span> d_srcB == e_dstE:</span><br><span class="line">    d_valB = e_valE</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcB == M_dstM:</span><br><span class="line">    d_valB = m_valM</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcB == M_dstE:</span><br><span class="line">    d_valB = M_valE</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcB == W_dstM:</span><br><span class="line">    d_valB = W_valM</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> d_srcB == W_dstE:</span><br><span class="line">    d_valB = W_valE</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    d_valB = d_rvalB</span><br></pre></td></tr></table></figure>
<p>然后就是写回阶段的逻辑，写回阶段基本是不用保持不变的。其中Stat需要根据W中的状态值计算出来，因为W保存着最近完成的指令的状态，所以我们需要用这个信号来表示整个处理器的状态。不过也要考虑写回阶段有气泡时。这也是一种正常状态，我们可以写出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stat</span></span><br><span class="line"><span class="keyword">if</span> W_stat == SBUB:</span><br><span class="line">    Stat = AOK</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Stat = W_stat</span><br></pre></td></tr></table></figure>
<h3 id="执行阶段">执行阶段</h3>
<figure>
<img src="https://s2.loli.net/2025/07/07/zZXk1A9S7NfsDWr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这一部分和SEQ种基本没有什么区别，其中e_dstE和e_valE被作为了指向译码阶段的转发源。不过有一点需要注意，<code>SetCC</code>不仅由icode控制，同时还以<code>m_stat</code>和<code>W_stat</code>作为输入。这样可以实现，当一条导致异常的指令通过后面的流水线时，任何对条件码的更新都会被停止。</p>
<h3 id="访存阶段">访存阶段</h3>
<figure>
<img src="https://s2.loli.net/2025/07/07/IMmUTFY2XQpDe6B.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>访存阶段中SEQ和PIPE的逻辑基本差不多，区别在于，这里用了很多流水线的数值用来向译码阶段做转发源。同时我们在这里来验证程序地址的合理性从而计算<code>m_stat</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># m_stat</span></span><br><span class="line"><span class="keyword">if</span> dmem_error:</span><br><span class="line">    m_stat = SADR</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    m_stat = M_stat</span><br></pre></td></tr></table></figure>
<h2 id="流水线的控制逻辑">流水线的控制逻辑</h2>
<p>现在我们要创建我们的流水线控制逻辑，以完成我们处理器设计，我们需要处理以下四种情况，这是我们无法通过分支预测和数据妆发处理的：</p>
<ul>
<li><strong>加载/使用冒险：</strong>在一条从内存中读出一个值的指令和一条使用该值的指令之间，流水线必须暂停一个周期</li>
<li><strong>处理ret：</strong>流水线必须暂停直到ret指令到达写回阶段</li>
<li><strong>预测错误的分支：</strong>再分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经进入流水线了。必须取消这些命令，并从跳转指令后面的那条指令开始取指。</li>
<li><strong>异常：</strong>当一条指令导致异常，我们想要禁止后面的指令更新程序员可见的状态，并且再异常指令到达写回阶段时，停止执行。</li>
</ul>
<p>我们先设计每种情况所期望的行为，然后再设计处理些情况的控制逻辑：</p>
<h3 id="特殊控制情况所期望的处理">特殊控制情况所期望的处理</h3>
<ul>
<li><p><strong>加载/使用冒险：</strong></p>
<p>只有mrmovq和popq指令会从内存中读取数据。当这两条指令中的任一一条处于执行阶段时，并且需要该目的寄存器的指令正处在译码阶段时（此时我们无法完成数据转发）。我们需要将第二条指令阻塞在译码阶段，并在下一个周期，往执行阶段中插入一个气泡。此后转发逻辑会解决这个数据冒险，可以将流水线寄存器D保持为固定状态，从而将一个指令阻塞在译码阶段。这样做还可以保证流水线寄存器F保持在固定状态，由此第二条指令会被再取指一次。总而言之我们需要保持流水线寄存器F和D不变，并在执行阶段中差插入气泡。</p></li>
<li><p><strong>处理ret：</strong></p>
<p>对ret指令的处理，我们需要将流水线停顿三个时钟周期，直到ret经过了访存阶段，读出返回地址。我们遇到ret时会默认PC新值为valP，也就是下一条指令地址。然后会对下一条指令进行取指，在下一条指令的译码阶段会被插入气泡，空转三个周期。</p></li>
<li><p><strong>分支预测错误：</strong></p>
<p>当跳转指令执行到执行阶段时就可以检测到预测错误。然后在下一个周期，控制逻辑会在译码和执行阶段插入气泡，取消两条不正确的已取指令。在同一个时钟周期，流水线将正确的指令读取到取指阶段。</p></li>
<li><p><strong>异常：</strong></p>
<p>我们必须保证，在前面的所有的指令结束前，后面的指令不能影响程序的状态。当异常发生时，我们的stat信息作为指令状态的一部分记录下来，并且继续取指译码和执行命令。当异常指令到达访存阶段时，我们采取措施防止之后的指令会修改程序员可见的状态：（1）禁止执行阶段设置条件码（2）向内存中插入气泡，禁止数据向内存中写入（3）当写回阶段中有异常指令时，暂停写回阶段，暂停流水线。这样我们实现了异常发生之前的指令完成，异常发生之后的指令不对程序员可见的状态进行修改。</p></li>
</ul>
<h3 id="发现特殊控制条件">发现特殊控制条件</h3>
<p>总结一下各个特殊控制触发的条件：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">条件</th>
<th style="text-align: center;">触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">处理ret</td>
<td style="text-align: center;">IRET∈{D_icode,E_icode,M_icode}</td>
</tr>
<tr>
<td style="text-align: center;">加载/使用冒险</td>
<td
style="text-align: center;">E_icode∈{MRMOVL,POPL}&amp;&amp;E_dstM∈{d_srcA,d_srcB}</td>
</tr>
<tr>
<td style="text-align: center;">预测错误的分支</td>
<td style="text-align: center;">E_icode==JXX&amp;&amp;!e_Cnd</td>
</tr>
<tr>
<td style="text-align: center;">异常</td>
<td
style="text-align: center;">m_stat∈{SADR,SINS,SHLT}||W_stat∈{SADR,SINS,SHLT}</td>
</tr>
</tbody>
</table>
<h3 id="流水线控制机制">流水线控制机制</h3>
<p>我们对流水线控制需要使用两个最简单的机制：暂停和气泡。它们分别将指令阻塞在流水线寄存器中（让真个流水线暂时停滞），或是往流水线中插入一个气泡（用空操作替换错误指令）。</p>
<figure>
<img src="https://s2.loli.net/2025/07/08/YzEkVrC5Gf8qX2c.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>在<strong>正常操作</strong>下，这两个输入都设为0，使得寄存器加载它的输入作为新的状态。</li>
<li>在<strong>暂停</strong>时，将暂停信号设置为1，禁止更新状态。</li>
<li>在<strong>气泡</strong>时，将气泡信号设置为1，寄存器状态会设置成一个固定的复位配置，得到一个等效于nop的状态</li>
<li>当暂停信号和气泡信号都设为1时会导致错误</li>
</ul>
<p>当我们遇到特定的条件时，我们可以将各个阶段的流水线状态设置为以下情况，以控制流水线逻辑：</p>
<table>
<thead>
<tr>
<th>条件/流水线寄存器</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ret</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用冒险</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>暂停后面跟气泡时为了取消进入该阶段的指令，避免产生影响</p>
<h3 id="控制条件的组合">控制条件的组合</h3>
<p>我们在之前的讨论中，默认一个时钟周期只能出现一个特殊情况，实际上，一个时钟周期可能会同时出现多种特殊情况的组合。我们把所有可能出现的特殊情况列出来，讨论它们组合的可能性。</p>
<figure>
<img src="https://s2.loli.net/2025/07/08/cLxUaK9lGoPA1RJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从这里我们可以看出大多数的控制条件之间是互斥的。加载/使用要求执行阶段是加载指令，预测错误要求执行阶段是跳转指令，所以是冲突的。ret的另外两种情况也是同理。所以实际上只有组合A和组合B可能会出现。</p>
<p>组合A中执行阶段有一条不选择分支的跳转指令，而译码阶段有一条ret指令，这种组合要求ret位于不选择分支的目标处。流水线控制逻辑发现分支预测错误，因此要取消ret指令。由此我们可以得出控制逻辑的控制动作</p>
<table>
<thead>
<tr>
<th>条件/流水线寄存器</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ret</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合A</td>
<td>暂停</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>因为下一个周期，PC选择逻辑会跳转到后面那条指令的地址，所以流水线寄存器F的保存的内容是无所谓的，因为正确的取指会覆盖他，错误的旧值会被取消。</p>
<p>组合B中包括一个加载/使用冒险，其中加载指令设置%rsp，然后ret用这个寄存器作为原操作数，因为它必须从栈中弹出返回地址。所以流水线控制逻辑应该将ret指令阻塞在译码阶段。我们看下组合B的控制逻辑的控制动作：</p>
<table>
<thead>
<tr>
<th>条件/流水线寄存器</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ret</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用冒险</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合B</td>
<td>暂停</td>
<td>气泡+暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>期望的情况</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>这里我们发现组合B需要进行特殊的处理。我们可以看到，在组合B的译码阶段，控制动作将寄存器的气泡信号和暂停信号同时设置成了1，这会导致错误。</p>
<p>实际上，我们在组合B中应该优先处理加载/使用冒险，我们要优先确保数据被成功加载后，再进行使用。所以这里将ret的处理推迟了一个周期。</p>
<h3 id="控制逻辑的实现">控制逻辑的实现</h3>
<p>下图是流水线控制逻辑的整体结构，根据流水线寄存器和流水线阶段的信号，控制逻辑产生流水线寄存器的暂停和气泡控制信号，同时决定是否更新条件码寄存器。</p>
<figure>
<img src="https://s2.loli.net/2025/07/08/1beOXESgTGwAFyt.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>接下来我们将控制条件和控制动作结合起来，产生各个流水线控制信号的描述：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># F_stall</span></span><br><span class="line">	<span class="comment"># 加载/使用冒险</span></span><br><span class="line"><span class="keyword">if</span> (E_icode <span class="keyword">in</span> [MRMOVQ,POPQ] <span class="keyword">and</span> E_dstM <span class="keyword">in</span> [d_srcA,d_srcB]):</span><br><span class="line">    F_stall = <span class="number">1</span></span><br><span class="line">	<span class="comment"># ret处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> RET <span class="keyword">in</span> [D_icode,E_icode,M_icode]:</span><br><span class="line">    F_stall = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># D_stall</span></span><br><span class="line">	<span class="comment"># 加载/使用冒险</span></span><br><span class="line"><span class="keyword">if</span> (E_icode <span class="keyword">in</span> [MRMOVQ,POPQ] <span class="keyword">and</span> E_dstM <span class="keyword">in</span> [d_srcA,d_srcB]):</span><br><span class="line">    D_stall = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>遇到预测错误和ret指令时，流水线寄存器D必须设置成气泡。不过前面提到的对于加载/使用冒险和ret的组合，我们需要将流水线寄存器设置成暂停</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># D_bubble</span></span><br><span class="line">	<span class="comment"># 排除组合状态</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (E_icode <span class="keyword">in</span> [MRMOVQ,POPQ] <span class="keyword">and</span> E_dstM <span class="keyword">in</span> [d_srcA,d_srcB]):</span><br><span class="line">	<span class="keyword">if</span> RET <span class="keyword">in</span> [D_icode,E_icode,M_icode]:</span><br><span class="line">        D_bubble = <span class="number">1</span></span><br><span class="line">	<span class="comment"># 分支预测错误</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> E_icode == JXX &amp;&amp; !e_Cnd:</span><br><span class="line">    D_bubble</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># E_bubble</span></span><br><span class="line">	<span class="comment"># 分支预测错误</span></span><br><span class="line"><span class="keyword">if</span> E_icode == JXX &amp;&amp; !e_Cnd:</span><br><span class="line">    E_bubble = <span class="number">1</span></span><br><span class="line">	<span class="comment"># 加载/冒险使用</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (E_icode <span class="keyword">in</span> [MRMOVQ,POPQ] <span class="keyword">and</span> E_dstM <span class="keyword">in</span> [d_srcA,d_srcB]):</span><br><span class="line">    E_bubble = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同时为了避免异常后的指令更新了程序状态，我们设置条件码不被整数操作设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set_cc</span></span><br><span class="line"><span class="keyword">if</span> E_icode == OPq:</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> m_stat <span class="keyword">in</span> [SADR,SINS,SHLT] <span class="keyword">and</span> <span class="keyword">not</span> W_stat <span class="keyword">in</span> [SADR,SINS,SHLT]):</span><br><span class="line">        set_CC = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同时，在下一个周期需要向访存阶段插入气泡，因为如果访存或写回阶段有异常时，我们不希望其他的指令改变了内存状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># M_bubble</span></span><br><span class="line"><span class="keyword">if</span> m_stat <span class="keyword">in</span> [SADR,SINS,SHLT]:</span><br><span class="line">    M_bubble = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> W_stat <span class="keyword">in</span> [SADR,SINS,SHLT]:</span><br><span class="line">    M_bubble = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>为了在写回阶段将异常提交到异常处理程序，所以我们也需要在异常指令到达W阶段时，阻塞整个流水线。从而实现异常之前的指令都被完成，后续的指令像没执行过一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># W_stall</span></span><br><span class="line"><span class="keyword">if</span> W_stat <span class="keyword">in</span> [SADR,SINS,SHLT]:</span><br><span class="line">    W_stat</span><br></pre></td></tr></table></figure>
<p>至此，我们处理器的流水线控制逻辑就实现了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">176k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:39</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
