<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/100-%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/100-%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">100:感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 20:18:05" itemprop="dateCreated datePublished" datetime="2025-11-22T20:18:05+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:19" itemprop="dateModified" datetime="2025-11-29T13:49:19+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>也是好不容易水到第100篇了，我本来准备了好多台词的，但是不知道说什么。我就记录一下我的几个感悟吧</p>
<h3 id="学会放弃">学会放弃</h3>
<p>刚开始觉得只要努力学就会有所收获吧，如果没学会就是自己比较笨什么的。但事实不是这样的，认知一个领域的过程是循序渐进的，就像游戏里的科技树一样，解锁一个科技需要一大堆前置科技。有时候一些知识也是这样，所以一开始学不会一些东西很正常，这个时候应该先放一放，去试试其他的方向，或者是从前置的内容开始学。</p>
<p>关于这一点我的感受就很明显吧，我每次遇到学不会的东西，就会放弃然后去学其他的东西。但是过一段时间之后再来看这些内容反而有一种水到渠成的感觉，我猜测一个是知识体系上的补齐，还有一个是你对这个领域的认知能力也在慢慢变强。你能对一些内容做出自己的解释，能说服自己我认为是理解一个知识的开始吧。不管你的猜想是不是对的，只要他能补齐你对这方面的认识，你就可以视作自己理解了。之后随着需求和认知的提升，再一步步完善自己对这方面的理解吧。</p>
<p>我发现生活中也有很多这样的事情，给你一种无从下手或者无能为力的感觉。如果实在不行就放弃吧，可以之后再试试，先把其他的事情做好，也许很多事情时间会给出答案，因为我们每天都在慢慢长大。只要不放弃从头再来的决心，迟早有一天也能找到自己的答案。</p>
<h3 id="主动学习">主动学习</h3>
<p>大家都在学习凭什么，也不存在谁比谁笨，为什么有的人能学会有的人不能呢？我认为这不是努不努力的事情，大家回宿舍都是打游戏，如果能认真学下去，活该他学的好。我觉得更多是对于这个知识的态度吧，有的人是被动的接受的，有的人是主动的接受的。主动接受的话你就会发现很多问题啥的，就是你的脑子里的东西和答案不一样，或者你脑子里没有这个东西。在这个不断碰撞思考的过程中，你的知识体系会被答案说服或者补全，这样你的认知体系就会慢慢完善，感觉这个就是高中老师说的框架/查漏补缺，这个就是主动学习。但是大多数人就是书上讲得是啥就是啥，老师说啥就是啥，一上来就记住正确答案，对知识很内容知其然不知其所以然，这种效率就很差。中国传统的应试教育就是这样的，所以大家都是这样的，我也是这样的。</p>
<p>这也是为什么比起看网课我更喜欢看书，看网课的时候，老师叽里咕噜讲个不停，你很难有自己思考的时间，更别说有时候发呆什么的。但是看书不一样，你不懂得时候可以对着书上得那句话发呆，等你发完呆它还在那里，你就有充分得时间去理解它，或者再来一遍。就是这个时候你的大脑是属于你自己的，你的想法不是跟着别人走的，更自由一点。这样你就能做出更多自己的思考。</p>
<p>我知道这样子很不好，但是有时候动脑子真的好累，偶尔主动学习一些重要的东西也还行。我的话有时候突然想做项目或者刷视频看到什么好帅的东西，我会迫不及待的去了解一下。主要是对游戏方面感兴趣一点</p>
<h3 id="要有耐心">要有耐心</h3>
<p>就是电视上和老师经常说的要坐的住冷板凳吧，有时候学一些东西确实挺牢的，就是很无聊，知识从脑袋里滑走了。这个时候就是看你有没有耐心了，感觉这个和我第一条说的是相反的，按道理这种情况是要放弃的，但是有时候就是不太想放弃，你就需要耐心一点。所以这么看来放弃是一件很理性的事情，坚持反而是一件很感性的事情。回到正题，我想说的是，人生的常态就是失败和无聊，但是不耐心去做一件事的话就会错过很多东西。什么时候放弃，什么时候坚持是一件很哲学的问题吧。我到这里也不知道说什么好了。</p>
<p>今天就暂时写到这些吧，希望之后的时间也能继续加油。现在虽然学了很多东西，但是没办法把知识串联在一起，也有点迷茫。有时候分析一些问题的时候，反而会因为知道的太多而被绕进去。就像之前不知道从哪里看到的三大境界：</p>
<ul>
<li>看山是山 看水是水</li>
<li>看山不是山 看水不是水</li>
<li>看山还是山 看水还是水</li>
</ul>
<p>我现在可能介于一二之间吧，很难受，技术不到家，看很多东西都是残破不堪的，漏洞百出，我自己也知道。希望以后能慢慢解决这个这个问题吧。还有就是我现在也遇到了一些生活中难以解决的问题，我也不知道怎么做，在迷茫的时候还是要坚定的提升自己，也许以后时间会给出答案吧。之后也要继续加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/22/99-%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/22/99-%E5%9B%BE/" class="post-title-link" itemprop="url">99:图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-22 11:15:14" itemprop="dateCreated datePublished" datetime="2025-11-22T11:15:14+08:00">2025-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:11" itemprop="dateModified" datetime="2025-11-29T13:49:11+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天接着来认识一下图，结束了图的学习，数据结构的部分就告一段落了。之后就是涉及到一些基本的算法问题，感觉也会越来越难。</p>
<h1 id="图">图</h1>
<h2 id="认识图">认识图</h2>
<p>和之前的数据结构不同，图是一种非线性的结构，由顶点和边组成，以下面为例，我们可以将图G抽象的表示成一组顶点和一组边的集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">E = &#123;(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>)&#125;</span><br><span class="line">G = &#123;V,E&#125;</span><br></pre></td></tr></table></figure>
<p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数
据结构。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/6ASNIDxnhqC7tKo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="图的常见类型和术语">图的常见类型和术语</h3>
<p>结合不同的场景，我们可以从不同的角度对图进行分类：</p>
<ul>
<li>根据边是否具有方向，分为有向图和无向图</li>
<li>根据顶点直接是否全部联通，分为联通图和非联通图</li>
<li>根据边上的权重，非为无权图和有权图</li>
<li>….</li>
</ul>
<p>在不同的场景中我们选择合适的类型，来解决问题。</p>
<p>图的数据结构有以下常用术语：</p>
<ul>
<li><strong>邻接：</strong>当两顶点之间存在边相连时，称这两个顶点邻接</li>
<li><strong>路径：</strong>从顶点A到顶点B经过的边构成的序列被称为从A到B的路径</li>
<li><strong>度：</strong>一个顶点拥有的边数。对有向图，根据边的方向，还分为入度和出度。</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>图通常使用两种表示方式，我们这里均以无向图为例：</p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>设图的顶点数量为𝑛，邻接矩阵使用一个n×n大小的矩阵来表示图，每一行（列）代
表一个顶点，矩阵元素代表边，用1或0表示两个顶点之间是否存在边。</p>
<p>设邻接矩阵为𝑀、顶点列表为𝑉
，那么矩阵元素𝑀[𝑖,𝑗]=1表示顶点𝑉[𝑖]到顶点𝑉[𝑗]
之间存在边，反之𝑀[𝑖,𝑗]=0表示两顶点之间无边。</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/3i1YVTLzGIZHjQr.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>邻接矩阵有以下性质：</p>
<ul>
<li>在简单图中，顶点不能和自己相连，所以邻接矩阵主对角线上的元素是没有意义的</li>
<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称</li>
<li>将邻接矩阵的元素替换成权重就是有权图</li>
</ul>
<h4 id="邻接表">邻接表</h4>
<p>邻接表使用n个链表来表示图，链表节点表示顶点。第i个链表对应顶点i，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。如下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/1W6QDdhbJVTZUYE.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="两种表示方法的比较">两种表示方法的比较</h4>
<p>对于邻接矩阵，我们可以直接访问矩阵元素实现对边的CRUD，时间效率高达<span
class="math inline"><em>O</em>(1)</span>。但是矩阵存储的空间复杂度为<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></p>
<p>对于邻接表，由于表中只存储实际已存在的边数，而边数通常小于<span
class="math inline"><em>n</em><sup>2</sup></span>，所以空间存储的效率上来看，邻接表要更加的节省空间。但是对于CRUD的操作，邻接表需要通过遍历搜索的方式来进行，所以时间效率更差。</p>
<p>但是结合先前的只是，对于这种链表较长的情况，我们可以将它优化成哈希表或者AVL树等结构，实现对时间效率的优化，所以对于大规模的图的使用场景，邻接表也更加普遍。</p>
<h2 id="图的基本操作">图的基本操作</h2>
<p>图的操作主要可以分为对顶点和对边的操作，这里分别通过邻接矩阵和邻接表的方式进行实现。</p>
<h3 id="基于邻接矩阵的实现">基于邻接矩阵的实现</h3>
<p>给定给一个顶点数量为n的无向图，我们需要完成以下操作：</p>
<ul>
<li><strong>添加或删除边：</strong>直接在邻接矩阵修改指定的边，只不过要注意同时更新两个方向的边（无向图）</li>
<li><strong>添加顶点：</strong>在邻接矩阵的尾部添加一行一列，并初始化为0即可。</li>
<li><strong>删除顶点：</strong>在邻接举证中删除一行一列，将剩下的元素向左上补齐。对于最坏的情况（删除首行首列）需要移动<span
class="math inline">(<em>n</em> − 1)<sup>2</sup></span>个元素</li>
<li><strong>初始化：</strong>传入n个顶点，初始化长度为n的顶点列表和nxn大小的邻接矩阵</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/zKrGQMe1svBL9jY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMap</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vertices;           <span class="comment">// 顶点列表</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMat;     <span class="comment">// 邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphMap</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> val : vertices)</span><br><span class="line">                <span class="built_in">addVertex</span>(val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;edge : edges)</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">            <span class="comment">// 向邻接矩阵中添加一行</span></span><br><span class="line">            adjMat.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row: adjMat)</span><br><span class="line">                row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除行</span></span><br><span class="line">            adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">            <span class="comment">// 删除列</span></span><br><span class="line">            <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat)</span><br><span class="line">                row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>() || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">size</span>() || i==j)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">            adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">            adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="基于邻接表的实现">基于邻接表的实现</h3>
<p>设无向图的顶点总数为n、边总数为m，我们需要完成以下操作：</p>
<ul>
<li><strong>添加边：</strong>在顶点对应链表的末尾添加边就行了。但是要注意无向图要加两个方向的边</li>
<li><strong>删除边：</strong>在顶点管理的链表中查找并删除指定的边。无向图中删两个方向。</li>
<li><strong>添加顶点：</strong>在邻接表中添加一个链表，并将新增顶点作为链表头节点</li>
<li><strong>删除顶点：</strong>遍历整个邻接表，删除包含指定顶点的所有边</li>
<li><strong>初始化：</strong>在邻接表中创建n个顶点和2m条边</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/22/eZVmQvChWyGikj2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>以下是邻接表的代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        unordered_map&lt;Vertex* ,vector&lt;Vertex*&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex*&gt; &amp;vec, Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i]==vet)&#123;</span><br><span class="line">                    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">GraphList</span>(<span class="type">const</span> vector&lt;vector&lt;Vertex*&gt;&gt; &amp;edges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> vector&lt;Vertex *&gt; &amp; edge: edges)&#123;</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">addEdge</span>(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            adjList[vet] = <span class="built_in">vector</span>&lt;Vertex*&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex* vet)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;adj : adjList)</span><br><span class="line">                <span class="built_in">remove</span>(adj.second,vet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">            adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex* vet1, Vertex* vet2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1==vet2)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet1],vet2);</span><br><span class="line">            <span class="built_in">remove</span>(adjList[vet2],vet1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里为了方便，我们使用动态数组代替了链表。用哈希表来表示邻接表结构。</p>
<p>同时需要注意在邻接表中我们使用<code>Vertex</code>类来表示顶点，也是为了方便。如果我们使用列表索引来区分不同德顶点的话，那么每当我们删除一个索引为i的顶点，就需要遍历整个邻接表，把所有索引大于i的顶点重新更新一遍，这样的话效率就很差。</p>
<h2 id="图的遍历">图的遍历</h2>
<p>树代表的是一对多的关系，图代表的是多对多的关系，所以我们可以将树视作图的一个特例。所以说树的遍历操作实际上也是图的遍历操作的一种特例。</p>
<p>和树类似的，我们有两种遍历方式实现对图的遍历操作：广度优先遍历和深度优先遍历</p>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外
扩张。以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/T2MS6rYJNOWeIGb.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻
接顶点，以此类推，直至所有顶点访问完毕。</p>
<h4 id="算法实现">算法实现</h4>
<p>BFS通常需要一个辅助队列来实现，通过队列先进先出的性质，实现BFS由近及远的思路。我们的实现流程如下：</p>
<ul>
<li>将遍历起始顶点<code>startVet</code>加入队列中，开始循环</li>
<li>在每次迭代中，弹出队首顶点并访问，将该顶点的所有邻接点加入到队列尾部</li>
<li>循环上一步，知道队列为空</li>
</ul>
<p>同时我们还需要一个哈希集合<code>visited</code>来记录哪些节点被访问，以防止重复遍历顶点。</p>
<p>我们的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphBFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    vector&lt;Vertex*&gt; res;				<span class="comment">// 返回的顶点序列</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;		 <span class="comment">// 哈希集合,用来记录被访问过的顶点	</span></span><br><span class="line">    queue&lt;Vertex*&gt; que;					<span class="comment">// 辅助队列	</span></span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Vertex* vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> adjVet : graph.adjList[vet])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;				<span class="comment">// 跳过已访问的顶点</span></span><br><span class="line">            que.<span class="built_in">push</span>(adjVet);</span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过画图的方法帮助理解一下这个过程</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。以下图为例</p>
<figure>
<img src="https://s2.loli.net/2025/11/22/4BcYNu6gOmpyzfa.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="算法实现-1">算法实现</h4>
<p>这种走到尽头并返回的样式，我们可以通过递归的方式实现。关键在于怎么设置边界条件，退出递归。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(GraphList &amp;graph, unordered_set&lt;Vertex*&gt; &amp;visited,</span></span></span><br><span class="line"><span class="params"><span class="function">         vector&lt;Vertex*&gt; &amp;res, Vertex * vet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 记录访问节点</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);</span><br><span class="line">    <span class="comment">// 标记已访问节点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet);</span><br><span class="line">	<span class="comment">// 遍历所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span>(Vertex* adjVet : graph.adjList[vet])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph,visited,res,adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphDFS</span><span class="params">(GraphList &amp;graph, Vertex* startVet)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex*&gt; res;</span><br><span class="line">    <span class="comment">// 以访问过的顶点</span></span><br><span class="line">    unordered_set&lt;Vertex*&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph,visited,res,startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自己尝试手推一下这个过程，加深理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/18/98-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/18/98-%E5%A0%86/" class="post-title-link" itemprop="url">98:堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-18 15:07:44" itemprop="dateCreated datePublished" datetime="2025-11-18T15:07:44+08:00">2025-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:49:06" itemprop="dateModified" datetime="2025-11-29T13:49:06+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学一种新的数据结构——“堆”，但是貌似和底层原理中的堆并不一样。之前总是略有耳闻，但是一直都很少仔细去了解。</p>
<h1 id="堆">堆</h1>
<p>堆是一种满足特定条件的完全二叉树，根据性质可以分为两种类型：</p>
<ul>
<li>小顶堆：任意节点的值 &lt;= 子节点的值</li>
<li>大顶堆：任意节点的值 &gt;= 子节点的值</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/18/Zjx5Hnc4sqoQYiW.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>堆作为完全二叉树的一个特例，有以下规则：</p>
<ul>
<li>最底层的节点靠左排列，其他层被节点填满。</li>
<li>二叉树的根节点被称为<strong>堆顶</strong>，二叉树底层靠右的节点称为<strong>堆底</strong></li>
<li>对于大(小)顶堆，堆顶元素的值是最大(小)的</li>
</ul>
<h2 id="堆的常用操作">堆的常用操作</h2>
<p>有一种抽象的数据结构——优先队列，定义为具有优先级排序的队列。通常我们会使用堆来实现优先队列，大顶堆就相当于元素按大到小的顺序出队的优先队列。这里我们将其视作等价的数据结构。</p>
<p>这里我们先通过优先队列来认识一下堆的一些操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minheap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxheap;</span><br><span class="line"></span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    maxheap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The size is &quot;</span> &lt;&lt; maxheap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> top = maxheap.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The top is &quot;</span> &lt;&lt; top &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEmpty = maxheap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的可以总结为以下几类：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/7Lgt6pdXfOrTP2V.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="堆的实现">堆的实现</h2>
<p>现在我们尝试从底层实现一个堆，这里我们用大顶堆演示，小顶堆只需要将所有的大小逻辑判断反转即可。</p>
<h3 id="堆的存储和表示">堆的存储和表示</h3>
<p>堆是一种完全二叉树，我们之前提到过完全二叉树十分适合用数组来进行存储，所以这里我们的底层实现选择用数组，和之前的实现一样。我们使用索引的映射公式来代替节点指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问堆顶元素">访问堆顶元素</h3>
<p>堆顶元素就是二叉树的根节点，也就是我们数组的首元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="元素入堆">元素入堆</h3>
<p>给定<code>val</code>，我们将其添加到堆底。但是此时插入的值可能会破坏当前到根节点的路径，导致堆的成立条件被破坏。所以我们需要遍历修复从插入节点到根节点路径上的所有节点，这个过程我们称之为<strong>堆化</strong></p>
<p>从入堆节点开始，我们从底执行堆化。我们依次比较当前节点和父节点的大小，如果插入节点更大就讲他们交换，知道修复所有的节点关系。</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/3OjBe9MCgLIG7sA.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过以下方式实现这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          heap.<span class="built_in">push_back</span>(i);</span><br><span class="line">          <span class="comment">// 从堆底开始堆化</span></span><br><span class="line">          <span class="built_in">siftUp</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">              <span class="type">int</span> p = <span class="built_in">parent</span>(i);</span><br><span class="line">              <span class="keyword">if</span>(p&lt;<span class="number">0</span> || heap[i] &lt;= heap[p])</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="built_in">swap</span>(heap[i],heap[p]);</span><br><span class="line">              <span class="comment">// 向上堆化</span></span><br><span class="line">              i=p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆顶元素出栈">堆顶元素出栈</h3>
<p>堆顶元素是二叉树的根节点，如果我们直接从数组中删除首元素，那么会破坏整个树的树状结构，这导致后续的堆化难以修复。所以我们采取以下步骤将堆顶元素出栈：</p>
<ul>
<li>交换堆顶元素（根节点）和堆底元素（最右元素）</li>
<li>交换完成之后，我们将堆底删除</li>
<li>从根节点开始自顶向底执行堆化</li>
</ul>
<p>自顶向下的堆化和自底向上的堆化逻辑相反，我们将当前节点和较大的子节点进行比较，然后进行交换，直到没有子节点或者无需再交换了：</p>
<figure>
<img src="https://s2.loli.net/2025/11/18/DhigaQdUJ3GnKW5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>出堆的实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// ma为较大的节点</span></span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">left</span>(i), r=<span class="built_in">right</span>(i), ma = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[l])</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i] &lt; heap[r])</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// l,r越界或者i已经是最大节点 则退出堆化</span></span><br><span class="line">        <span class="keyword">if</span>(ma==i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[ma]);</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建堆操作">建堆操作</h3>
<p>我们希望能直接根据一个列表中的所有元素来构建一个堆。我们有两种可行的方案：</p>
<ul>
<li>创建一个空堆，然后遍历列表，对每一个元素都进行入堆操作。但是对于n个元素执行复杂度为<code>O(logn)</code>的入堆操作，时间复杂度会增长到<code>O(nlogn)</code></li>
<li>另一个方法就是，将列表中的元素添加到完全二叉树中，尽管现在的堆的性质并没有被满足。接下来我们倒序遍历堆，并对每个非叶节点进行一次自顶向下的堆化。这样每当我们堆化一个节点之后，都会以该节点为根节点形成一个子堆。</li>
</ul>
<p>这里我们着重分析一下第二种方法。我们可以通过以下方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Heap</span>(vector&lt;<span class="type">int</span>&gt; vec)&#123;</span><br><span class="line">    heap = vec;</span><br><span class="line">    <span class="comment">// 倒序遍历的第一个非叶节点 就是最后一个叶节点的父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">parent</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>); i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">siftDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法下的复杂度被优化到了<code>O(n)</code>，更加的便捷。</p>
<h2 id="top-k问题">Top-k问题</h2>
<p>所谓top-k问题，就是给定一个长度为n的无序数组<code>nums</code>，请返回数组中最大的k个元素。</p>
<p>对于这个问题我们有很多种解决方案：</p>
<h3 id="遍历选择">遍历选择</h3>
<p>我们可以像这样对一个长度为n的序列进行k次遍历，每轮遍历都提取出当前序列中的最大的数据。时间复杂度为<code>O(nk)</code>。当k接近n时，时间复杂度增长到<code>O(n^2)</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/18/upZYUAsJwrt2gcz.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="排序">排序</h3>
<p>先对数组<code>nums</code>进行排序，然后再返回最右边的k个数据。这个方法主要取决于对数组排序的时间复杂度，对于<code>std::sort</code>，这个方法的复杂度是<code>O(nlogn)</code></p>
<h3 id="堆-1">堆</h3>
<p>我们可以基于堆更加高效的完成这个任务，我们遵循以下步骤实现：</p>
<ul>
<li>初始化一个小顶堆，此时其堆顶元素最小。</li>
<li>然后将数组的前k个元素依次入堆</li>
<li>从第k+1个元素开始，如果当前元素大于堆顶元素，我们就将堆顶出堆，并将当前元素入堆。</li>
<li>遍历完成之后，堆中保存的就是最大的k个元素。</li>
</ul>
<p>我们可以写出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">topHeap</span>(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">top</span>() &lt; nums[i])&#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共进行了n轮入堆和出堆，由于堆大小是固定的k，所以我们只需要维护k个元素，所以实际上我们的计算复杂度只有<code>O(nlogk)</code>，在k较小时，我们的时间复杂度约等于<code>O(n)</code></p>
<p>由此可以看到通过堆的思路，对解决<code>TopK</code>问题的显著提升。尤其是对于这种方法，适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现
最大的𝑘个元素的动态更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/17/97-%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="post-title-link" itemprop="url">97:平衡树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-17 20:45:51" itemprop="dateCreated datePublished" datetime="2025-11-17T20:45:51+08:00">2025-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:53" itemprop="dateModified" datetime="2025-11-29T13:48:53+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，接着研究一下AVL树。</p>
<h2 id="avl树">AVL树</h2>
<p>在二叉搜索树中，我们可以知道，在多次的插入和删除之后，二叉树的左右可能会失去平衡，从而导致退化成链表，在这样的情况下我们的算法的效率会从<code>O(logn)</code>退化到<code>O(n)</code>：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/5jRdMzbsJDmt3Z2.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/hxU4EiZFm9HaNOk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>但是我们接下来将要提到的AVL树，将解决这些问题</p>
<h3 id="avl树的常见术语">AVL树的常见术语</h3>
<p>AVL树本质是二叉搜索树和二叉平衡树的结合，所以同时满足这两种树的性质：</p>
<ol type="1">
<li><strong>节点高度</strong></li>
</ol>
<p>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。这里我们让叶子节点的高度为<code>0</code>，把空节点的高度设置为<code>-1</code>。我们将根据这些性质来编写我们的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left&#123;&#125;;</span><br><span class="line">    TreeNode* right&#123;&#125;;</span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span>: val(x) &#123;</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点的高度 = 最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left),<span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>节点的平衡因子</strong></li>
</ol>
<p>节点的平衡因子定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。对于AVL树，我们要求树中任意节点的平衡因子<code>-1&lt;=f&lt;=1</code>，否则这个树就进入了失衡状态。我们可以写出以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">balance</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的旋转">AVL树的旋转</h3>
<p>AVL树的精髓就在于旋转操作，当我们的树中存在失衡节点时，我们可以通过“旋转”操作，在不影响中序遍历序列的前提下，使失衡的节点重新回到平衡的状态。</p>
<p>我们将<code>|平衡因子| &gt; 1</code>的节点称为失衡节点，根据不同的失衡情况，我们有四种旋转操作：</p>
<h4 id="右旋">右旋</h4>
<figure>
<img src="https://s2.loli.net/2025/11/17/OHDbWSA6JQIgBc4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>结合这张图来看，从底至顶看，二叉树中首个失衡节点是“节点3”。我们关注以该失衡
节点为根节点的子树，将该节点记为 node ，其左子节点记为 child
，执行“右旋”操作。完成右旋后，子树
恢复平衡，并且仍然保持二叉搜索树的性质。</p>
<p>但是对于，当节点<code>child</code>有右节点（记作<code>grand_child</code>）的情况下，我们需在右旋中添加一步：将<code>grand_child</code>设置为<code>node</code>的左子节点。</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/J1BOAZhMKVXuwGl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以通过修改节点指针的方法来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    TreeNode* grandChild = child-&gt;right;</span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    <span class="comment">// 当grandChild为null时无影响</span></span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="comment">// 右旋后child作为左子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="左旋">左旋</h4>
<p>左旋作为右旋的镜像版本，对应右节点失衡的情况，同样是下面的两种情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/vSVYkineu6gU9ID.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/11/17/xqeXp4zbtHB3KIg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以写出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    TreeNode* child = node-&gt;right;</span><br><span class="line">    TreeNode* grandChild = child-&gt;left;</span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先左旋后右旋">先左旋后右旋</h4>
<p>对于下面这种情况，我们需要先对<code>child</code>进行左旋，再对<code>node</code>进行右旋：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/LzuXUe4dlR2GSaD.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="先右旋后左旋">先右旋后左旋</h3>
<p>这种情况依旧是上一种情况的镜像对称情况：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/q2JQknaz7PGlIci.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="旋转的选择">旋转的选择</h4>
<p>讲完了四种旋转的操作，现在我们需要分析，在什么情况下需要对我们的树进行哪些操作了，这里的话我推荐看一个视频：<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&amp;vd_source=860ada84437562c4715775e08ac9e2ae">平衡二叉树(AVL树)_哔哩哔哩_bilibili</a></p>
<p>我们的步骤总结如下：</p>
<ul>
<li>先检查失衡节点的子节点<code>child</code>的平衡因子，大于0则需要进行右旋操作，小于0则需要进行左旋操作。</li>
<li>然后检查失衡节点<code>node</code>的平衡因子，大于1则需要进行右旋操作，小于1则需要左旋操作。</li>
<li>最后比较对子节点<code>chlid</code>和失衡节点<code>node</code>的需要进行的操作，如果相同则合并，不同则先操作子节点后操作失衡节点。</li>
</ul>
<p>我们也可以用一张表来进行这个判断：</p>
<figure>
<img src="https://s2.loli.net/2025/11/17/HInBOe2GjgZEXCo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>现在我们可以写出AVL树的平衡函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">rotate</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _balanceFactor = <span class="built_in">balance</span>(node);</span><br><span class="line">    TreeNode* child = node-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(_balanceFactor &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 右旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&lt;<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">// 先左旋</span></span><br><span class="line">            child = <span class="built_in">leftRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_balanceFactor &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 左旋</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">balance</span>(child)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 先右旋</span></span><br><span class="line">            child = <span class="built_in">rightRotate</span>(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 平衡</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树的常用操作">AVL树的常用操作</h3>
<ol type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>AVL树的节点插入操作和二叉搜索树一样，只不过在AVL树插入节点之后，从这个节点到根节点的路径上可能会出现一系列的失衡节点。所以我们需要从这个节点开始，自底向上的执行平衡操作，知道所有的失衡节点都恢复平衡。我们的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _insert(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _insert(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = _insert(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>删除操作</strong></li>
</ol>
<p>删除也是差不多，需要在删除的基础之上，从底部到顶部进行平衡操作，确保所有的失衡点都恢复平衡：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* _remove(TreeNode* node, <span class="type">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = _remove(node-&gt;left,num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right =_remove(node-&gt;right,num);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">nullptr</span>||node-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* child = node-&gt;left==<span class="literal">nullptr</span> ? node-&gt;right : node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* tmp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;left !=<span class="literal">nullptr</span>)</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            <span class="type">int</span> val = tmp-&gt;val;</span><br><span class="line">            node-&gt;right = _remove(node-&gt;right,tmp-&gt;val);</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rotate</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>查找操作</strong></li>
</ol>
<p>和二叉搜索树一样，没有变化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/16/96-%E5%8D%81%E4%B8%80%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">96:十一月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-16 16:54:07" itemprop="dateCreated datePublished" datetime="2025-11-16T16:54:07+08:00">2025-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:52:34" itemprop="dateModified" datetime="2025-11-29T13:52:34+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>841</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>十一月份已经过去了一半。回顾这个月我都做了什么，做到了什么呢？仔细一想是没有的，感觉时间过的好快，转眼间就过去了大半个学期，自己也是没什么收获，定下的很多目标都没有做到。</p>
<p>马上就要期中考试了，我希望能在各科都拿到一个比较好的成绩吧，因为这个学期对我的绩点来说是十分重要的。所以一定要好好加油，尤其是408相关的课程，一定要好好学，不能只是满足于书上的内容，不仅要掌握概念，也要会做题。要做好考研的准备吧，因为推免资格对我而言还是有点困难的，所以一定要好好加油。</p>
<p>这个月接触到了各种语言吧，学的很杂，接触到了Lua和他的游戏开发引擎，我之前说过想做一个游戏，但是思路上仍然是一头雾水，做一个什么样的游戏呢，要做哪些内容呢？我一点idea也没有，所以只能慢慢积累了，还有一些游戏开发相关的技术。所以我选择去了解一下星露谷物语的mod制作，它是用C#进行编写的，语法结构和Java差不多，所以我勉强能看懂一些，但是对于整个项目结构一点也不够了解。</p>
<p>我发现自己总是半途而废，我经常会突然想做什么，但是没办法一直做下去，我感觉要做的事情太多了，我不知道该怎么安排过来，所以也比较晕头转向的。接下来的一个月里，我打算好好夯实一下课内的知识吧，比如操作系统和数据结构，目前学习的过程中也明显感受到了清晰的需求。争取在这个学期把王道的课程也看掉一部分，感觉他讲的还是十分详细的。然后是概率论和离散数学，我也打算好好学一下了，每天坚持做一点题目，因为到现在为止，我对这两门科目都是不太了解。</p>
<p>还有的就是密码学 信息安全基础
程序设计一类的课程了，要想办法把平时分搞高一点，争取一下满绩吧。拉一拉我上上个学期拖得后腿。我发现密码学的很多知识还是比较有用的，因为会涉及到一些简单的数论和密码学体制。我以前总是抗拒听老师的课，但是其实我自己也不知道要做什么，何妨不听一听呢。</p>
<p>然后感觉最近心态好了很多吧，平时不会想那么多了。以后有空的话我也想试试出去旅游，然后玩一点剧情类的游戏。有空的话想拍一点游戏视频。尝试各种各样的事情。我想自己的人生开阔一点，可是我总是半途而废，总是做不到，但是既然有这样的想法就试一试吧。希望未来会越来越好，有很多开心的事在等着我。</p>
<p>我也想坚持锻炼身体，希望能健健康康的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/15/95-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/15/95-%E6%A0%91/" class="post-title-link" itemprop="url">95:树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-15 16:03:54" itemprop="dateCreated datePublished" datetime="2025-11-15T16:03:54+08:00">2025-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:46" itemprop="dateModified" datetime="2025-11-29T13:48:46+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>打算系统性的学一下数据结构与算法，这个就相当于笔记做一下记录了。 #
树</p>
<h2 id="二叉树">二叉树</h2>
<p>二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。我们可以用以下数据结构表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里每个节点都有两个引用，分别为左右子节点，中间的节点为这两个节点的父节点。左右子树的概念也可以类推。<strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。</strong></p>
<h3 id="二叉树常用的术语">二叉树常用的术语</h3>
<p>二叉树中的性质较为复杂，所以我们需要记住许多相关的术语：</p>
<ul>
<li>根节点：位于二叉树顶层的节点，没有父节点。</li>
<li>叶节点：没有子节点的节点，其两个指针均指向 None</li>
<li>边：连接两个节点的线段，即节点引用（指针）</li>
<li>节点所在的层：从顶至底递增，根节点所在层为1。</li>
<li>节点的度：节点的子节点的数量。在二叉树中，度的取值范围是0、1、2。</li>
<li>二叉树的高度：从根节点到最远叶节点所经过的边的数量</li>
<li>节点的深度：从根节点到该节点所经过的边的数量。</li>
<li>节点的高度：从距离该节点最远的叶节点到该节点所经过的边的数量。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/15/79N3evPGgUXx6fw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的基本操作">二叉树的基本操作</h3>
<ol type="1">
<li><strong>初始化二叉树</strong></li>
</ol>
<p>​ 初始化节点，并构造引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode* n1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode* n2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    TreeNode* n3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    TreeNode* n4 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n5 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    n1-&gt;left = n2;</span><br><span class="line">    n1-&gt;right = n3;</span><br><span class="line">    n2-&gt;left = n4;</span><br><span class="line">    n2-&gt;right = n5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入与删除节点</strong></li>
</ol>
<p>​ 二叉树中的插入与删除节点可以通过修改指针实现，效果见下图：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/OBCUobELsv2yVSk.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉树的类型">二叉树的类型</h3>
<h4 id="完美二叉树">完美二叉树</h4>
<p>完美二叉树的所有层的节点都被完全填满。且在完美二叉树中，叶节点的度为0，其余所有节点的度都为2；若树的高度为ℎ，则节点总数为2ℎ+1−1，呈现标准的指数级关系：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/wm5xDqf234QTkIc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>关于完美二叉树，我们需要注意到它的几个性质：</p>
<ul>
<li><strong>第i层的节点数量：</strong> <span
class="math inline">2<sup><em>i</em> − 1</sup></span></li>
<li><strong>高度为h的树的叶节点数量：</strong><span
class="math inline">2<sup><em>h</em></sup></span></li>
<li><strong>高度为h的树的节点总数：</strong> <span
class="math inline">2<sup><em>h</em> + 1</sup> − 1</span></li>
<li><strong>节点总数为n的树的高度：</strong><span
class="math inline"><em>l</em><em>o</em><em>g</em><sub>2</sub>(<em>n</em> + 1) − 1</span></li>
</ul>
<h4 id="完全二叉树">完全二叉树</h4>
<p>完全二叉树只有最底层的节点未被填满，且最底层的节点尽量靠左边。</p>
<p>注：完美二叉树是一种特殊的完全二叉树</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/tMZBKs3xRLaXTcu.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="完满二叉树">完满二叉树</h4>
<p>完满二叉树除了叶子节点之外，其余所有节点都有两个子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/LoBGgVvxW4miF7N.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="平衡二叉树">平衡二叉树</h4>
<p>平衡二叉树中的任意节点的左子树和右子树的高度之差的绝对值不超过1，<code>|左子树高度-右子树高度|&lt;=1</code></p>
<figure>
<img src="https://s2.loli.net/2025/11/15/Ev6t13Msx24lpIo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="二叉树遍历">二叉树遍历</h2>
<p>常见的二叉树遍历有：层序遍历、前序遍历、中序遍历和后序遍历</p>
<h3 id="层序遍历">层序遍历</h3>
<p>层序遍历是从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。这种遍历方式本质上属于广度优先遍历，我们也称之为广度优先搜索：</p>
<figure>
<img src="https://s2.loli.net/2025/11/15/xAbY8fXjeuOtnRQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>其代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;		<span class="comment">// 用于存放遍历序列</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();			<span class="comment">// 将需要处理的节点出列</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前中后序遍历">前中后序遍历</h3>
<p>相应的这种遍历方式实际上是一种深度优先的遍历，我们称之为深度有限的搜索。这里我们有三种不同的遍历顺序，我们可以通过简单的递归来实现，具体实现如下。就不做过多的说明，因为很直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pastOrder</span><span class="params">(TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==nullptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    pastOrder(root-&gt;left);</span><br><span class="line">    pastOrder(root-&gt;right);    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的数组表示">二叉树的数组表示</h2>
<p>我们先前对二叉树的实现是通过链表进行实现的，节点之间则通过指针连接。但是实际上我们也可以通过数组实现二叉树的结构。</p>
<h3 id="表示完美二叉树">表示完美二叉树</h3>
<p>对于一颗完美二叉树，我们可以将所有的节点按照层序遍历的顺序存储一个数组中，则每个节点都对应唯一的数组索引，根据层序遍历的特性，我们也可以推导出父子节点之间的索引关系：</p>
<p><strong>若某节点的索引为𝑖，
则该节点的左子节点索引为2𝑖+1，右子节点索引为2𝑖+2</strong></p>
<p>这里的映射关系就相当于先前的指针，我们只需要知道当前的索引，就能找到其对应的左右节点</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/nKbiCcQN3fhk4al.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="表示任意二叉树">表示任意二叉树</h3>
<p>完美二叉树是一个特例，在实际情况中，我们的二叉树中间层有很多<code>None</code>，如果层序遍历不包含这些<code>None</code>，那么我们就无法根据一个数组来还原二叉树的形态：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/MJ9KjoOWAIVvtG1.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>所以我们尝试在层序遍历的序列中显式的写出所有的<code>None</code>:</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/ZXafdEGv3RcoBOl.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>就可以清晰的表示一个二叉树的结构。当然需要注意的是，完全二叉树十分适合用数组来表示，我们知道其<code>None</code>只会出现在最底层的右边，一定出现在层序遍历序列的末尾。这意味着当我们对完全二叉树进行存储时，我们可以忽略所有的<code>None</code></p>
<h3 id="二叉树的数组实现">二叉树的数组实现</h3>
<p>现在我们尝试用数组实现二叉树的结构，我们需要支持以下操作：</p>
<ul>
<li>给定某节点，获取其值、左右子节点、父节点</li>
<li>获取前序、中序、后序遍历、层序遍历序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayBinaryTree</span>(vector&lt;<span class="type">int</span>&gt; arr)&#123;</span><br><span class="line">        tree = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> tree[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">val</span>(i)!=<span class="number">-1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">preOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pastOrder</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(index)==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">left</span>(index));</span><br><span class="line">        <span class="built_in">pastOrder</span>(<span class="built_in">right</span>(index));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">val</span>(index) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>如下图所示，二叉搜索树需要满足以下条件：</p>
<ul>
<li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt;
右子树所有节点的值</li>
<li>任意节点的左右子树也时二叉搜索树，满足上一个条件</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/EUbMoqiVmQJug8Z.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="二叉搜索树的操作">二叉搜索树的操作</h3>
<p>我们将二叉搜索树封装为一个类<code>BinarySerchTree</code>，并声明一个成员变量<code>root</code>，指向树的节点。</p>
<ol type="1">
<li><strong>查找节点</strong></li>
</ol>
<p>给定一个目标节点值<code>num</code>，我们可以很快的根据二叉搜索树的性质来查找，我们可以声明一个节点<code>cur</code>，从二叉树的根节点<code>root</code>出发，循环比较值，知道找到对应的节点。</p>
<p>二叉搜索树的查找操作实际上和二分查找差不多，循环次数最多为树的高度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val &gt; num)</span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> cur;</span><br><span class="line">       &#125;  </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>插入节点</strong></li>
</ol>
<p>给定一个等待插入的元素<code>num</code>，为了保持二叉树的性质，我们进行以下步骤：</p>
<ul>
<li>查找插入位置：和查找操作相似，从根节点出出发，直到越过叶节点时退出循环。</li>
<li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>none</code>的位置。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/8GEtkeaMZ6B1SbU.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在编写的过程中我们需要注意两点：</p>
<ul>
<li>如果插入的数值已经存在，那么则不插入。</li>
<li>使用<code>pre</code>节点保存<code>cur</code>的上一个位置，以为我们指定插入位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">           TreeNode* cur = root;</span><br><span class="line">           TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               pre = cur;</span><br><span class="line">               <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">                   cur = cur-&gt;right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cur = cur-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">           <span class="keyword">if</span>(num &gt; pre-&gt;val)</span><br><span class="line">               pre-&gt;right = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pre-&gt;left = node;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><strong>删除节点</strong></li>
</ol>
<p>在二叉树中查找到目标节点，并将其删除，和插入节点类似，我们需要保证在删除操作完成之后仍然保持着二叉树的性质。所以我们需要根据目标子节点的数量，分为<code>0\1\2</code>三种情况进行相应的处理。</p>
<p>对于度为0的情况，我们只需要简单的删除：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/cNCLRi7B2nJhqmM.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当度为1时，我们需要将待删除的节点替换成其子节点：</p>
<figure>
<img src="https://s2.loli.net/2025/11/16/WlRGE2JQf8zK47s.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于度为2的节点，我们则需要谨慎处理。首先我们需要找到一个能替换它的节点（左子树的最大值或是右子树的最小值），并将其删除，覆盖待删除的节点：</p>
<ul>
<li>找到待删除节点在中序遍历序列中的下一个节点，记为<code>tmp</code></li>
<li>用<code>tmp</code>的值覆盖待删除节点的值，并在书中递归删除节点<code>tmp</code></li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/11/16/kltzjwHXGmpd2EI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 度为0/1</span></span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span> || cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        TreeNode* child = cur-&gt;left==<span class="literal">nullptr</span>?cur-&gt;right:cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(cur!=root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;left==cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode* tmp = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 寻找后继节点</span></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        <span class="comment">// 递归删除后继节点</span></span><br><span class="line">        <span class="built_in">remove</span>(tmp-&gt;val);</span><br><span class="line">        cur-&gt;val = tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><strong>中序遍历有序</strong></li>
</ol>
<p>由于搜索二叉树的性质，当我们对其进行中序遍历时，总是会优先遍历下一个最小节点，所以我们知道：<strong>搜索二叉树的中序遍历时升序的</strong>。所以我们可以直接得到搜索二叉树的有序数据。</p>
<h2 id="avl树">AVL树</h2>
<p>之后单独开一篇讲 感觉比较复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/04/94-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-4/" class="post-title-link" itemprop="url">94:c4编译器回顾(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-04 15:23:50" itemprop="dateCreated datePublished" datetime="2025-11-04T15:23:50+08:00">2025-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-09 16:16:32" itemprop="dateModified" datetime="2025-11-09T16:16:32+08:00">2025-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一章中，我们完成了对函数体的解析，现在我们需要进一步解析函数体中的语句，还有程序中的表达式。我们需要将程序中的语句解析成我们的虚拟机能直接执行的语句，所以这一章中会有一点难度：</p>
<h2 id="语句">语句</h2>
<p>我们的编译器中识别以下六种语句：</p>
<ul>
<li><code>if(...) &lt;statement&gt;; [else &lt;statement&gt;;]</code></li>
<li><code>while (...) &lt;statement&gt;;</code></li>
<li><code>&#123;&lt;statement&gt;;&#125;</code></li>
<li><code>return xxx;</code></li>
<li><code>&lt;;(empty statement)&gt;</code></li>
<li><code>expression(这个我们稍后单独讨论)</code></li>
</ul>
<p>现在我们要将这些语句转换成对应的汇编代码：</p>
<h3 id="if语句">IF语句</h3>
<p>IF语句的作用是跳转，根据条件表达式决定跳转的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &lt;statement&gt; [<span class="keyword">else</span> &lt;statement&gt;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&lt;cond&gt;)                   &lt;cond&gt;</span><br><span class="line">JZ a</span><br><span class="line">&lt;true_statement&gt;   ===&gt;     &lt;true_statement&gt;</span><br><span class="line"><span class="keyword">else</span>:                         JMP b</span><br><span class="line">a:                           a:</span><br><span class="line">&lt;false_statement&gt;           &lt;false_statement&gt;</span><br><span class="line">b:                           b:</span><br></pre></td></tr></table></figure>
<p>对应的流程就是：</p>
<ul>
<li>先执行条件表达式<code>&lt;cond&gt;</code></li>
<li>如果条件失败，则跳转到<code>a</code>的位置，执行<code>else</code>语句</li>
<li>如果条件成功，则在执行<code>&lt;true_statement&gt;</code>之后，无条件跳转到<code>b</code>，结束判断。</li>
</ul>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==If)&#123;</span><br><span class="line">       match(If);</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       <span class="keyword">if</span>(token==Else)&#123;</span><br><span class="line">           match(Else);</span><br><span class="line">           *b = (<span class="type">int</span>)(text + <span class="number">2</span>);</span><br><span class="line">           *++text = JMP;</span><br><span class="line">           b = ++text;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从栈的视角进行解释，text始终是指向下一条要执行的指令的。我们希望<code>JZ</code>后面跟着的是<code>else</code>的代码块的入口或是<code>if</code>判断之后的地址。</p>
<p>这里我们使用了延迟绑定地址的方式，我们来看看以下两种情况：</p>
<ul>
<li>只有<code>if</code>，我们将在执行完<code>if_statement</code>之后，将<code>JZ</code>之后的跳转地址设置成下一条指令的地址<code>text</code></li>
<li>有<code>else</code>，我们希望能够跳转到<code>else</code>的起始地址，我们需要在当前<code>text</code>指向的地址基础上<code>+2</code>，因为我们需要跳过<code>JMP</code>和<code>出口地址</code>所占用的指令空间。同时我们需要将<code>if_statement</code>之后的地址设置成判断的出口，即<code>else_statement</code>的后一条指令</li>
</ul>
<h3 id="while语句">While语句</h3>
<p>While语句的汇编代码更加简单，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:                     a:</span><br><span class="line"><span class="keyword">while</span> (&lt;cond&gt;)        &lt;cond&gt;</span><br><span class="line">JZ b</span><br><span class="line">&lt;statement&gt;          &lt;statement&gt;</span><br><span class="line">JMP a</span><br><span class="line">b:                     b:</span><br></pre></td></tr></table></figure>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==While)&#123;</span><br><span class="line">       match(While);</span><br><span class="line">       a = text;</span><br><span class="line">       match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">       *++text = JZ;</span><br><span class="line">       b = ++text;</span><br><span class="line">       statement();</span><br><span class="line">       *++text = JMP;</span><br><span class="line">       *++text = (<span class="type">int</span>)a;</span><br><span class="line">       *b = (<span class="type">int</span>)(text);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在跳转之前用<code>a</code>保存<code>expression</code>开始的指令，用于重新计算<code>cond</code>。然后延迟绑定地址<code>b</code>，作为<code>while</code>逻辑的出口</p>
<h3 id="return-语句">Return 语句</h3>
<p>遇到Return语句则代表函数将要退出了，这一部分很简单，实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Return)&#123;</span><br><span class="line">        match(Return);</span><br><span class="line">        <span class="keyword">if</span>(token!=<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            expression();</span><br><span class="line">        &#125;</span><br><span class="line">        *++text = LEV;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他语句">其他语句</h3>
<p>其他语句并不生成汇编代码，所以简单的匹配消耗即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">       <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">           statement();</span><br><span class="line">       &#125;</span><br><span class="line">       match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       expression();</span><br><span class="line">       match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>
<h2 id="expresion">expresion</h2>
<p>我们已经完成了对语句的解释，现在我们需要实现对表达式的解释，在此之前我们要明确什么是表达式？怎么解析我们的表达式，并计算他们。</p>
<h3 id="怎么计算表达式">怎么计算表达式</h3>
<p>对于表达式中的运算符，每一个符号都有自己的优先级，在进行运算的时候，我们希望运算符优先级高的子式先被计算。例如在<code>2 + 3 * 4</code>中，我们希望<code>*</code>先被计算，然后再是<code>+</code>。对于我们生成的汇编代码而言，我们应该优先为优先级高的运算符生成目标代码，所以如何确定一个表达式的优先运算顺序十分重要。</p>
<p>这里我们使用递归下降的方法实现对表达式运算符的解析，我们在一开始定义标识符时，实际上就对运算符的优先级进行了排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">    Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">    Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先明确，一元运算符的优先级始终是高于二元运算符的，所以这里我们需要，首先完成对一元运算符的解析，这里先罗列几个较为特殊的：</p>
<ul>
<li><code>Num</code> 当我们遇到一个数字时 要返回它的数值</li>
<li><code>"..."</code> 当我们遇到一个字符串时 要返回它的指针</li>
<li><code>PTR</code> 当我们遇到一个指针类型时
我们要正确的解析它的解引用</li>
<li><code>Func</code>
当我们遇到一个函数调用时，我们要正确的执行它，并返回返回值</li>
<li><code>Id</code> 当我们遇到一个变量时，需要返回它的存储的值</li>
<li>…</li>
</ul>
<p>然后，对一元预算符的判断结束后，我们需要对二元运算符的解析，但是对于二元运算符，我们需要考虑运算符号的优先级。我们给每一个运算符都设置一个当前的<code>level</code>，每次只对高于/等于当前<code>level</code>的运算符进行解析，每次解析完一个运算符之后，都将当前的优先级提高。这样我们就实现了对运算符的递归下降分析，我们的框架代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expression</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">    <span class="comment">// 解析一元运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 解析顺序按一元运算符优先级进行解析</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析二元运算符</span></span><br><span class="line">    <span class="keyword">while</span>(token&gt;=level)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们给出具体的实现：</p>
<h3 id="常量">常量</h3>
<p><code>Num</code>用<code>IMM</code>指令将其加载到ax中即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token==Num)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是字符串常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>)&#123;</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = token_val;</span><br><span class="line">        expr_type = PTR;</span><br><span class="line">        <span class="comment">// while(token==&#x27;&quot;&#x27;) match(&#x27;&quot;&#x27;);</span></span><br><span class="line">        <span class="comment">// 对data段进行地址对齐</span></span><br><span class="line">        data = (<span class="type">char</span>*)(((<span class="type">int</span>)(data) + <span class="keyword">sizeof</span>(<span class="type">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意，如果你想支持<code>"Hello""World" = "HelloWorld"</code>的语法，那么你要设置<code>while(token=='"') match('"');</code>，这里我不想支持就不开了。</p>
<p>然后是<code>data = (char*)(((int)(data) + sizeof(int)) &amp; (-sizeof(int)));</code>，这一部分的作用是将数据段进行对齐，我们希望每次的<code>data</code>指针都是四字节对齐的，这样可以方便我们进行索引，或是避免了字符串访问越界的可能。</p>
<h3 id="sizeof">sizeof</h3>
<p>这个关键字我们也将其作为一元运算符进行处理，我们需要根据后面参数的类型，并返回它的大小。这里我们只支持<code>Int Char Ptr</code>三种类型，其中<code>Ptr</code>类型的大小同<code>int</code></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Sizeof)&#123;</span><br><span class="line">        match(Sizeof);</span><br><span class="line">        match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">            match(Int);</span><br><span class="line">            expr_type = INT;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            expr_type = CHAR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            expr_type = expr_type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        *++text = IMM;</span><br><span class="line">        *++text = (expr_type==CHAR) ? <span class="keyword">sizeof</span>(<span class="type">char</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        expr_type = INT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量与函数调用">变量与函数调用</h3>
<p>由于我们将函数和变量的值的词法分析都是以<code>Id</code>开头，所以我们对他们的目标代码生成也放在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==Id)&#123;</span><br><span class="line">           match(Id);</span><br><span class="line">           id = current_id;</span><br><span class="line">           <span class="comment">// 函数调用</span></span><br><span class="line">           <span class="keyword">if</span>(token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">               tmp = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                   expression(Assign);</span><br><span class="line">                   *++text = PUSH;</span><br><span class="line">                   tmp++;</span><br><span class="line">                   <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class==Sys)&#123;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class==Fun)&#123;</span><br><span class="line">                   *++text = CALL;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数调用\n&quot;</span>,line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 清除栈上的变量</span></span><br><span class="line">               <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   *++text = ADJ;</span><br><span class="line">                   *++text = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Num)&#123;</span><br><span class="line">               *++text = IMM;</span><br><span class="line">               *++text = id-&gt;value;</span><br><span class="line">               expr_type = INT;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(id-&gt;class = Glo)&#123;</span><br><span class="line">                   *++text = IMM;</span><br><span class="line">                   *++text = id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id-&gt;class == Loc)&#123;</span><br><span class="line">                   *++text = LEA;</span><br><span class="line">                   *++text = -id-&gt;value;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d: 未知变量类型\n&quot;</span>, line);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               expr_type = id-&gt;type;</span><br><span class="line">               *++text = (expr_type==CHAR) ? LC : LI;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针取值">指针取值</h3>
<p>说实话有点写不下去了，最近有点忙，心情也不好，写这个的过程中断断续续的，所以先到此为止吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/30/93-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-3/" class="post-title-link" itemprop="url">93:c4编译器回顾(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-30 16:26:49" itemprop="dateCreated datePublished" datetime="2025-10-30T16:26:49+08:00">2025-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-06 10:52:43" itemprop="dateModified" datetime="2025-11-06T10:52:43+08:00">2025-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们完成了对词法分析的获取函数<code>next()</code>，现在我们尝试根据token分析，和我们的语法规则，进行简单的语法分析。</p>
<h2 id="解析变量">解析变量</h2>
<p>我们的解释器的语法结构，可以用下面的EBNF的表示法直观的体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">program ::= &#123;global_declaration&#125;+</span><br><span class="line"></span><br><span class="line">global_declaration ::= enum_decl | variable_decl | function_decl</span><br><span class="line"></span><br><span class="line">enum_decl ::= <span class="string">&#x27;enum&#x27;</span> [id] <span class="string">&#x27;&#123;&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>] &#123;<span class="string">&#x27;,&#x27;</span> id [<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;num&#x27;</span>&#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">variable_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123; <span class="string">&#x27;,&#x27;</span> &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#125; <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">function_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id <span class="string">&#x27;(&#x27;</span> parameter_decl <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> body_decl <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">parameter_decl ::= type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id &#123;<span class="string">&#x27;,&#x27;</span> type &#123;<span class="string">&#x27;*&#x27;</span>&#125; id&#125;</span><br><span class="line"></span><br><span class="line">body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;</span><br><span class="line"></span><br><span class="line">statement ::= non_empty_statement | empty_statement</span><br><span class="line"></span><br><span class="line">non_empty_statement ::= if_statement | while_statement | <span class="string">&#x27;&#123;&#x27;</span> statement <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">| <span class="string">&#x27;return&#x27;</span> expression | expression <span class="string">&#x27;;&#x27;</span></span><br><span class="line"></span><br><span class="line">if_statement ::= <span class="string">&#x27;if&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> statement [<span class="string">&#x27;else&#x27;</span> non_empty_statement]</span><br><span class="line"></span><br><span class="line">while_statement ::= <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> expression <span class="string">&#x27;)&#x27;</span> non_empty_statement</span><br></pre></td></tr></table></figure>
<p>对于我们的程序而言，一切都是从对<code>global_delartion</code>开始：</p>
<ul>
<li>变量定义</li>
<li>类型定义（目前只支持enum）</li>
<li>函数定义</li>
</ul>
<p>我们的<code>program()</code>作为语法解析函数，框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">    <span class="keyword">while</span>(token &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        global_declaration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="global_declaration">global_declaration</h3>
<p>即全局定义的语句，我们通过递归下降的方法，来判断当前的定义类型，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">global_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    basetype = INT;</span><br><span class="line">    <span class="keyword">if</span>(token == Enum)&#123;</span><br><span class="line">        match(Enum);</span><br><span class="line">        <span class="keyword">if</span>(token != <span class="string">&#x27;&#123;&#x27;</span>) match(Id);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            enum_declaration();</span><br><span class="line">            match(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Int)&#123;</span><br><span class="line">        match(Int);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">        match(Char);</span><br><span class="line">        basetype = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        type = basetype;</span><br><span class="line">        <span class="comment">// 指针处理</span></span><br><span class="line">        <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: bad global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: duplicate global declaration\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Fun;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(text);</span><br><span class="line">            function_declaration();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current_id-&gt;class = Glo;</span><br><span class="line">            current_id-&gt;value = (<span class="type">int</span>)(data);</span><br><span class="line">            data += <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用的依旧是<code>lookahead</code>的思想，我们无法根据一个<code>token</code>信息就实现对这一部分的语法功能解析，所以我们需要结合之后的信息，来对定义进行判断。</p>
<p>我们的解释器同时也支持指针类型，我们这里使用<code>type = type+PTR</code>的方式，来表示其包含指针的信息。</p>
<h3 id="enum_declaration">enum_declaration</h3>
<p>主要用来解析用<code>,</code>分隔的变量，这里我们需要注意编译器对枚举变量的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enum_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的枚举变量声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(token!=Num)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 枚举变量赋值错误\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i = token_val;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Num;</span><br><span class="line">        current_id-&gt;type = INT;</span><br><span class="line">        current_id-&gt;value = i++;</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="辅助函数match">辅助函数match</h3>
<p>这里我们使用<code>match</code>来匹配并获取下一个<code>token</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> tk)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(token == tk)&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: 语法错误, 缺少 %c\n&quot;</span>, line, tk);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数定义的解析">函数定义的解析</h3>
<p>我们在先前的函数Id判断中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">current_id[Class] = Fun;</span><br><span class="line">current_id[Value] = (<span class="type">int</span>)(text); </span><br><span class="line">function_declaration();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在确定是函数类型之后，我们开始对函数结构的解析，我们对函数体的解析结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_declaration</span><span class="params">()</span>&#123;</span><br><span class="line">    match(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    function_parameters();</span><br><span class="line">    match(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    match(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    function_body();</span><br><span class="line">    <span class="comment">// match(&#x27;&#125;&#x27;);</span></span><br><span class="line">    <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_id-&gt;class==Loc)&#123;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span>=</span>current_id-&gt;Bclass;</span><br><span class="line">            current_id-&gt;type=current_id-&gt;Btype;</span><br><span class="line">            current_id-&gt;value=current_id-&gt;Bvalue;</span><br><span class="line">        &#125;</span><br><span class="line">        current_id++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意两个点：</p>
<ul>
<li>一是在对函数体的分析结束之后，不需要<code>match("&#125;")</code>，因为函数体解析的函数会匹配他</li>
<li>二是在函数解析完毕之后，我们需要将用到的token信息还原。这是因为在函数体解析的过程中，同名的局部变量会把原来定义的全局变量信息覆盖。</li>
</ul>
<p>进一步的实现，则分别是对参数和函数体的内容的解析，首先是对参数的解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_parameters</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> params = <span class="number">0</span>;</span><br><span class="line">    type = basetype = INT;</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(token==Int) match(Int);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(token==Char)&#123;</span><br><span class="line">            match(Char);</span><br><span class="line">            type = CHAR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">            match(Mul);</span><br><span class="line">            type = type + PTR;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(token!=Id)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的函数参数声明\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(Id);</span><br><span class="line"></span><br><span class="line">        current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">        current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">        current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">        current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">        current_id-&gt;type = type;</span><br><span class="line">        current_id-&gt;value = ++params;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要注意两点，首先是<code>index_of_bp</code>，这个变量用于确定参数在栈上的偏移值，因为从<code>bp</code>到函数传参之间隔着一个返回地址，所以在计算时需要将<code>index_of_bp</code>加一。</p>
<p>其次是，当我们遇到一个Id类型的token，我们将其所有的信息都备份一遍，并且将值赋值为<code>参数的索引</code></p>
<p>然后是对函数体的解析，我们可以进一步分成局部变量声明和语句部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_body</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos_local = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(token==Int||token==Char)&#123;</span><br><span class="line">        basetype = (token==Int ? INT : CHAR);</span><br><span class="line">        match(token);</span><br><span class="line">        <span class="keyword">while</span>(token!= <span class="string">&#x27;;&#x27;</span>)&#123;</span><br><span class="line">            type = basetype;</span><br><span class="line">            <span class="keyword">while</span>(token==Mul)&#123;</span><br><span class="line">                match(Mul);</span><br><span class="line">                type = type + PTR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (token!=Id)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 错误的局部变量声明\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_id-&gt;class != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d: 重复定义了局部变量-^-\n&quot;</span>, line);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            match(Id);</span><br><span class="line">            current_id-&gt;Bclass = current_id-&gt;class;</span><br><span class="line">            current_id-&gt;Btype = current_id-&gt;type;</span><br><span class="line">            current_id-&gt;Bvalue = current_id-&gt;value;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Loc;</span><br><span class="line">            current_id-&gt;type = type;</span><br><span class="line">            current_id-&gt;value = ++pos_local;</span><br><span class="line">            <span class="keyword">if</span>(token==<span class="string">&#x27;,&#x27;</span>) match(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        match(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = ENT;  <span class="comment">// 函数入口指令</span></span><br><span class="line">    *++text = pos_local; <span class="comment">// 局部变量大小</span></span><br><span class="line">    <span class="comment">// 语句处理</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        statement();</span><br><span class="line">    &#125;</span><br><span class="line">    *++text = LEV;  <span class="comment">// 函数返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分需要注意的就是<code>*++text</code>的含义，相当于我们在栈上为局部变量预留了空间，后面的<code>LEV</code>则是用来返回函数调用。</p>
<p>至此我们对全局变量和函数定义的解析完成了，之后我们将着重实现对语句的实现，并为他们生成可用的字节码指令。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/" class="post-title-link" itemprop="url">92:c4编译器回顾(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-29 12:59:29" itemprop="dateCreated datePublished" datetime="2025-10-29T12:59:29+08:00">2025-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-30 16:27:12" itemprop="dateModified" datetime="2025-10-30T16:27:12+08:00">2025-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一节中完成了对虚拟机的实现和初始化，还有指令集的定义，接下来就是对源文件的词法分析部分</p>
<h2 id="词法分析">词法分析</h2>
<h3 id="什么是词法分析">什么是词法分析</h3>
<p>源文件的内容对于我们的解释器而言，本质上就是一系列ASCII字符串，是毫无意义的，我们需要通过语法分析将其解析为简单的指令，然后再执行。可是这样一来，这就使得语法分析的部分十分庞大。所以编译器一般会对整个过程进行前后端的分离。前端负责对源文件进行预处理，将其解析为一系列标识符流，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span> * (<span class="number">4</span> - <span class="number">5</span>)</span><br><span class="line">=&gt;</span><br><span class="line">(Number, <span class="number">2</span>) Add (Number, <span class="number">3</span>) Multiply Left-Bracket (Number, <span class="number">4</span>) Subtract (Number, <span class="number">5</span>) Right-Bracket</span><br></pre></td></tr></table></figure>
<p>然后后端就可以根据直接对标识符流进行处理，就避免了中间处理过程臃肿的情况。</p>
<h3 id="词法分析和编译器">词法分析和编译器</h3>
<p>词法分析从某种意义上来讲，本质上也是一种编译器，它以源代码作为输入流，然后输出标识符流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+</span><br><span class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</span><br><span class="line">                   +-------+                      +--------+</span><br></pre></td></tr></table></figure>
<p>直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h3 id="词法分析器的实现">词法分析器的实现</h3>
<p>这里我们就不用现有的词法分析器了，我们手动的实现这一部分。当然我们需要注意，词法分析并不是一次性的将所有的源码转换成标记流。因为在代码中的大多数操作符，和字符关键字都是和代码有上下文关系的。</p>
<p>所以实际的做法是，提供一个<code>next()</code>函数，每次调用这个函数就返回下一个标识。</p>
<h4 id="支持的标识">支持的标识</h4>
<p>我们的编辑器支持以下标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">	Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">	Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里之所以让标识符从128开始，是为了避免和前面设置的指令枚举变量发生冲突。</p>
<p>上面的运算符的枚举变量是有顺序的，实际上他们是按优先级进行排列的，之后的语法分析过程中会用到。现在我们就要进行token的匹配了。例如将<code>==</code>匹配成<code>Eq</code>，将<code>=</code>匹配成<code>Assign</code>。在下面的实现中，我们会分析这些匹配是怎么实现的。</p>
<p>当然这里还需要注意一些字符，他们自己就构成了标记，如右方括号<code>]</code>和波浪号<code>~</code>等，我们不需要对他们做额外的处理，因为他们不属于多字符的共同标记，也不参与运算（没有优先级关系）</p>
<h4 id="框架">框架</h4>
<p>我们的<code>next()</code>的主体框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *last_pos;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        ++src;</span><br><span class="line">	<span class="comment">// 具体的匹配逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用whlie来跳过我们分析过程中的遇到的空白字符和未知的符号。下面我们先把几个比较特殊的标识符进行一下处理：</p>
<h4 id="换行符号">换行符号</h4>
<p>换行符也和空格类似，只不过遇到换行符号，我们需要将当前的行号+1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token == <span class="string">&#x27;\n&#x27;</span>) &#123;++line;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<p>我们的解释器不支持宏定义所以直接跳过<code>#</code>后面部分的内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="number">0</span> || *src == <span class="string">&#x27; &#x27;</span>) &#123;++src;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标识符和符号表">标识符和符号表</h4>
<p>标识符可以理解为变量名。对于语法分析而言，我们并不关心一个变量叫什么，而是在意这个变量的标识符，我们需要从它唯一的标识符中获取这个变量的信息。</p>
<p>基于这个理由，我们让词法分析器将扫描到的标识符保存在一张表中，每当我们遇到标识符，就去表中查找，如果标识符存在就返回它的唯一标识符，不存在则创建有一个新的标识符存放在表中。</p>
<p>我们用结构体来存放标识符的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识符信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">id</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> token;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> Bclass;</span><br><span class="line">    <span class="type">int</span> Btype;</span><br><span class="line">    <span class="type">int</span> Bvalue;</span><br><span class="line">&#125; ID;</span><br></pre></td></tr></table></figure>
<p>这里解释一下各个字段的具体含义：</p>
<ul>
<li><strong>token：</strong>该标识符返回的标记，这里主要是存储变量的信息，所以标记类型注意要是<code>Id</code></li>
<li><strong>hash：</strong> 这个标识符的hash值，用于快速比较标识</li>
<li><strong>name：</strong>存放标识符的变量名</li>
<li><strong>class：</strong>
存放标识符的类型，例如全局、局部、数字等</li>
<li><strong>type：</strong>
标识符的类型，如果是个变量，可能是指针、int或者char</li>
<li><strong>value：</strong>
存放这个标识符的值，如果标识符是函数的，则存放函数地址</li>
<li><strong>BXXX：</strong>
C语言的标识符中可能是全局的也是局部的，当我们局部标识符和全局标识符冲突时，这个字段用于保存全局变量的信息。</li>
</ul>
<p>上面这些信息用于我们在语法分析部分进行解析，更加方便快捷：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> token_val;          <span class="comment">// 当前标识符的值</span></span><br><span class="line">ID *Symbols;            <span class="comment">// 符号表</span></span><br><span class="line">ID *current_id;         <span class="comment">// 当前标识符</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;z&#x27;</span> || token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;Z&#x27;</span> || (*src &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *src &lt;= <span class="string">&#x27;9&#x27;</span>) || token==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 标识符处理</span></span><br><span class="line">            last_pos = src - <span class="number">1</span>; <span class="comment">// 标识符起始位置</span></span><br><span class="line">            <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;z&#x27;</span> || *src&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;Z&#x27;</span> || *src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span> || *src==<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">                hash = hash * <span class="number">147</span> + *(src++);</span><br><span class="line">            <span class="comment">// 查找符号表</span></span><br><span class="line">            current_id = Symbols;</span><br><span class="line">            <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">                <span class="keyword">if</span>(current_id-&gt;hash == hash &amp;&amp; !<span class="built_in">memcmp</span>(current_id-&gt;name, last_pos, src - last_pos))&#123;</span><br><span class="line">                    token = current_id-&gt;token;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current_id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新标识符</span></span><br><span class="line">            token = current_id-&gt;token = Id;</span><br><span class="line">            current_id-&gt;hash = hash;</span><br><span class="line">            current_id-&gt;name = (<span class="type">int</span>)last_pos;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们通过以上形式实现对标识符的识别。</p>
<h4 id="数字">数字</h4>
<p>当遇到数字时我们也需要，进行对应的解析，这一部分的难点在于不同进制的识别。然后将数字转换为对应的数据并求值，我们把它的值保存在<code>token_value</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">           <span class="comment">// 数字处理</span></span><br><span class="line">           token_val = token - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(token_val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                   token_val = token_val *<span class="number">10</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(*src == <span class="string">&#x27;x&#x27;</span> || *src == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                   token = *(++src);</span><br><span class="line">                   <span class="keyword">while</span>((token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>) || (token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;f&#x27;</span>) || (token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;F&#x27;</span>))&#123;</span><br><span class="line">                       token_val = token_val *<span class="number">16</span> + (token&amp;<span class="number">15</span>) + (token&gt;=<span class="string">&#x27;A&#x27;</span> ?<span class="number">9</span>:<span class="number">0</span>);</span><br><span class="line">                       token = *(++src);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">                       token_val = token_val *<span class="number">8</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           token = Num;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>在实际的分析过程中，当我们遇到字符串，我们需要将它的内容保存在<code>data</code>段中，然后返回它<code>data</code>段中的地址，之后我们对字符串的使用都指向这个地址。另一个特殊的地方在于，我们需要支持部分转义字符的实现，这里我们只对<code>\n</code>做一个支持，也支持<code>\x</code>表示字符<code>x</code>的语法。</p>
<p>在分析时，我们将单个字符<code>'a'</code>按<code>Num</code>的形式保存并返回，我们将<code>"a string"</code>按字符串的形式进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>||token==<span class="string">&#x27;\&#x27;&#x27;</span>)&#123;</span><br><span class="line">          last_pos = data;</span><br><span class="line">          <span class="keyword">while</span>(*src!=token &amp;&amp; *src!=<span class="number">0</span>)&#123;</span><br><span class="line">              token_val = *src++;</span><br><span class="line">              <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">                  token_val = *src++;</span><br><span class="line">                  <span class="keyword">if</span>(token_val==<span class="string">&#x27;n&#x27;</span>) token_val = <span class="number">10</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;t&#x27;</span>) token_val = <span class="number">9</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;r&#x27;</span>) token_val = <span class="number">13</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>) token_val = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                  *data++ = token_val;</span><br><span class="line">          &#125;</span><br><span class="line">          src++;  <span class="comment">// 跳过结束符</span></span><br><span class="line">          <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">              *data++ = <span class="number">0</span>;</span><br><span class="line">              token_val = (<span class="type">int</span>)last_pos;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;token = Num;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分可能比较难理解，首先就是判断这个是单字符还是多字符的字符串。然后分别做不同的处理即可。</p>
<h4 id="注释">注释</h4>
<p>在我们的C中，只支持<code>//</code>类型的注释，不支持多行<code>/**/</code>的注释方法。处理方式和前面对<code>#</code>的方式差不多，需要注意的是，这里要前瞻的观察下一位是什么<code>/</code>可能是除法，也可能是<code>//</code>注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">              <span class="keyword">while</span>(*src!=<span class="number">0</span> &amp;&amp; *src!=<span class="string">&#x27;\n&#x27;</span>) ++src;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Div; <span class="keyword">return</span>;&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们利用src比token快一个字符的特点，实现了对多个字符的观察，我们称这个概念为前瞻（lookahead）</p>
<h4 id="其他">其他</h4>
<p>其他的大多数是一些简单的操作符，我们简单的附上代码即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Eq;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Assign;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;+&#x27;</span>)&#123;++src; token = Inc;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Add;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;-&#x27;</span>)&#123;++src; token = Dec;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Sub;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ne;&#125; </span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Le;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&lt;&#x27;</span>)&#123;++src; token = Shl;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Lt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ge;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&gt;&#x27;</span>)&#123;++src; token = Shr;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Gt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;|&#x27;</span>)&#123;++src; token = Lor;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Or;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;&amp;&#x27;</span>)&#123;++src; token = Lan;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = And;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">          token = Xor;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">          token = Mod;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">          token = Mul;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">          token = Brak;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">          token = Cond;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;~&#x27;</span> || token==<span class="string">&#x27;;&#x27;</span> || token==<span class="string">&#x27;&#123;&#x27;</span> || token==<span class="string">&#x27;&#125;&#x27;</span> || token==<span class="string">&#x27;(&#x27;</span> || token==<span class="string">&#x27;)&#x27;</span> || token==<span class="string">&#x27;]&#x27;</span> || token==<span class="string">&#x27;,&#x27;</span> || token==<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>基本的思想就是利用前瞻确定标记。</p>
<h4 id="关键字和内置函数">关键字和内置函数</h4>
<p>完成了上述的词法分析之后，我们需要在正式开始词法分析之前，预处理我们的关键字和内置的函数。我们将它们加入符号表，并提前为他们赋予必要的信息。</p>
<p>我们在<code>main</code>函数中对其进行初始化:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理关键字</span></span><br><span class="line">    &#123;</span><br><span class="line">        Symbols = <span class="built_in">malloc</span>(poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(Symbols, <span class="number">0</span>, poolsize);</span><br><span class="line">        src = <span class="string">&quot;char else enum if int return sizeof while &quot;</span></span><br><span class="line">              <span class="string">&quot;open read close printf malloc memset memcmp exit void main&quot;</span>;</span><br><span class="line">        i=Char;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=While)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;token = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i = OPEN;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=EXIT)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;value = i++;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Sys;</span><br><span class="line">            current_id-&gt;type = INT;</span><br><span class="line">        &#125;</span><br><span class="line">        next(); current_id-&gt;token = Char;</span><br><span class="line">        next(); idmain = current_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们就完成了对源代码的词法分析，程序会通过词法分析将我们的源代码转换成标记流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/" class="post-title-link" itemprop="url">91:c4编译器回顾(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-28 16:37:10" itemprop="dateCreated datePublished" datetime="2025-10-28T16:37:10+08:00">2025-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-29 10:39:50" itemprop="dateModified" datetime="2025-10-29T10:39:50+08:00">2025-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们将尝试构建一个C语言的解释器，这个项目也是我C语言的大作业。现在回顾看来，当时对整个项目都是知其然不知其所以然，从现在的眼光来看，当时很多做法都是很稚嫩的。尤其是对于这个项目结构的理解也远远不足，所以打算重构一遍。</p>
<h2 id="构建流程">构建流程</h2>
<p>首先是整个编译器的构建流程，一般来讲，编译器的编写有三个步骤：</p>
<ol type="1">
<li>词法分析器，用于将文本文件转换为内部的表示结构</li>
<li>语法分析器，在词法分析得到的标记的基础之上，构建一棵语法树</li>
<li>目标代码的生成，将语法树转换成目标代码</li>
</ol>
<p>但是由于这里我们编写的是一个解释器，所以我们自定义自己的虚拟机框架和指令。我们通过语法分析词法分析之后得到的语法树，来生成使用自定义虚拟机框架的指令的目标代码。</p>
<h2 id="编译器的框架">编译器的框架</h2>
<p>仿照c4编译器的写法：</p>
<p>这里我们的解释器主要包括4个函数：</p>
<ul>
<li><code>next()</code> 用于词法分析，获取下一个标记</li>
<li><code>program()</code> 用于语法分析，分析整个C语言的程序</li>
<li><code>expression(level)</code> 用于解析一个表达式</li>
<li><code>eval()</code> 虚拟机的入口，用于执行目标代码</li>
</ul>
<p>可能在此基础之上我会做出一点自己的改动，但是总体框架还是确定的，首先是实现对要解释的文件的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件全局变量</span></span><br><span class="line"><span class="type">int</span> line;       <span class="comment">// 当前行数</span></span><br><span class="line"><span class="type">char</span> *src;      <span class="comment">// 源文件内容</span></span><br><span class="line"><span class="type">char</span> *old_src;  <span class="comment">// 源文件备份</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> poolsize = <span class="number">256</span>*<span class="number">1024</span>; <span class="comment">// 内存池大小</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取源文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(*argv,<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, *argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(src = old_src = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((i=read(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not read %s\n&quot;</span>, *argv);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        src[i] = <span class="number">0</span>; <span class="comment">// 文件结束符</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将读取到的文件内容复制到<code>src</code>内存空间中。</p>
<p>现在我们就需要开始模拟一台计算机应有的功能了，我们的指令需要运行在我们的虚拟机上。那么首先，我们就需要定义一个自己的虚拟机，一台机器必须要有以下几个部分：</p>
<ul>
<li>内存： 这是用来存放数据的主要空间，我们的代码段数据
还有函数调用时的栈段都存放在这里</li>
<li>寄存器：我们需要寄存器帮助我们实现各种命令，同时也需要程序计数器指向我们的指令</li>
<li>CPU：本来这一部分应该是一大堆电路，但是这里我们可以通过操作指针和寄存器的方式，用一系列程序，简单的模拟它</li>
</ul>
<h2 id="计算机内部实现">计算机内部实现</h2>
<h3 id="内存">内存</h3>
<p>首先是内存部分，一般情况下，内存会被分成几个段。由于我们是简单实现的理想模型，我们只需要设置几个最基本的部分就可以了：</p>
<ul>
<li>代码段： 我们分析得到的指令就被存放在这里</li>
<li>数据段： 这里用来存放我们源程序中用的数据，通常和token信息绑定</li>
<li>栈段： 我们处理函数调用将会用到它，存放栈帧和局部变量等数据</li>
</ul>
<p>现在我们就可以简单的对我们的模拟的计算机内存进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 内存布局</span></span><br><span class="line"><span class="type">int</span> *text;          <span class="comment">// 代码段</span></span><br><span class="line"><span class="type">int</span> *old_text;      <span class="comment">// 代码段备份</span></span><br><span class="line"><span class="type">int</span> *<span class="built_in">stack</span>;         <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> *data;         <span class="comment">// 数据段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(text = old_text = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for text\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">stack</span> = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for stack\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(data = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for data\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(text, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, poolsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄存器">寄存器</h3>
<p>寄存器用来存放计算机的运行状态，我们的虚拟机中只简单的使用四个寄存器，分别是：</p>
<ul>
<li><code>PC</code>程序计数器，用于存放一个内存地址，该地址中用于存放下一条要执行的指令</li>
<li><code>SP</code>寄存器，永远指向当前的栈顶（注意这里的栈是从高地址向低地址增长的）</li>
<li><code>BP</code>基址寄存器，用于指向栈底，当我们在函数调用解析参数时需要用到它</li>
<li><code>AX</code>通用寄存器，用来存放一条指令执行后的结果</li>
</ul>
<p>我们对他们进行简单的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 寄存器</span></span><br><span class="line"><span class="type">int</span> *pc;            <span class="comment">// 程序计数器</span></span><br><span class="line"><span class="type">int</span> *bp;            <span class="comment">// 基址指针</span></span><br><span class="line"><span class="type">int</span> *sp;            <span class="comment">// 栈指针</span></span><br><span class="line"><span class="type">int</span> ax;             <span class="comment">// 通用寄存器</span></span><br><span class="line"><span class="type">int</span> cycle;          <span class="comment">// 时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 寄存器初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        bp = sp = (<span class="type">int</span>*)((<span class="type">char</span>*)<span class="built_in">stack</span> + poolsize);</span><br><span class="line">        ax = <span class="number">0</span>;</span><br><span class="line">        cycle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<p>现在我们的虚拟机已经有了基本的骨架，我们可以开始尝试实现我们我们虚拟机最基本的指令集。不过首先我们需要明确我们需要用到哪些指令。这里我们直接照搬C4的指令集就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">       LEA, IMM, JMP, CALL, JZ, JNZ, ENT, ADJ, LEV,</span><br><span class="line">       LI, LC, SI, SC, PUSH,</span><br><span class="line">       OR, XOR, AND, EQ, NE, LT, GT, LE, GE,</span><br><span class="line">       SHL, SHR, ADD, SUB, MUL, DIV, MOD,</span><br><span class="line">       OPEN, READ, CLOS, PRTF, MALC, MSET, MCMP, EXIT </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些指令顺序是有意的，带有参数的指令在前，没有参数指令的放在后面，为了方便我们之后打印调试信息。</p>
<h4 id="mov">MOV</h4>
<p><code>MOV dest,src</code>x86中最基础重要的一个公式，它将<code>SOURCE</code>中的内容放在<code>DEST</code>中。但在我们的虚拟机中只提供了一个通用寄存器<code>AX</code>，加上由于对参数类型的识别是一件复杂的事情，所以我们将<code>MOV</code>拆分成五个子操作来实现：</p>
<ul>
<li><code>IMM &lt;num&gt;</code>
将<code>num</code>放入寄存器<code>ax</code>中</li>
<li><code>LC</code>
将对应地址中的字符载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>LI</code>
将对应地址中的整数载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>SC</code>将<code>ax</code>中的数据作为字符存放入地址中，要求栈顶存放地址</li>
<li><code>SI</code>将<code>ax</code>中的数据作为整数存放入地址中，要求栈顶存放地址</li>
</ul>
<p>这样的拆分，极大程度上的减小了指令实现的复杂度，现在我们可以开始具体的实现了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> op, *tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == IMM) &#123;ax = *pc++;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LC) &#123;ax = *(<span class="type">char</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LI) &#123;ax = *(<span class="type">int</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SC) &#123; *(<span class="type">char</span>*)*sp++ = ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SI) &#123; *(<span class="type">int</span>*)*sp++ = ax;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里得<code>*sp++</code>实际上就是一个退栈操作，将值存储到弹出得地址中。</p>
<p>这里我之前一直没有搞懂，为什么<code>LI/LC</code>要将对应地址中的字符载入<code>ax</code>中，因为我们的默认的计算结果是存储在<code>ax</code>中的，也就是我们指令计算出的地址，可以直接被<code>LI/LC</code>所使用，这样就很高效。</p>
<h4 id="push">PUSH</h4>
<p><code>PUSH</code>的作用很简单，就是将值或者寄存器压入到栈中。在这里我们<code>PUSH</code>的作用给就是将<code>ax</code>的值压入栈中，因为我们只有这一个寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == PUSH) &#123;*--sp = ax;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jmp">JMP</h4>
<p><code>JMP &lt;addr&gt;</code>是跳转指令，无条件的将当前的<code>PC</code>寄存器设置为指定的<code>&lt;addr&gt;</code>，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JMP) &#123;pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>pc始终指向的是下一条指令，所以此时它存放的存放的是JMP指定的参数，即<code>&lt;addr&gt;</code>的值</p>
<h4 id="jzjnz">JZ/JNZ</h4>
<p>为了实现<code>if</code>语句
我们也需要条件判断相关的指令。这里我们只需要实现两个最简单的条件判断，即<code>ax==0/ax!=0</code>的情况下的跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JZ) &#123;pc = ax ? pc+<span class="number">1</span> : (<span class="type">int</span>*)*pc;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JNZ) &#123;pc = ax ? (<span class="type">int</span>*)*pc : pc+<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子函数调用">子函数调用</h3>
<p>这个是比较重要的一部分，我很大程度上也是为了这一部分重新回头别写这个编译器。这里我们将根据子函数调用约定，用几个最简单的指令来实现这个过程，我们要引入的指令有<code>CALL ENT ADJ LEV</code>。</p>
<p>首先我们介绍<code>CALL</code>，它用于跳转到一个子函数的开始地址。程序将会跳转到地址<code>&lt;addr&gt;</code>，并将当前的位置信息保存起来，以用于函数调用后的返回。这里我们将返回的PC存放在栈中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == CALL) &#123;*--sp = (<span class="type">int</span>)(pc+<span class="number">1</span>); pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们能进入调用函数了，那么我们便需要进一步的规范我们的函数调用规则。在实际的函数调用中，我们不仅要考虑函数的地址，也要考虑如何传递参数和返回结果，这里我们将每次的返回结果保存在<code>ax</code>中，对于参数传递，我们需要遵循C语言的调用标准：</p>
<ul>
<li>由调用者将参数入栈</li>
<li>调用结束时，由调用者将参数出栈</li>
<li>参数逆序入栈（因为先进后出）</li>
</ul>
<p>我们可以看下面的这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callee</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ret += <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会生成下面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     1, esp       ; save stack for variable: i</span><br><span class="line">; push call arguments</span><br><span class="line">push    3</span><br><span class="line">push    2</span><br><span class="line">push    1</span><br><span class="line">; call subroutine &#x27;callee&#x27;</span><br><span class="line">call    callee</span><br><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, 12</span><br><span class="line">; use subroutine result</span><br><span class="line">add     eax, 5</span><br><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>但是我们的虚拟机难以解决其中的几个问题：</p>
<ul>
<li><code>push ebp</code> 我们的PUSH无法指定寄存器</li>
<li><code>mov ebp,esp</code> 我们的MOV也无法直接指定源和目的</li>
<li><code>add esp,12</code> 我们的ADD也无法直接实现两个操作数的加法</li>
</ul>
<p>所以我们需要额外的指令来代替这几个的功能，所以我们需要定义以下几个指令：</p>
<h4 id="ent">ENT</h4>
<p><code>ENT &lt;size&gt;</code>指的是<code>enter</code>我们用它实现<code>make new call frame</code>的操作，即保存当前的栈指针，并在栈上保留一定的空间，用来存放局部变量，汇编代码的表现形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     size, esp       ; save stack for variable</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ENT) &#123;*--sp = (<span class="type">int</span>)bp; bp = sp; sp = sp - *pc++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="adj">ADJ</h4>
<p><code>ADJ &lt;size&gt;</code>用于实现<code>remove argument from frame</code>。用于将调用子函数时压入栈中的数据清楚，之所以单独定义这个指令，是对我们ADD功能局限做出的妥协。其汇编实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, size</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ADJ) &#123;sp = sp + *pc++;&#125;    <span class="comment">// add esp &lt;size&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lev">LEV</h4>
<p>本质上这个指令并不是必需的而且我们的指令集中并没有<code>POP</code>的指令，所以为了简洁的进行函数的退出操作，我们专门定义了<code>LEV</code>的封装。对应的汇编操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>我们用以下形式实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEV) &#123;sp = bp; bp = (<span class="type">int</span>*)sp++; pc = (<span class="type">int</span>*)*sp++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>上述的指令解决了调用帧的问题，解决了我们函数的运行和返回的问题。现在，为了进一步的执行调用函数，我们需要想办法获取先前压入的参数。在此之前，我们首先需要了解当参数调用时，栈中的调用帧是什么样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sub_function(arg1, arg2, arg3);</span><br><span class="line"></span><br><span class="line">|    ....       | high address</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 1        |    new_bp + 4</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 2        |    new_bp + 3</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 3        |    new_bp + 2</span><br><span class="line">+---------------+</span><br><span class="line">|return address |    new_bp + 1</span><br><span class="line">+---------------+</span><br><span class="line">| old BP        | &lt;- new BP</span><br><span class="line">+---------------+</span><br><span class="line">| local var 1   |    new_bp - 1</span><br><span class="line">+---------------+</span><br><span class="line">| local var 2   |    new_bp - 2</span><br><span class="line">+---------------+</span><br><span class="line">|    ....       |  low address</span><br></pre></td></tr></table></figure>
<p>我们首先将参数压入栈中，然后进行调用，调用会将返回地址压入栈中，然后保存当前的栈基址（我们将这个保存的栈帧称为<code>old_bp</code>），准备创建下一个栈帧。当前视图就是进行<code>push rbp; mov rbp,rsp;</code>之后的栈帧状态。此时如果我们想要访问函数的第一个参数，我们就需要访问<code>new_bp+4</code>地址上的内容。</p>
<p>但是这里有一个问题，我们的ADD指令无法对bp进行运算，所以我们需要设置一个新的指令，用于访问栈帧上的地址<code>LEA &lt;offset&gt;</code>。我们具体的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEA) &#123;ax = (<span class="type">int</span>)(bp + *pc++);&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们就完成了实现函数调用的所有指令了。</p>
<h3 id="运算符指令">运算符指令</h3>
<p>我们在C语言中支持的各种运算符号都是二元的，所以我们指令的参数也应该是由两个的，但是我们只有一个通用寄存器，这就导致我们需要将其中一个参数放在栈上，另一个参数存放在<code>ax</code>中，我们通过指令计算出来的结果也存放在ax上。</p>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == OR)  ax = *sp++ | ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == XOR) ax = *sp++ ^ ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == AND) ax = *sp++ &amp; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == EQ)  ax = *sp++ == ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == NE)  ax = *sp++ != ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LT)  ax = *sp++ &lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LE)  ax = *sp++ &lt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GT)  ax = *sp++ &gt;  ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GE)  ax = *sp++ &gt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHL) ax = *sp++ &lt;&lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHR) ax = *sp++ &gt;&gt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADD) ax = *sp++ + ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SUB) ax = *sp++ - ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MUL) ax = *sp++ * ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == DIV) ax = *sp++ / ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MOD) ax = *sp++ % ax;</span><br></pre></td></tr></table></figure>
<h3 id="内置命令">内置命令</h3>
<p>有很多由系统支持的函数，我们往往难以在机器上支持实现，所以这里我们简单的对函数进行封装，设置为内置的指令，用来支持一些常用的库函数调用。</p>
<p>这里我们就简单的对<code>exit open close read printf malloc memset</code>指令进行封装以确保我们的程序有基本的能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == EXIT) &#123;<span class="built_in">printf</span>(<span class="string">&quot;exit(%d)&quot;</span>, *sp); <span class="keyword">return</span> *sp;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == OPEN) &#123;ax = open((<span class="type">char</span> *)sp[<span class="number">1</span>], sp[<span class="number">0</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == CLOS) &#123;ax = close(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == READ) &#123;ax = read(sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == PRTF) &#123;tmp = sp+pc[<span class="number">1</span>]; ax = <span class="built_in">printf</span>((<span class="type">char</span>*)tmp[<span class="number">-1</span>],tmp[<span class="number">-2</span>],tmp[<span class="number">-3</span>],tmp[<span class="number">-4</span>],tmp[<span class="number">-5</span>],tmp[<span class="number">-6</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MALC) &#123;ax = (<span class="type">int</span>)<span class="built_in">malloc</span>(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MSET) &#123;ax = (<span class="type">int</span>)<span class="built_in">memset</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MCMP) &#123;ax = <span class="built_in">memcmp</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的参数在函数调用时是顺序入栈，所以看起来比较反直觉，结合栈是自顶向下索引的，所以我们最终可以很好的理解我们的参数调用顺序。</p>
<p>最后在加上一个错误判断，我们的虚拟机指令就完成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown instruction:%d\n&quot;</span>, op);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<p>现在我们的虚拟机指令就完成了，我们可以做一个简单的测试，来看我们的机器能否正确的运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">pc = text;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">12</span>;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">5</span>;</span><br><span class="line">text[i++] = DIV;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">1</span>;</span><br><span class="line">text[i++] = EXIT;</span><br></pre></td></tr></table></figure>
<p>程序执行的结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/c4$ ./a.out</span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="number">2</span>)</span></span><br></pre></td></tr></table></figure>
<p>至此我们的虚拟机以及指令架构就完成了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">243k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:45</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
