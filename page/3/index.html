<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/13/73-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/13/73-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-3/" class="post-title-link" itemprop="url">73:异常控制流(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-13 13:08:39 / 修改时间：17:28:38" itemprop="dateCreated datePublished" datetime="2025-08-13T13:08:39+08:00">2025-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" itemprop="url" rel="index"><span itemprop="name">异常控制流</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="信号">信号</h1>
<p>我们已经认识到了操作系统怎么通过异常使得进程上下文切换，以实现异常控制流的实现。现在我们将尝试另一种实现——<strong>Linux信号</strong>，来允许进程和内核中断其他的进程。</p>
<p>我们可以将信号理解成一条消息，它通知进程系统中发生了某一个事件。每种信号类型都会对应于某种系统事件。然后由不同的处理程序去处理这个事件。我们可以通过<code>man 7 signal</code>来进一步的认识这些信号：</p>
<figure>
<img src="https://s2.loli.net/2025/08/13/iSXhvnLw5c41CY9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="信号术语">信号术语</h2>
<p>传送一个信号到目的进程可以分作两个步骤：</p>
<ul>
<li><strong>发送信号：</strong>内核通过更新目的进程的上下文中的某个状态，从而实现发送一个信号给目的进程。发送信号一般有以下两种原因：1)内核检测到了一个系统事件，2)一个进程调用了kill函数，显式的要求内核发送一个信号给目的进程</li>
<li><strong>接收信号：</strong>当目的进程被内核强迫对信号的发送做出反应时，我们就说它接受了信号。目的进程可以忽略这个信号，终止，或者通过执行信号处理程序的用户层来捕获这个信号。</li>
</ul>
<figure>
<img src="https://s2.loli.net/2025/08/13/tQ2OVL8gGhT9mKq.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>一个发出但没有被接收的信号我们称之为<strong>待处理信号</strong>。在任何时刻一个类型只会有一个待处理信号。如果一个进程中有一个类型为k的待处理信号。接下来任何发送到这个进程的类型为k的信号都不会再排队等候，而是被丢弃。同时一个进程可以选择阻塞接受某种信号。如果一个信号被阻塞，它可以发送，但是不会再被接收，直到取消对它的阻塞。</p>
<p>这个实现通过内核为每个进程维护这一个信号处理集合实现。在<code>pending</code>向量中维护着一个待处理信号的集合，在<code>blocked</code>向量中维护着一个阻塞信号的集合。当一个信号类型为<code>k</code>的信号被发送时，目的进程会检查其<code>pending</code>位是否已被设置，若是则丢弃；不是则设置。然后检查其<code>block</code>位是否被阻塞，若是则丢弃；若不是则接受信号，并清除<code>pending</code>位。</p>
<h2 id="发送信号">发送信号</h2>
<p>发送信号的机制，是基于进程组实现的。我们接下来进一步的理解信号的发送：</p>
<h3 id="进程组">进程组</h3>
<p>每个进程都只属于一个进程组。进程组是由一个正整数进程组ID来标识的。我们有以下函数可以认识并改变进程组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">//返回调用进程的进程组ID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">pid_t</span> pgid)</span>;	<span class="comment">//成功则返回0，失败则返回-1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，子进程和它的父进程是同属于一个进程组的。一个进程可以通过使用<code>setpgid</code>函数来改变自己或者其他进程的进程组。<code>setpgid</code>函数将<code>pid(目标进程PID)</code>进程加入到进程组<code>pgid(目标进程组ID)</code>。如果<code>pid</code>是0，就表示当前进程。如果<code>pgid</code>是0，就用<code>pid</code>的值作为新的<code>pgid</code>。</p>
<h3 id="kill程序发送信号">kill程序发送信号</h3>
<p><code>/bin/kill</code>程序可以向其他程序发送任意的信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -&lt;signalNumber&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>也可以向指定的进程组中的所有进程发送信号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -&lt;signalNumber&gt; -&lt;pgid&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以尝试一下：</p>
<figure>
<img src="https://s2.loli.net/2025/08/13/E8UBMIxsinXbcgG.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>此外我们也可以通过键盘发送信号</p>
<h3 id="从键盘发送信号">从键盘发送信号</h3>
<p>Uinx shell
中通常使用<code>job</code>（作业）来表示对一条命令行求值而创建的进程。在任何时刻，只有一个前台作业和0或多个后台作业。其中每个作业的都属于一个独立的进程组。</p>
<p>在键盘上<code>Ctrl+C</code>会导致内核发送一个<code>SIGINT</code>信号到前台进程组中的每个进程，导致作业终止。在键盘上<code>Ctrl+Z</code>会导致内核发送一个<code>SIGTSTP</code>信号到前台进程组中的每个进程，导致作业被停止（挂起）。</p>
<h3 id="用kill函数发送信号">用kill函数发送信号</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig)</span>	<span class="comment">//成功则返回0，失败则返回-1</span></span><br></pre></td></tr></table></figure>
<p>通过调用kill函数发送信号到其他进程。</p>
<ul>
<li>如果<code>pid&gt;0</code>，那么发送信号<code>sig</code>给进程<code>pid</code>。</li>
<li><code>pid=0</code>，那么发送信号<code>sig</code>给调用进程所在进程组中的每个进程，包括自己。</li>
<li><code>pid&lt;0</code>，则发送信号<code>sig</code>给进程组<code>|pid|</code>中的每个进程</li>
</ul>
<p>我们可以尝试编写一个程序来使用kill函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = Fork())==<span class="number">0</span>)&#123;</span><br><span class="line">        Pause();		<span class="comment">//将进程挂起，直到接收到一个信号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;never get it\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kill(pid,SIGKILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就实现了父进程击杀自己的子进程。</p>
<h3 id="用alarm函数发送信号">用alarm函数发送信号</h3>
<p>进程可以通过调用<code>alarm</code>函数向自己发送<code>SIGALRM</code>信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;	<span class="comment">//返回前一次闹钟剩余的秒数，若之前没有设置闹钟，返回0</span></span><br></pre></td></tr></table></figure>
<p><code>alarm</code>函数安排内核在<code>secs</code>秒之后发送一个<code>SIGALRM</code>信号给调用进程。如果<code>secs==0</code>，那么不会安排调度新的闹钟。在任何情况下，<code>alarm</code>的调用都会取消之前的待处理的闹钟，并返回前一个闹钟的剩余的秒数。</p>
<h2 id="接收信号">接收信号</h2>
<p>当内核把进程<code>p</code>从内核态切换到用户态时，它会检查进程<code>p</code>的未被阻塞的待处理信号的集合<code>pending &amp; ~blocked</code>。如果这个集合为空，那么内核将控制传递到<code>p</code>的逻辑控制流中的下一条指令。如果集合使非空的，那么内核选择集合中的某个信号<code>k</code>(通常是最小的<code>k</code>)，并强制<code>p</code>接收信号<code>k</code>。收到这个信号会触发某种行为。一旦进程完成这个行为，就会将控制传递回<code>p</code>的逻辑控制流中的下一条指令。</p>
<p>在上面展示信号类型的图中，也有每个信号类型相关联的默认行为。我们也可以通过<code>signal</code>函数修改和信号相关联的默认行为。唯一例外的是<code>SIGSTOP</code>和<code>SIGKILL</code>。它们的默认行为是不能修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum,<span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">//如果成功则返回指向前次处理程序的指针；否则返回SIG_ERR，不设置errno</span></span><br></pre></td></tr></table></figure>
<p><code>signal</code>函数通过以下三种方式之一来改变和信号<code>signum</code>相关联的行为：</p>
<ul>
<li>如果<code>handler</code>是SIG_IGN，那么忽略这个类型的信号</li>
<li>如果<code>handler</code>是SIG_DFL，那么恢复这个类型的信号的默认行为</li>
<li>否则，<code>handler</code>就是用户定义的函数的地址，这个函数被称为<strong>信号处理程序</strong>。当接收到指定的信号类型时就会调用信号处理程序，我们称之为<strong>捕获信号</strong>。一个处理程序可以捕获不同的信号。</li>
</ul>
<p>比如我们可以写一个程序用来改变<code>SIGINT</code>信号的默认行为（终止进程）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nOVER!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Signal(SIGINT,handler);</span><br><span class="line">    Pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然信号处理程序也可以被其他信号处理程序中断。例如在下图中演示了这个过程：</p>
<figure>
<img src="https://s2.loli.net/2025/08/13/5JV6lqbaiWARLEO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="阻塞和解除阻塞信号">阻塞和解除阻塞信号</h2>
<p>Linux提供了两种阻塞信号的机制：</p>
<ul>
<li><strong>隐式阻塞机制</strong>
内核默认阻塞任何当前处理程序正在处理的信号类型的待处理信号。</li>
<li><strong>显式阻塞机制</strong>
使用<code>sigprocmask</code>函数和它的辅助函数，明确阻塞/解除指定的信号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;	<span class="comment">//成功则返回0，否则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signum)</span>;	<span class="comment">//若是则返回1，不是则返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>sigprocmask</code>函数改变当前阻塞的信号集合（blocked位向量）。其具体的行为依赖于<code>how</code>值：</p>
<ul>
<li><strong>SIG_BLOCK</strong> 把set中的信号添加到blocked中
<code>blocked = set|blocked</code></li>
<li><strong>SIG_UNBLOCK</strong> 从blocked中删除set中的信号
<code>blocked = blocked &amp; ~set</code></li>
<li><strong>SIG_SETMASK</strong> 令<code>blocked = set</code></li>
</ul>
<p>如果<code>oldset</code>非空，则将之前的<code>blocked</code>保存在其中。对于其他的几个辅助函数：</p>
<ul>
<li><code>sigemptyset</code>初始化set为空集合</li>
<li><code>sigfillset</code>将每个信号都添加到set中</li>
<li><code>sigaddset</code>将signum加入到set中</li>
<li><code>sigdelset</code>从set中删除signum，如果signum是set的成员，返回1。不是则返回0</li>
</ul>
<h2 id="编写信号处理程序">编写信号处理程序</h2>
<p>这一部分太难了，我难以理解并接受。之后再来看看吧</p>
<h2 id="显式地等待信号">显式地等待信号</h2>
<p>和上面的关联度较高，涉及到竞争并发等内容，我暂时无法理解</p>
<h1 id="非本地跳转">非本地跳转</h1>
<p>C语言提供了一种用户级的异常控制流形式，即非本地跳转（本地跳转是<code>goto</code>），它将控制从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。其中非本地跳转是通过<code>setjmp</code>和<code>longjmp</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjump.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjump</span><span class="params">(jmp_buf env)</span>;	<span class="comment">//setjmp返回0，longjmp返回非0</span></span><br></pre></td></tr></table></figure>
<p><code>setjmp</code>函数会在env缓冲区中保存当前的调用环境（相当于设置一个锚点，保存当前状态），以供后面的<code>longjmp</code>使用，并返回0。注意<code>setjump</code>由于其特殊的返回机制，不能被存储在变量之中，但是可以被switch使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjump.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;	<span class="comment">//不返回</span></span><br></pre></td></tr></table></figure>
<p><code>longjmp</code>函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的<code>setjmp</code>调用的返回。然后<code>setjmp</code>返回，并带有非零的返回值<code>retval</code></p>
<p>注意到，setjmp只被执行一次，但是会返回多次：一次是第一次调用<code>setjmp</code>时，调用环境保存在缓冲区<code>env</code>中。一次时为每个相应的<code>longjmp</code>调用。另一方面，<code>longjmp</code>被调用一次，但是不返回。</p>
<p>通过非本地条状我们可以实现从一个深层嵌套的函数调用中立即返回，从而实现对错误的分析，而不用多次退出复杂的调用栈。我们以下面的程序为例，可以感受到非本地跳转的用途：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line">jmp_buf buf;</span><br><span class="line"><span class="type">int</span> error1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> error2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>,<span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(setjmp(buf))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            foo();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Detected error1 in foo\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Detected error2 in foo\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown error in foo\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error1)</span><br><span class="line">        longjmp(buf,<span class="number">1</span>);</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error2)</span><br><span class="line">        longjmp(buf,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然C中并没有异常的捕获函数，但是我们可以通过这种方式去实现。当遇到一个错误是，从setjmp返回，并解析它的错误类型。</p>
<p>同时，也要注意。<code>longjmp</code>允许跳过中间调用机制的过程可能回导致许多意外的后果。比如没有释放一些数据结构，导致内存泄露….</p>
<h1 id="写在最后">写在最后</h1>
<p>关于异常控制流我感觉还是比较抽象的。涉及到的函数很多，尤其是信号部分，牵连到许多并发相关的内容。对于现在的我而言还是太过超前，日后再来巩固。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/07/72-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/07/72-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-2/" class="post-title-link" itemprop="url">72:异常控制流(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-07 11:53:06 / 修改时间：17:14:57" itemprop="dateCreated datePublished" datetime="2025-08-07T11:53:06+08:00">2025-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" itemprop="url" rel="index"><span itemprop="name">异常控制流</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统调用错误处理">系统调用错误处理</h1>
<p>由于之后会用到大量的系统调用函数，我们需要做好错误处理，以便于查找问题。Uinx系统中的系统级函数遇到错误时会返回-1，并设置全局整数变量<code>errno</code>来表示错误类型。这个时候我们可以通过<code>strerror()</code>函数来返回和errno值相关联的错误。我们以处理<code>fork()</code>的错误为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork error: %s\n&quot;</span>,strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以进一步的封装这个错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s: %s\n&quot;</span>,msg,strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过错误处理包装函数，我们可以进一步的优化代码。对于错误处理包装函数，有一个约定成俗的规矩，对于基本函数<code>foo</code>，我们定义一个具有相同参数的包装函数<code>Foo</code>。包装函数调用基本函数，检查错误，如果有问题就终止。比如下面对<code>fork</code>的包装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之后的包装函数也会按照相同的处理模式，来进行编写。</p>
<h1 id="进程调用">进程调用</h1>
<p>Unix提供了大量从C程序中操作进程的系统调用，我们来详细了解他们：</p>
<h2 id="获取进程id">获取进程ID</h2>
<p>每个进程都有一个唯一的正数非零进程<code>PID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">()</span>;		<span class="comment">//返回调用进程的PID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">()</span>;	<span class="comment">//返回调用进程的父进程的PID</span></span><br></pre></td></tr></table></figure>
<p>这两个函数返回的类型为<code>pid_t</code>，在Linux中它们被<code>types.h</code>定义为<code>int</code></p>
<h2 id="创建和终止进程">创建和终止进程</h2>
<p>我们可以认为进程总是处于下面三种状态：</p>
<ul>
<li><strong>运行</strong>
进程要么在CPU上执行，要么在等待被执行且最终会被调度</li>
<li><strong>停止</strong>
进程的执行被挂起，且不会被调度。当收到<code>SIGSTOP SIGTSTP SIGTTIN SIGTTOU</code>信号时，进程就保持停止，直到它收到一个<code>SIGCONT</code>信号，这个时候，进程在次开始运行</li>
<li><strong>终止</strong>
进程永远地停止了。三种原因:1)收到终止进程信号，2)从主程序返回，3)调用exit()函数</li>
</ul>
<p>下面我们了解进程的创建和终止过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;	<span class="comment">//exit函数以status退出状态来终止进程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;	<span class="comment">//子进程返回0,父进程返回子进程的PID,如果出错返回-1</span></span><br></pre></td></tr></table></figure>
<p>新创建的子进程会得到父进程用户级虚拟地址空间相同的一份副本，包括代码、数据、用户栈、堆、共享库。子进程也会得到与父进程任何打开文件描述符相同的副本，这意味着当父进程调用<code>fork</code>时，子进程可以读取父进程中打开的所有文件。父子进程最大的区别就在于他们的PID不同</p>
<p>fork函数被调用一次，却会返回两次，这是因为调用之后创建了一个新的进程。然而，在两个进程中的返回值会有所不同，因此我们根据<code>fork()</code>的返回值来判断父子进程</p>
<p>我们可以用下面这个程序来展示一个进程的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	pid = Fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;	<span class="comment">//子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child: x = %d\n&quot;</span>,x+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: x = %d\n&quot;</span>,x<span class="number">-1</span>);	<span class="comment">//父进程</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到执行的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ./a.out</span><br><span class="line">parent: x = 0</span><br><span class="line">child: x = 2</span><br></pre></td></tr></table></figure>
<p>实际的运行过程我们可以简化成流程图：</p>
<figure>
<img src="https://s2.loli.net/2025/08/07/r8OAl2RgnLdvPNw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于整个过程我们可以从中注意到一些关键点：</p>
<ul>
<li><strong>调用一次，返回两次</strong>
fork函数被父进程调用一次，但是却返回两次——一次返回到父进程，一次返回到子进程。对于多个fork函数的情况我们之后会涉及</li>
<li><strong>并发执行</strong>
父子进程都是并发运行的独立进程。内核可能以任意方式交替执行它们的逻辑控制流的指令。因此我们不能对不同进程中指令的交替执行做出假设。不存在执行的先后关系</li>
<li><strong>相同但是独立的空间</strong>
通过观察局部变量x，我们可以看出，父子进程对x所作的改变都是独立的。说明它们之间的空间是独立的。根据数值可以判断，x的值是相同的。因此我们说父子进程的空间相同且独立。</li>
<li><strong>共享文件</strong>
printf将输出输入到stdout文件中，结果表明在子进程中的stdout也是打开的。子进程继承了这个文件，所以说父子进程中的文件描述符也是相同的</li>
</ul>
<p>理解了这些我们就可以理解更复杂的情况，我们可以通过流程图来更好的分析复杂的嵌套情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Fork();</span><br><span class="line">    Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://s2.loli.net/2025/08/07/ZQseSj79UoVKr8v.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="回收子进程">回收子进程</h2>
<p>当一个进程被终止时，内核不会立即将其清除。而是进程会处于一个终止的状态下，直到它的父进程将其回收。当父进程将终止的子进程回收时，内核将子进程的推出状态传递给了父进程，然后抛弃终止的进程。直到现在，这个进程才不存在了。对于处于终止状态，但没有被回收的进程，我们称之为僵死进程。</p>
<p>如果一个父进程终止了，内核会安排init进程作为它们的孤儿进程的养父。init进程的PID为1，是在系统启动时就由内核创建的，它不会终止，是所有内核的祖先，如果父进程没有回收它的僵死子进程就终止了。内核会安排init进程去回收它们。因为即使僵死子进程没有运行，也会消耗系统的内存资源</p>
<p>进程可以通过调用<code>waitpid</code>函数来等待它的子进程终止或停止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 如果成功终止就返回子进程的PID;如果WNOHANG,则为0;其他错误,则为-1</span></span><br></pre></td></tr></table></figure>
<p>waitpid函数比较复杂，我们需要仔细讨论一下。</p>
<p>默认情况下(options=0),waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在刚调用的时候就已经终止了，那么waitpid就立即返回。在这两种情况中，waitpid会返回导致waitpid返回的已终止进程的PID。此时，已终止的子进程会被回收，内核会清理它的痕迹。</p>
<p>这个过程非常的抽象，我们需要深入去理解waitpid:</p>
<h3 id="判定等待集合的成员">判定等待集合的成员</h3>
<p>等待集合的成员由参数pid确定：</p>
<ul>
<li>如果pid&gt;0，那么等待集合就是一个单独的子进程，它的进程ID等于pid</li>
<li>如果pid=-1，那么等待集合就是由父进程所有的子进程组成的</li>
</ul>
<h3 id="修改默认行为">修改默认行为</h3>
<p>可以通过修改<code>options</code>为各个常量从而实现修改默认行为<strong>：</strong></p>
<ul>
<li><p><strong>WNOHANG</strong></p>
<p>如果等待集合中的任何子进程都没有终止，那么就立即返回。而默认的行为是挂起调用进程，直到有子进程终止。默认行为是等待的，会阻塞之后的操作。如果想要在等待子进程终止的同时，想要进行别的工作，我们就可以启用这个选项</p></li>
<li><p><strong>WUNTRACED</strong></p>
<p>挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或者被停止的子进程的PID。默认是返回导致返回的已终止的子进程。如果想要检查已终止和被停止的子进程时，可以启用这个选项。</p></li>
<li><p><strong>WCONTINUED</strong></p>
<p>挂起调用进程的执行，直到等待集合中一个正在运行的进程变成已终止或等待集合中一个被停止的进程收到<code>SIGCONT</code>信号重新开始执行</p></li>
</ul>
<p>这些常量可以通过”|“来连接，从而更改行为</p>
<h3 id="检查已回收子进程的退出状态">检查已回收子进程的退出状态</h3>
<p>status是statusp指向的值，如果这个值不为NULL。waitpid就会在status中放上关于导致返回的子进程的状态信息。我们可以通过&lt;wait.h&gt;中定义的宏来解释status参数：</p>
<ul>
<li><strong>WIFEXITED()</strong>
如果子进程通过exit或return正常终止则返回真</li>
<li><strong>WEXITSTATUS()</strong>
返回一个正常终止的子进程的退出状态。只有WIFEXITED()返回为真时，才有这个状态</li>
<li><strong>WIFSIGNALED()</strong>
如果子进程是因为一个未被捕获的信号终止的，那么返回真</li>
<li><strong>WTERMSIG()</strong>
返回导致子进程终止的信号的编号。只有WIFSIGNALED()返回为真时，才有这个状态</li>
<li><strong>WIFSTOPPED()</strong> 如果子进程是停止的，就返回真</li>
<li><strong>WSTOPSIG()</strong>
返回引起子进程停止的信号的编号。只有WITSTOPPED()返回为真时，才有这个状态</li>
<li><strong>WIFCONTINUED()</strong>
如果子进程收到SIGCONT信号重新启动，则返回真</li>
</ul>
<h3 id="错误条件">错误条件</h3>
<p>如果调用进程没有子进程，则返回-1，设置errno=ECHILD</p>
<p>如果waitpid被信号中断，返回-1，设置errno=EINTR</p>
<h3 id="wait函数">wait函数</h3>
<p><code>wait()</code>是<code>waitpid()</code>的简化版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* statusp)</span>;</span><br><span class="line"><span class="comment">//如果成功，返回子进程PID;否则返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>wait(&amp;status)</code>等价于<code>waitpid(-1,&amp;status,0)</code></p>
<h2 id="让进程休眠">让进程休眠</h2>
<p>sleep函数可以将一个进程挂起指定的时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;	<span class="comment">//返回还要休眠的秒数</span></span><br></pre></td></tr></table></figure>
<p>如果请求的时间到了，就返回0；否则返回还要休眠的秒数，这种情况是因为sleep可能会被信号中断而过早返回。</p>
<p>另一个函数是puase，该函数让进程休眠，直到收到信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">()</span>;	<span class="comment">//总是返回-1</span></span><br></pre></td></tr></table></figure>
<h2 id="加载并运行程序">加载并运行程序</h2>
<p>execve函数用于在当前进程的上下文中加载并运行一个新的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">char</span>* argv[],</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">char</span>* envp[])</span>;</span><br><span class="line"><span class="comment">//如果成功，则不返回；否则返回-1</span></span><br></pre></td></tr></table></figure>
<p>execve函数加载并运行可执行目标文件filename，且待参数列表argv和环境变量列表envp。只有出现错误时，execve才会返回到调用程序。正常情况下调用一次不返回。</p>
<p>在execve加载了filename之哦胡。它会调用启动代码<code>__libc_start_main</code>。启动代码设置栈，并将控制传递给新程序的主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[],<span class="type">char</span>*envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>当main开始执行时，用户栈的组织结构如下：</p>
<figure>
<img src="https://s2.loli.net/2025/08/07/CmR8H3ILYJb6aoD.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们从高地址往下看，先是存放了参数和环境的字符串。然后是以NULL结尾的指针数组，其中每个指针都指向栈中的一个字符串。其中全局变量environ指向这些指针中的第一个envp[0]。在栈的顶部是系统启动函数<code>__libc_start_main</code>的栈帧。</p>
<p>main的三个参数：</p>
<ul>
<li>argc 给出argv[]数组中非空指针的数量</li>
<li>argv 指向argv[]数组中的第一个条目</li>
<li>envp 指向envp[]数组中的第一个条目</li>
</ul>
<p>同时LInux还提供了几个函数用来操作环境数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;	<span class="comment">//若存在则返回指向name的指针；否则返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">const</span> <span class="type">char</span>* newvalue,<span class="type">int</span> overwrite)</span>; <span class="comment">//成功则返回0；否则返回-1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>; <span class="comment">//不返回</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getenv函数在环境数组中搜索字符串“name=value”。如果找到了，就返回指向value的指针。</li>
<li>unsetenv函数查找字符串”name=value”，并删除</li>
<li>setenv函数找到环境变量”name=value”后，会用新的value替换；否则则创建一个”name=new_value”的环境变量。overwrite用来控制是否覆盖已存在的同名环境变量，0则不覆盖。</li>
</ul>
<h2 id="使用fork和execve">使用fork和execve</h2>
<p>我们写一个shell。shell打印一个命令行提示符，我们在stdin上输入命令行，然后对这个命令执行。于是我们可以搭建出一个简单的框架:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shell.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">                Fgets(cmdline,MAXLINE,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(feof(<span class="built_in">stdin</span>))</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                eval(cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先需要解析命令行参数，我们以空格作为分隔符，同时返回一个参数列表<code>argv</code>。如果命令的参数以<code>&amp;</code>结尾，我们就把这个程序放在后台运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf,<span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* delim;    <span class="comment">// 指向分隔符的指针</span></span><br><span class="line">        <span class="type">int</span> argc;               <span class="comment">// 参数数量</span></span><br><span class="line">        <span class="type">int</span> bg;                 <span class="comment">// 是否为后台程序</span></span><br><span class="line"></span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="string">&#x27; &#x27;</span>; <span class="comment">// \0替换为空格</span></span><br><span class="line">        <span class="keyword">while</span>(*buf &amp;&amp; (*buf==<span class="string">&#x27; &#x27;</span>)) <span class="comment">// 忽略多余的空格</span></span><br><span class="line">                buf++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析参数</span></span><br><span class="line">        argc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((delim = <span class="built_in">strchr</span>(buf,<span class="string">&#x27; &#x27;</span>)))&#123;</span><br><span class="line">                argv[argc++] = buf;</span><br><span class="line">                *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                buf = delim+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(*buf &amp;&amp; (*buf==<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">                        buf++;</span><br><span class="line">        &#125;</span><br><span class="line">        argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否应该在后台运行</span></span><br><span class="line">        <span class="keyword">if</span>((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">                argv[argc<span class="number">-1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析好命令参数后，我们也需要判断第一个参数是否为程序名，或者是shell的内置函数。如果是内置函数我们就执行该函数，并返回1；如果不是就返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;cd&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                        chdir(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">                chdir(argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们就可以写出我们的执行函数了，如果<code>builtin_comand</code>返回0，我们就需要创建一个新的子进程并加载程序运行。然后根据是否后台运行的需求，使用waitpid进行对前台程序的等待。当作业结束后，再进行一次迭代。我们的Shell就粗略的完成了。但是现在有一个问题，我们的shell不能回收已经结束的子进程，我们会在之后加以改进。程序的完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csapp.h	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s: %s\n&quot;</span>,msg,strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">Fgets</span><span class="params">(<span class="type">char</span>* str,<span class="type">int</span> n,FILE* stream)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* p = fgets(str,n,stream);</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// shell.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行命令行任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="comment">//解析参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="comment">//判断Shell内联函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf,<span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* delim;    <span class="comment">// 指向分隔符的指针</span></span><br><span class="line">        <span class="type">int</span> argc;               <span class="comment">// 参数数量</span></span><br><span class="line">        <span class="type">int</span> bg;                 <span class="comment">// 是否为后台程序</span></span><br><span class="line"></span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="string">&#x27; &#x27;</span>; <span class="comment">// \0替换为空格</span></span><br><span class="line">        <span class="keyword">while</span>(*buf &amp;&amp; (*buf==<span class="string">&#x27; &#x27;</span>)) <span class="comment">// 忽略多余的空格</span></span><br><span class="line">                buf++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析参数</span></span><br><span class="line">        argc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((delim = <span class="built_in">strchr</span>(buf,<span class="string">&#x27; &#x27;</span>)))&#123;</span><br><span class="line">                argv[argc++] = buf;</span><br><span class="line">                *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                buf = delim+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(*buf &amp;&amp; (*buf==<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">                        buf++;</span><br><span class="line">        &#125;</span><br><span class="line">        argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否应该在后台运行</span></span><br><span class="line">        <span class="keyword">if</span>((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">                argv[argc<span class="number">-1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;cd&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                        chdir(<span class="string">&quot;~&quot;</span>);</span><br><span class="line">                chdir(argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* argv[MAXARGS];    <span class="comment">//参数列表</span></span><br><span class="line">        <span class="type">char</span> buf[MAXLINE];      <span class="comment">//命令存储区</span></span><br><span class="line">        <span class="type">int</span> bg;                 <span class="comment">//是否后台调用</span></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">        bg = parseline(buf,argv);</span><br><span class="line">        <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!builtin_command(argv))&#123;</span><br><span class="line">                <span class="keyword">if</span>((pid = Fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// printf(&quot;%s&quot;,argv[0]);</span></span><br><span class="line">                        <span class="keyword">if</span>(execvp(argv[<span class="number">0</span>],argv)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;Command not found\n&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!bg)&#123;</span><br><span class="line">                        <span class="type">int</span> status;</span><br><span class="line">                        <span class="keyword">if</span>(waitpid(pid,&amp;status,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                                unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,pid,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shell.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        Fgets(cmdline,MAXLINE,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/06/71-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/06/71-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-1/" class="post-title-link" itemprop="url">71:异常控制流(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-06 10:49:30 / 修改时间：18:26:11" itemprop="dateCreated datePublished" datetime="2025-08-06T10:49:30+08:00">2025-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" itemprop="url" rel="index"><span itemprop="name">异常控制流</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常">异常</h1>
<p>从处理器加电一直到断电，程序计数器始终执行着一个序列的指令。每次从一个指令到下一条指令的过渡被称为控制转移。而这个控制转移序列则被称为处理器的<strong>控制流</strong>。最简单的控制流是一个平滑的序列，由诸如跳转，调用，返回一类的指令造成的。这些指令都是必要的，使程序能根据程序内部状态做出反映。</p>
<p>但是系统也应该能对系统状态的变化做出反应，这些系统状态不会被内部程序变量捕获，也不一定和程序的执行相关。可能是某个硬件向系统发出的信号或是请求。这个时候原本的控制流是难以处理这些情况的，所以现代的系统通过使控制流发生突变，从而对这些情况做出反应。一般而言，我们将这些突变称作<strong>异常控制流(ECF)</strong></p>
<p>异常则是异常控制流的一种形式，指的是控制流中的突变，用来响应处理器的某些变化，下图就反映了这个过程：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/K1RtFgpsSHPenb5.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当处理器状态发生一个重要的变化时，这个状态的变化我们称之为<strong>事件</strong>。事件和当前执行的指令相关，比如以0作为除数，算数溢出……</p>
<p>当处理器检测到事件发生时，它就会通过一张叫<strong>异常表</strong>的跳转表，进行一个间接过程的调用（异常），到一个专门设计用来处理这些事件的操作系统子程序（异常处理程序）。事件经过处理后，根据事件类型，程序会进入其中一种状态：</p>
<ul>
<li>控制返回给当前指令<code>I_curr</code>，即事件发生时的指令</li>
<li>控制返回给<code>I_next</code>，如果没有发生异常将会执行的下一条指令</li>
<li>终止该程序</li>
</ul>
<h2 id="异常处理">异常处理</h2>
<p>我们进一步的了解一下，异常处理的过程中都发生了什么。</p>
<p>系统为每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>。号码的分配也有所区别，处理器设计者分配的异常号码通常是零除，内存访问违例，算数溢出一类的。另一部分是，操作系统的内核的设计者分配的，如系统调用和来自外部I/O设备的信号.</p>
<p>在系统启动时，操作系统会分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/nm6rfDzxywHFeiN.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当运行时，处理器检测到发生了一个事件，且确定了其异常号k时。处理器会触发异常，执行间接过程调用，通过异常表的表目k，跳转到相应的处理程序，其过程如下
：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/waGlhBZuQ9CeAgq.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>异常表基址寄存器是用来存放异常表地址的特殊寄存器，在异常表中，异常号是到异常表的索引。</p>
<p>异常类似于过程调用，但是有些区别：</p>
<ul>
<li>过程调用时，会把返回地址压入栈中（确定的）。但是，根据异常类型，返回的地址会有所不同，返回地址要么是当前指令（事件发生时的执行的指令），要么是下一条指令</li>
<li>由于要切换到异常处理程序，所以我们需要保存额外的处理器状态（通用寄存器，PC，条件寄存器…）以保存上下文。</li>
<li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是用户栈。</li>
<li>异常处理程序运行在内核模式下，它们对所有系统资源都有访问权</li>
</ul>
<p>当硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完毕之后，通过“从终端返回”指令，可选的返回到被中断的程序，该指令将保存的状态弹回寄存器中。并恢复用户模式，将控制返回给呗中断的程序。</p>
<h2 id="异常的类别">异常的类别</h2>
<p>异常可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)、终止(abort)</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/i2FmTvkAgyI4xrB.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="中断">中断</h3>
<p>中断时异步发生的，时来自处理器外部的I/O设备的信号的结果。硬件中断不是由指令造成的，且不可预测，所以我们说它是异步的。硬件中断的异常处理程序称之为中断处理程序</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/vQmHLj5XZ9cNuab.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>设备会将异常号放到系统总线上，并且向处理器的中断引脚发送信号。当处理器发现中断引脚电压升高，就会读取异常号，调用中断处理程序。当处理程序返回时，就将控制返回给下一条指令。这样从外界看，就好像没有发生过中断一样。</p>
<p>剩下的异常类型都是同步发生的，他们是执行当前指令的结果。我们把这类指令叫做故障指令。</p>
<h3 id="陷阱和系统调用">陷阱和系统调用</h3>
<p>陷阱是有意的异常，是一条指令执行的结果。它可以在用户程序和内核之间提供一个像过程一样的接口，即<strong>系统调用</strong>。</p>
<p>用户程序经常需要像内核请求服务。如读取文件(read)、创建一个新的进程(fork)、加载一个新的程序(exec)、终止当前进程(exit)。为了支持对这些内核服务的访问，处理器支持<code>syscall n</code>指令，当用户想要请求服务<code>n</code>时，可以执行这个指令。执行<code>syscall</code>会导致一个到异常处理程序的陷阱，这个处理程序会解析参数，调用合适的内核程序。</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/VtKIB6imG1yMTox.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>看起来系统调用和函数调用是一样的，但是实际上函数调用是在用户模式下进行，用户模式限制了函数可执行的指令的类型，而且他们只能访问于调用函数相同的栈。系统调用则是运行在内核模式中，内核模式允许指令调用特权指令，并访问内核中的栈。</p>
<h3 id="故障">故障</h3>
<p>故障是由错误情况导致的，它可能会被故障处理程序修正。当故障发生，处理器会将控制传递给故障处理程序。如果故障被修读，就将控制传递会引起故障的程序，重新执行。否则，船里程序会返回<code>abort</code>历程例程，从而终止引起故障的应用程序。</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/rFLMOPeKX2n5YJb.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="终止">终止</h3>
<p>终止是不可恢复的错误造成的结果
。终止处理程序不会将控制返回给应用程序，而是但会给一个abort例程，从而终止这个应用。</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/GbrpKvjw8Nls5df.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="linuxx86-64系统中的异常">Linux/x86-64系统中的异常</h2>
<p>为了认识的更加具体，我们可以看看x86_64系统定义的一些异常。其中<code>0~31</code>的号码对应Intel架构定义的异常。<code>32~255</code>的号码对应的是操作系统定义的中断和陷阱。</p>
<p>这是一些比较常见的：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/y5lTFS4qr3jDmku.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="故障和终止">故障和终止</h3>
<ul>
<li><strong>除法错误：</strong>当试图除0时，或者一个除法指令的结果对于目标操作数而言太大的时候，就会导致除法错误。在LinuxShell里面，执行一个有除法错误的程序会报告<code>Floating point exception</code></li>
<li><strong>一般保护故障：</strong>这个故障比较容易触发，通常是因为程序引用了一个未定义的虚拟内存区域，或者是尝试写一个只读文本段。Linux不会恢复这类故障，会报告为段故障<code>Segmentation fault</code></li>
<li><strong>缺页：</strong>这是一个会重新执行产生故障的指令的一个异常示例。处理程序会将适当的磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这个产生故障的指令。</li>
<li><strong>机器检查：</strong>机器检查是在导致故障的指令执行中检测到致命的硬件错误时发生的。</li>
</ul>
<h3 id="系统调用">系统调用</h3>
<p>下面展示一些常用的系统调用</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/rUEbyfLgIjKPdHn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>C语言中可以用syscall来进行系统调用。不过没必要，因为在&lt;unistd.h&gt;头文件中，封装了许多对操作系统底层服务的访问接口。我们将这些系统调用和包装函数称为系统级函数。</p>
<p>在Linux系统中，我们使用<code>syscall</code>陷阱指令来实现系统调用。它的调用过程如下：</p>
<p>使用寄存器<code>%rax</code>包含系统调用号，使用寄存器<code>%rdi %rsi %rdx %r10 %r8 %r9</code>来依次传递参数。从系统调用返回时，<code>%r11 %rcx</code>会被破坏（因为rcx用来存放返回地址，r11存放标志寄存器），<code>%rax</code>存放返回值。如果返回值是负数则说明发生错误。</p>
<p>可以通过查看系统级函数的编译来看到这个参数传递的过程:</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/9DruvC53JEP8AnI.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="进程">进程</h1>
<p>在系统上运行一个程序时，我们会得到一个假象，我们的程序似乎是系统中的唯一一个程序，独占着内存和处理器的使用。但事实并非如此。</p>
<p>系统中的每个程序都运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成。这个状态包括许多，如存放在内存中的数据和代码，它的栈、通用寄存器的内容、程序计数器、环境变量、和打开文件描述符的集合。</p>
<p>每次运行一个新的程序时，shell就会创建一个新的进程，然后再这个新进程的上下文中运行这个程序。应用程序也是如此，创建新进程，并且再新进程的上下文中运行自己的代码和其他应用程序。不过我们只需要关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流：提供一个假象，让我们认为程序独占处理器</li>
<li>一个私有的地址空间：提供一个假象，让我们以为程序独占内存系统</li>
</ul>
<h2 id="逻辑控制流">逻辑控制流</h2>
<p>通常系统中同时有很多程序在进行，进程可以向程序提供一个假象，自以为独占处理器与内存。但实际上并非如此。</p>
<p>我们将一个程序的顺序执行的PC值的序列称为<strong>逻辑控制流</strong>。将处理器执行的PC值的序列称为物理控制流。那么，在处理器的视角中控制流的转移实际上是这样的：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/tfipN5LPgykZrzO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>进程实际上是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。再次运行这个进程时，由于进程的上下文信息不变，所以运行在这些进程之一的上下文中的程序，它自认为是始终独占处理器的。</p>
<h2 id="并发流">并发流</h2>
<p>如果一个逻辑流得执行在时间上和另一个流重叠，称为<strong>并发流</strong>，这两个流称为并发的运行。多个流并发的执行的一般现象称为并发。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>。一个进程执行它的控制流的一部分的每一时间段就叫做<strong>时间片</strong>。因此多任务也叫时间分片。例如上图的进程A就是由两个时间片组成的。</p>
<p>这里我们还要提到一下并行和并发的区别。并行是并发的一个真子集，只不过并行是并发的运行在不同的处理器核或计算机上的。现代计算机的并行能力，是基于计算机数或处理器核数上的，单一的处理器核无法实现并行。这一点要加以区分。</p>
<h2 id="私有地址空间">私有地址空间</h2>
<p>进程也为每个程序提供一个假象，好像它独占了系统地址空间。这是因为进程为每个程序提供了自己的私有地址空间（进程地址空间）。一般而言，和这个空间中某个地址相关联的内存字节，是不能被其他进程读或写的。这个意义上来说，这个地址空间是私有的。</p>
<p>尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/mxfuyZFswWo1kbQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>地址空间的底部是留给用户程序的，地址空间的顶部总是留给内核。这里需要注意，代码段总是从地址<code>0x0040000</code>开始的。这个进程的地址空间是进程上下文的一部分。</p>
<h2 id="用户模式和内核模式">用户模式和内核模式</h2>
<p>为了进一步提供进程的抽象能力，操作系统需要一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通过控制某个控制寄存器中的一个模式位来提供这种功能，这个寄存器会描述当前的进程所享有的特权。当设置了模式位时，进程就运行在内核模式下。在内核模式下的进程可以执行指令集中的所有指令，访问系统中的任何内存地址。</p>
<p>没有设置模式位时，在用户模式下的进程，不允许执行特权指令，比如停止处理器，改变模式位，发起IO操作…….。也不允许进程直接引用地址空间中内核区的代码和数据。否则会引起故障保护，用户程序只能通过系统调用接口间接的访问内核的代码和数据。</p>
<p>初始时，应用程序代码的进程是在用户模式中的，当发生异常时。控制传递到异常处理程序，处理器从用户模式切换到内核模式。处理程序在内核模式中运行，当它返回到应用程序时，处理器将内核模式切换回用户模式</p>
<p>当然除此之外，Linux提供了一系列的机制可以让用户进程访问内核的数据结构的内容。在<code>/proc</code>下我们可以访问进程的属性还有一般的系统属性。<code>/sys</code>中则可以查看关于系统总线和设备的底层信息…….</p>
<h2 id="上下文切换">上下文切换</h2>
<p>操作系统内核通过<strong>上下文切换</strong>的机制来实现多任务。这个机制是基于底层的异常机制之上的。</p>
<p>内核为每个进程维护一个上下文。上下文就是内核重新启动一个进程所需要的状态。它由一系列的对象的值组成。这些对象有通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和一系列内核数据结构（例如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表……）组成的。</p>
<p>在进程执行的某些时刻，内核可以挂起当前进程转而执行恢复执行其他被挂起的进程。这个决策被称为<strong>调度</strong>，由内核中的调度器处理。当内核选择一个新的进程时，我们就称内核调度了这个进程。内核调度了一个新的进程后，就抢占当前进程。使用上下文切换的机制来控制转移新的进程。</p>
<p>上下文切换主要分为三个过程：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被挂起的进程的上下文</li>
<li>将控制传递给新恢复的进程</li>
</ul>
<p>了解了上下文切换，我们再来看看上下文切换的场景：</p>
<ul>
<li>执行系统调用sleep</li>
<li>系统调用因为等待某个事件而阻塞时</li>
<li>中断发生（有的系统会有周期性的定时中断器，以免处理器在单个进程运行太长时间）</li>
<li>……..</li>
</ul>
<p>总而言之就是尽可能安排任务，不要让处理器空转。下面这个图片就很好的体现了这个过程：</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/fE85YFu9ib1C2hK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/70-%E5%88%9D%E7%AA%A5%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/05/70-%E5%88%9D%E7%AA%A5%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">70:初窥深度学习(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-05 16:06:58" itemprop="dateCreated datePublished" datetime="2025-08-05T16:06:58+08:00">2025-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-06 00:08:24" itemprop="dateModified" datetime="2025-08-06T00:08:24+08:00">2025-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">人工智能</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近很流行这些，出于好奇，我也想知道这些技术背后的原理是什么。而且我感觉很多知识可能之后会用到，所以我打算浅浅的了解一下。最终的目标是实现一个手写数字识别的神经网络吧。试试看吧。</p>
<h1 id="神经网络简介">神经网络简介</h1>
<h2 id="基础构件神经元">基础构件：神经元</h2>
<p>神经元是神经网络的基本单元。它接受输入，对数据进行计算从而产生一个输出。比如下面的一个二元输入神经元样例：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/ryetOK7vjB2D3Y9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个神经元进行了以下操作：</p>
<ul>
<li><p>输入乘以权重w：</p>
<p>x<sub>1</sub> –&gt; x<sub>1</sub> * w<sub>1</sub> x<sub>2</sub> –&gt;
x<sub>2</sub> * w<sub>2</sub></p></li>
<li><p>加权输入与偏置b相加：</p>
<p>( x<sub>1</sub> * w<sub>1</sub>) + (x<sub>2</sub> * w<sub>2</sub>) +
b</p></li>
<li><p>最后将总和传递给激活函数：(其中f是激活函数)</p>
<p>y = f(x<sub>1</sub> * w<sub>1</sub> + x<sub>2</sub> * w<sub>2</sub> +
b)</p></li>
</ul>
<p>对于任意输入的神经元，我们的输出是：</p>
<p><span class="math display">$$
y = f\left(\sum_{i=1}^{n} w_i x_i + b\right)
$$</span></p>
<p>对于激活函数<code>f</code>我们需要额外了解到，在不引入激活函数的情况下，我们的输出和下一个输入的结果之间总是线性的关系。我们使用激活函数则可以将无界的输入转换成良好的、可以预测形式的输出。这里我们使用的激活函数是<code>sigmoid</code>函数：</p>
<p><span class="math display">$$
\begin{aligned}
f(x)=\frac{1}{1+e^{-x}}
\end{aligned}
$$</span></p>
<figure>
<img src="https://s2.loli.net/2025/08/05/kHw1mWV6jEPCUze.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><code>sigmoid</code>函数只输出（0，1）范围内的数值，它将<span
class="math inline">(−∞, +∞)</span>的数值压缩到了（0，1）.</p>
<h3 id="简单的举例">简单的举例</h3>
<p>假设我们现在有一个使用sigmoid激活函数的二元输入神经元，其<code>w=[0,1] b=4</code></p>
<p>若我们想神经元输入<code>x = [2,3]</code>，我们可以得到</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(w * x) + b = 0*2 + 1*3 + 4</span><br><span class="line">		   = 7</span><br><span class="line">y = f(w*x+b) = f(7) = 0.999</span><br></pre></td></tr></table></figure>
<p>我们向前传递输入以获取输出，这个过程我们称之为前馈(<code>feedforward</code>)</p>
<h3 id="神经元的代码实现">神经元的代码实现</h3>
<p>我们使用Python中的numpy来实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x: <span class="built_in">float</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weights, bias</span>):</span><br><span class="line">        <span class="variable language_">self</span>.weights = weights</span><br><span class="line">        <span class="variable language_">self</span>.bias = bias</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">feedforward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        total = np.dot(<span class="variable language_">self</span>.weights, inputs) + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="keyword">return</span> sigmoid(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">weights = np.array([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">bias = <span class="number">4</span></span><br><span class="line">n = Neuron(weights,bias)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(n.feedforward(x))</span><br><span class="line"><span class="comment"># 0.9990889488055994</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们的输出和我们的计算是吻合的</p>
<h2 id="将神经元组合成神经网络">将神经元组合成神经网络</h2>
<p>神经网络实际上是许多相互连接的神经元，一个简单的神经元长这样：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/1mdrhxJyzN6cCep.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个网络有两个输入组成的输入层，还有两个神经元(h<sub>1</sub>，h<sub>2</sub>)组成的隐藏层，以及一个神经元(o<sub>1</sub>)组成的输出层。其中隐藏层指的是位于输入层和输出层之间的任何层，可以有多个隐藏层。</p>
<h3 id="简单的举例前馈计算">简单的举例：前馈计算</h3>
<p>我们使用上述的网络，令每个神经元都是使用sigmoid激活函数且<code>w=[0,1] b=0</code>，用<code>h1 h2 o1</code>来表示神经元的输出，则有：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h1 = h2 = f(w*x+b)</span><br><span class="line">		=f((0*2)+(1*3)+0)</span><br><span class="line">		=f(3)</span><br><span class="line">		=0.9526</span><br><span class="line">o1 = f(w*x+b)</span><br><span class="line">	= f(0.9526)</span><br><span class="line">	= 0.7216</span><br></pre></td></tr></table></figure>
<p>此时我们的神经网络的前馈就是<code>0.7216</code>，整个过程简而言之就是，将输入信息通过网络中的神经元向前传递，最终得到输出信息，作为整个神经网络的前馈</p>
<h3 id="神经网络的代码实现">神经网络的代码实现</h3>
<p>现在我们为这个简单的神经网络实现前向传播</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        weights = np.array([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">        bias = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.h1 = Neuron(weights,bias)</span><br><span class="line">        <span class="variable language_">self</span>.h2 = Neuron(weights,bias)</span><br><span class="line">        <span class="variable language_">self</span>.o1 = Neuron(weights,bias)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">feedforword</span>(<span class="params">self,x</span>):</span><br><span class="line">        out_h1 = <span class="variable language_">self</span>.h1.feedforward(x)</span><br><span class="line">        out_h2 = <span class="variable language_">self</span>.h2.feedforward(x)</span><br><span class="line">        out_o1 = <span class="variable language_">self</span>.o1.feedforward(np.array([out_h1,out_h2]))</span><br><span class="line">        <span class="keyword">return</span> out_o1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">network = NeuralNetwork()</span><br><span class="line">x = np.array([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(network.feedforword(x))</span><br><span class="line"><span class="comment"># 0.7216325609518421</span></span><br></pre></td></tr></table></figure>
<p>和我预期的答案是吻合的</p>
<h2 id="训练神经网络">训练神经网络</h2>
<h3 id="损失">损失</h3>
<p>训练神经网络意味着，有预测的答案和实际的答案。训练的过程就是让网络预测的结果贴合真实的答案。那么首先我们就需要知道，预测的答案和真实的答案差距有多大，我们需要将它量化。</p>
<p>假设有以下测量值：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/3vRlEQd6C1OYrfb.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们用0表示男性，用1表示女性。我们要训练我们的网络，根据体重和身高预测某人的性别。我们通过对数据设置偏移，让它更容易被处理：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/riXCgwjOT9LQPsu.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>现在我们需要找到一个方法量化它的”好坏”，以训练它做的更好。这里我们使用均方误差损失(MSE)来衡量它的好坏：
<span class="math display">$$
MSE = \frac{1}{n}\sum_{i=1}^{n}(y_{true} - y_{pred})^2
$$</span> 其中：</p>
<ul>
<li>n是样本数量，这里是4</li>
<li>y代表被预测的变量，这里是性别</li>
<li>y<sub>true</sub>是变量的真实值（“正确答案”）</li>
<li>y<sub>pred</sub>是网络输出的结果，即预测值</li>
</ul>
<p>我们可以用代码实现MSE的计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mse_loss</span>(<span class="params">y_true,y_pred</span>):</span><br><span class="line">    <span class="keyword">return</span> ((y_true - y_pred)**<span class="number">2</span>).mean()</span><br></pre></td></tr></table></figure>
<h3 id="反向传播">反向传播</h3>
<p>我们现在已经量化了我们的损失，我们现在需要通过调整网络的权重和偏差从而使得预测更加准确。我们该怎么做呢?</p>
<p>我们从下面这个最简单的情况开始，一点一点反推整个训练的过程</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/rNY86vJlCkgSeuw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在这次训练中，正确答案为1，预测结果为y<sub>pred</sub>。此时有： <span
class="math display">$$
\begin{align*}
MSE = \frac{1}{1}\sum_{i=1}^{n}(1-y_{pread})^2
= (1-y_{pred})^2
\end{align*}
$$</span>
有了量化的偏差，接下来我们给网络中的每个权重和偏差都标记出来，此时我们可以写出一个多变量函数：
<span
class="math display"><em>L</em>(<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, <em>w</em><sub>3</sub>, <em>w</em><sub>4</sub>, <em>w</em><sub>5</sub>, <em>w</em><sub>6</sub>, <em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, <em>b</em><sub>3</sub>)</span>
<img src="https://s2.loli.net/2025/08/05/igJTIyfzBGuY2jm.png"
alt="image.png" /></p>
<p>假如我们调整w1，那么损失L会怎么变化呢？也就是说我们需要求出<span
class="math inline">$\frac{\partial L}{\partial
w_1}$</span>，从而进一步调整w1以减少L</p>
<p>我们可以用下列过程来求出它： <span class="math display">$$
\begin{align*}
\frac{\partial L}{\partial w_1} &amp;= \frac{\partial L}{\partial
y_{pred}}*\frac{\partial y_{pred}}{\partial w_1}
\\
\frac{\partial L}{\partial y_{pred}} &amp;= \frac{\partial
(1-y_{pred})^2}{\partial y_{pred}} = -2(1-y_{pred})
\end{align*}
$$</span> 我们想处理<span class="math inline">$\frac{\partial
y_{pred}}{\partial w_1}$</span>，需要用h1 h2 o1
来代表神经元的输出，然后得到： <span class="math display">$$
\begin{align*}
\frac{\partial y_{pred}}{\partial w_1} &amp;= \frac{\partial
y_{pred}}{\partial h_1}*\frac{\partial h_1}{\partial w_1}
\\
\\
y_{pred} &amp;= o_1 = f(w_5h_1 + w_6h_2 + b_3)
\\
\frac{\partial y_{pred}}{\partial h_1} &amp;= w_5*f'(w_5h_1 + w_6h_2 +
b_3)
\\
\\
h_1 &amp;= f(w_1x_1+w_2x_2+b_1)
\\
\frac{\partial h_1}{\partial w_1} &amp;= x_1*f'(w_1x_1+w_2x_2+b_1)
\end{align*}
$$</span> 这里我们要用到激活函数的导数，所以对其进行求导： <span
class="math display">$$
\begin{align*}
f(x)&amp;=\frac{1}{1+e^{-x}}
\\
f'(x)&amp;=\frac{e^{-x}}{(1+e^{-x})^2}=f(x)*(1-f(x))
\end{align*}
$$</span> 现在我们可以合并计算出 <span class="math display">$$
\frac{\partial L}{\partial w_1} = \frac{\partial L}{\partial
y_{pred}}*\frac{\partial y_{pred}}{\partial h_1}*\frac{\partial
h_1}{\partial w_1}
$$</span>
这个反向计算偏导数的系统被称之为<strong>反向传播</strong>。现在我们可以带入数值计算出<span
class="math inline">$\frac{\partial L}{\partial
w_1}=0.0214$</span>，我们可以根据这个值来训练我们的权重。</p>
<h3 id="训练">训练</h3>
<p>于是我们可以制定我们的训练过程了。在这里我们使用一种名为随机梯度下降的算法，它将告诉我们如何调整权重和偏差以最小化损失。它实际上就是这么个更新公式：
<span class="math display">$$
w_1 \gets w_1 - \eta*\frac{\partial L}{\partial w_1}
$$</span> 这里的<span
class="math inline"><em>η</em></span>指的是学习率，用来控制我们训练的速度和精度。我们对网络中的每个权重和偏差都这么做，我们的损失将慢慢减少，我们的网络将越来越准确。</p>
<p>我们的徐连过程将如下：</p>
<ul>
<li>从数据集中选择一个样本（随机梯度下降的原理就是一次只操作一个样本）</li>
<li>计算损失相对于权重或偏差的所有偏导数</li>
<li>使用更新方程来更新每个权重和偏差</li>
<li>重复</li>
</ul>
<h3 id="实现一个完整的神经网络">实现一个完整的神经网络</h3>
<p>现在我们可以实现一个完整的神经网络来实现这个训练过程了</p>
<p>这是我们的数据集和网络结构：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/riXCgwjOT9LQPsu.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2025/08/05/igJTIyfzBGuY2jm.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deriv_sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sigmoid(x)*(<span class="number">1</span>-sigmoid(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mse_loss</span>(<span class="params">y_true,y_pred</span>):</span><br><span class="line">    <span class="keyword">return</span> ((y_true - y_pred)**<span class="number">2</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weights, bias</span>):</span><br><span class="line">        <span class="variable language_">self</span>.weights = weights</span><br><span class="line">        <span class="variable language_">self</span>.bias = bias</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">feedforward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        total = np.dot(<span class="variable language_">self</span>.weights, inputs) + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="keyword">return</span> sigmoid(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.w1 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.w2 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.w3 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.w4 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.w5 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.w6 = np.random.normal()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.b1 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.b2 = np.random.normal()</span><br><span class="line">        <span class="variable language_">self</span>.b3 = np.random.normal()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">feedforward</span>(<span class="params">self,x</span>):</span><br><span class="line">        h1 = sigmoid(<span class="variable language_">self</span>.w1 * x[<span class="number">0</span>] + <span class="variable language_">self</span>.w2 * x[<span class="number">1</span>] + <span class="variable language_">self</span>.b1)</span><br><span class="line">        h2 = sigmoid(<span class="variable language_">self</span>.w3 * x[<span class="number">0</span>] + <span class="variable language_">self</span>.w4 * x[<span class="number">1</span>] + <span class="variable language_">self</span>.b2)</span><br><span class="line">        o1 = sigmoid(<span class="variable language_">self</span>.w5 * h1 + <span class="variable language_">self</span>.w6 * h2 + <span class="variable language_">self</span>.b3)</span><br><span class="line">        <span class="keyword">return</span> o1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self,data,all_y_trues</span>):</span><br><span class="line">        learn_rate = <span class="number">0.05</span></span><br><span class="line">        epochs = <span class="number">5000</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            <span class="keyword">for</span> x,y_true <span class="keyword">in</span> <span class="built_in">zip</span>(data,all_y_trues):</span><br><span class="line">                sum_h1 = <span class="variable language_">self</span>.w1 * x[<span class="number">0</span>] + <span class="variable language_">self</span>.w2 * x[<span class="number">1</span>] + <span class="variable language_">self</span>.b1</span><br><span class="line">                h1 = sigmoid(sum_h1)</span><br><span class="line">                sum_h2 = <span class="variable language_">self</span>.w3 * x[<span class="number">0</span>] + <span class="variable language_">self</span>.w4 * x[<span class="number">1</span>] + <span class="variable language_">self</span>.b2</span><br><span class="line">                h2 = sigmoid(sum_h2)</span><br><span class="line">                sum_o1 = <span class="variable language_">self</span>.w5 * h1 + <span class="variable language_">self</span>.w6 * h2 + <span class="variable language_">self</span>.b3</span><br><span class="line">                o1 = sigmoid(sum_o1)</span><br><span class="line">                y_pred = o1</span><br><span class="line"></span><br><span class="line">                d_L_d_ypred = -<span class="number">2</span>*(y_true-y_pred)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># o1</span></span><br><span class="line">                d_ypred_d_w5 = h1 * deriv_sigmoid(sum_o1)</span><br><span class="line">                d_ypred_d_w6 = h2 * deriv_sigmoid(sum_o1)</span><br><span class="line">                d_ypred_d_b3 = deriv_sigmoid(sum_o1)</span><br><span class="line">                d_ypred_d_h1 = <span class="variable language_">self</span>.w5 * deriv_sigmoid(sum_o1)</span><br><span class="line">                d_ypred_d_h2 = <span class="variable language_">self</span>.w6 * deriv_sigmoid(sum_o1)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># h1</span></span><br><span class="line">                d_h1_d_w1 = x[<span class="number">0</span>] * deriv_sigmoid(sum_h1)</span><br><span class="line">                d_h1_d_w2 = x[<span class="number">1</span>] * deriv_sigmoid(sum_h1)</span><br><span class="line">                d_h1_d_b1 = deriv_sigmoid(sum_h1)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># h2</span></span><br><span class="line">                d_h2_d_w3 = x[<span class="number">0</span>] * deriv_sigmoid(sum_h2)</span><br><span class="line">                d_h2_d_w4 = x[<span class="number">1</span>] * deriv_sigmoid(sum_h2)</span><br><span class="line">                d_h2_d_b2 = deriv_sigmoid(sum_h2)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># h1 train</span></span><br><span class="line">                <span class="variable language_">self</span>.w1 -= d_L_d_ypred * d_ypred_d_h1 * d_h1_d_w1 * learn_rate</span><br><span class="line">                <span class="variable language_">self</span>.w2 -= d_L_d_ypred * d_ypred_d_h1 * d_h1_d_w2 * learn_rate</span><br><span class="line">                <span class="variable language_">self</span>.b1 -= d_L_d_ypred * d_ypred_d_h1 * d_h1_d_b1 * learn_rate</span><br><span class="line"></span><br><span class="line">                <span class="comment"># h2 train</span></span><br><span class="line">                <span class="variable language_">self</span>.w3 -= learn_rate * d_L_d_ypred * d_ypred_d_h2 * d_h2_d_w3</span><br><span class="line">                <span class="variable language_">self</span>.w4 -= learn_rate * d_L_d_ypred * d_ypred_d_h2 * d_h2_d_w4</span><br><span class="line">                <span class="variable language_">self</span>.b2 -= learn_rate * d_L_d_ypred * d_ypred_d_h2 * d_h2_d_b2</span><br><span class="line"></span><br><span class="line">                <span class="comment"># o1 train</span></span><br><span class="line">                <span class="variable language_">self</span>.w5 -= learn_rate * d_L_d_ypred * d_ypred_d_w5</span><br><span class="line">                <span class="variable language_">self</span>.w6 -= learn_rate * d_L_d_ypred * d_ypred_d_w6</span><br><span class="line">                <span class="variable language_">self</span>.b3 -= learn_rate * d_L_d_ypred * d_ypred_d_b3</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                y_preds =np.apply_along_axis(<span class="variable language_">self</span>.feedforward,<span class="number">1</span>,data)</span><br><span class="line">                loss = mse_loss(all_y_trues,y_preds)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Epoch %d loss: %.3f&quot;</span> % (epoch,loss))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来源：国家体育总局《第五次国民体质监测公报》2022[^44^]</span></span><br><span class="line"><span class="comment"># cm-150 kg-50</span></span><br><span class="line">data = np.array([</span><br><span class="line">    [<span class="number">10.6</span>, <span class="number">5.7</span>],   <span class="comment"># 女 20-24 岁</span></span><br><span class="line">    [<span class="number">9.8</span>, <span class="number">6.7</span>],   <span class="comment"># 女 25-29 岁</span></span><br><span class="line">    [<span class="number">9.1</span>, <span class="number">8.0</span>],   <span class="comment"># 女 30-34 岁</span></span><br><span class="line">    [<span class="number">8.6</span>, <span class="number">9.1</span>],   <span class="comment"># 女 35-39 岁</span></span><br><span class="line">    [<span class="number">8.0</span>, <span class="number">9.7</span>],   <span class="comment"># 女 40-44 岁</span></span><br><span class="line">    [<span class="number">7.5</span>, <span class="number">10.1</span>],   <span class="comment"># 女 45-49 岁</span></span><br><span class="line">    [<span class="number">7.2</span>, <span class="number">10.8</span>],   <span class="comment"># 女 50-54 岁</span></span><br><span class="line">    [<span class="number">7.0</span>, <span class="number">10.7</span>],   <span class="comment"># 女 55-59 岁</span></span><br><span class="line">    [<span class="number">22.6</span>, <span class="number">20.4</span>],   <span class="comment"># 男 20-24 岁</span></span><br><span class="line">    [<span class="number">22.1</span>, <span class="number">22.8</span>],   <span class="comment"># 男 25-29 岁</span></span><br><span class="line">    [<span class="number">21.4</span>, <span class="number">24.3</span>],   <span class="comment"># 男 30-34 岁</span></span><br><span class="line">    [<span class="number">20.4</span>, <span class="number">24.0</span>],   <span class="comment"># 男 35-39 岁</span></span><br><span class="line">    [<span class="number">19.4</span>, <span class="number">23.2</span>],   <span class="comment"># 男 40-44 岁</span></span><br><span class="line">    [<span class="number">18.7</span>, <span class="number">22.5</span>],   <span class="comment"># 男 45-49 岁</span></span><br><span class="line">    [<span class="number">17.9</span>, <span class="number">21.6</span>],   <span class="comment"># 男 50-54 岁</span></span><br><span class="line">    [<span class="number">17.5</span>, <span class="number">21.0</span>]    <span class="comment"># 男 55-59 岁</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">all_y_trues = np.array([</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,   <span class="comment"># 8 位女性</span></span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>    <span class="comment"># 8 位男性</span></span><br><span class="line">])</span><br><span class="line">network = NeuralNetwork()</span><br><span class="line">network.train(data,all_y_trues)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(network.feedforward([<span class="number">161</span>-<span class="number">150</span>,<span class="number">65</span>-<span class="number">50</span>]))</span><br></pre></td></tr></table></figure>
<p>找了下几个热心嘉宾试了一下还是很准确滴</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/04/69-%E9%9A%8F%E4%BE%BF%E7%9A%84%E6%83%B3%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/04/69-%E9%9A%8F%E4%BE%BF%E7%9A%84%E6%83%B3%E6%B3%95/" class="post-title-link" itemprop="url">69:随便的想法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-04 23:08:48 / 修改时间：23:49:14" itemprop="dateCreated datePublished" datetime="2025-08-04T23:08:48+08:00">2025-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%9D%E8%80%83/" itemprop="url" rel="index"><span itemprop="name">思考</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>和好兄弟出去玩，谈到上大学。我觉得很遗憾，遗憾自己没能去想去的学校。他说，感觉人生就是因为有遗憾的事情所以才值得去回忆。我想想也是，我看历史书也是这样的，就是因为有遗憾的部分我才总是记得很清楚。就像是三国演义的诸葛之死，我每次想到都很难过，王者荣耀这个赛季也是三国主题。我看别人都是选的魏国吴国的阵营，我就选蜀国，我就是单纯的比较喜欢。</p>
<p>感觉人生也是小小的历史，从小到大也有很多遗憾的瞬间。某场惜败，某个街头匆匆错过的音乐，或者是未曾意识到的错误。我总是会想，要是……就好了，我每次这么想着都觉得很有趣，人生有好多可能，像是好多部电影。我有时候就是喜欢什么也不干躺在床上想这些，很多偶然记下的细节在脑子里循环播放，我想从每件事情里面都总结出什么，吸取经验教训。像历史那样，避免前人的错误，但我就是做不到。或者说是不太喜欢各种道理，我比较喜欢想到什么做什么，但是即使是这样我也有一直想做的事情。</p>
<p>我想做点有意义的事情，就是那种别人一听就能想起我的事情。不是违法犯罪那种，也不是今日头条那种。就是比较有意思的事情有价值的东西，比如牛顿定律那种，一听就能想起牛顿。或者是相对论，想起爱因斯坦。不过我就打个比方，总之就是想留下点有个人价值的事情吧。比如做个好玩的游戏，有个好玩的发明发现啥的，但我感觉还是挺难的。</p>
<p>我学东西感觉还是太慢了，技术也比较落后吧。我总是喜欢刨根问底，我现在在学的计算机在这一点上就让我好痛苦。计算机里我最讨厌的就是封装，它屏蔽了我对原理的认识；最喜欢的东西也是封装，因为把自己的归纳和设计封装起来很有成就感。导致我每次看到一个技术或者一个功能，我总是喜欢自己动手实现一下。我感觉这是一个好的品质，我看网上书上都说这样好，但我又感觉这样不好。我是不是在做没有意义的事，我这样是不是不适合当下的快节奏的社会。短短的大学四年我应该将时间和精力去浪费在这些事情上嘛。</p>
<p>什么是浪费，什么是有价值的。我的做法是正确的嘛。我只是想试试想看看，就是感觉很神奇。我平时看课外书也是这样，总喜欢看些没用的东西，好多人多我说，这些没用的知识早晚都会帮到你，我也想这样想，但我更清楚，我可能这辈子也不会用到他们。但我就是想知道，我也有时候会突然想到一些内容想要对别人说，一些好玩的科普，一些好玩的典故。但是感觉大多数人都不太感兴趣，或者有的人觉得是在炫耀。所以我就不想说了。</p>
<p>感觉这么一想都是从好功利的角度出发，因为换个角度将，这些想法都是可以被反驳的。我感觉打出来的字都是好意识流的哦，这么一看感觉人的思绪也是好凌乱的，也是很矛盾的。今天突然想随便写一些东西，因为我想暑假把我的博客数量争取破80，所以随便水一水。今天和同学聊天，我说想试试不用库写一个深度学习的模型，emm用C++吧。但是他说不太可能，我感觉还是挺可能的，我打算接下来试一试。刚好找点事情做。之后再是学下图像加密什么的，最近听学长聊天，我感觉科研好重要哦。不过我对这个也挺感兴趣的。不过我想先学掉链接之后再说。不知道怎么下手哦好烦。也不知道怎么跟导师联系，我好怕问些好蠢的问题。</p>
<p>我感觉打游戏还是挺好玩的，玩我的世界，总有要干的事情，不过最好玩的还是向懂行的展示自己的成果，很好玩。就是下矿不太好玩，火把总是不够，怪物总是到处出来。我现在还开了困难模式，所以更难玩了。我想之后把怪物猎人和艾尔登法环通关。暑假好短呀。</p>
<p>太晚了，我先不写了。躺在床上玩一会儿手机就可睡觉了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/01/68-%E9%93%BE%E6%8E%A5-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/01/68-%E9%93%BE%E6%8E%A5-4/" class="post-title-link" itemprop="url">68:链接(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-01 10:29:32" itemprop="dateCreated datePublished" datetime="2025-08-01T10:29:32+08:00">2025-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-05 15:13:02" itemprop="dateModified" datetime="2025-08-05T15:13:02+08:00">2025-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一章中的加载过程中，我们大致了解了动态链接的过程，接下来我们要进一步认知其背后的原理。</p>
<h2 id="位置无关代码">位置无关代码</h2>
<p>共享库的主要目的就是让多个正在运行的进程共享内存中相同的库代码，从而节约内存空间。可是多个进程是怎么共享同样一个副本的呢？</p>
<p>给每个共享库分配有一个事先预备的专用的地址空间，然后有要求加载器总是在这个地址加载共享库。这样虽然很简单，但是对内存空间的使用效率差。即使进程不适用这个库，这部分空间也会被分配出来。而且难以管理，每当我们又有一个新的库们就需要重新分配一篇空间。久而久之，这会导致地址空间分裂成各种各样的内存碎片</p>
<p>为了避免这个问题，现代操作系统令共享模块的代码段可以加载到内存的任何位置，而无需链接器修改。这样就可以实现无限多个进程共享一个共享模块的代码段的单一副本。这种可以加载而无需重定位的代码称为位置无关代码（PIC）。可以通过<code>-fpic</code>选项指示GNU编译系统生成PIC代码。</p>
<p>对于在前面已经链接好了的目标模块，我们并不需要特殊的处理，因为他们的相对位置已经固定。我们可以用PC相对寻址来编译这些引用。然而对于共享模块定义的外部过程和全局变量的引用，我们需要进行处理：</p>
<h3 id="pic数据引用">PIC数据引用</h3>
<p>下面我们要用到的方法是基于一个事实的，链接阶段之后，程序的代码段和数据段的距离（代码段首-&gt;数据段首）总是不变的。所以我们说代码段中任何指令和数据段中任何变量间的距离都是一个运行时的常量。与绝对内存的位置是无关的。</p>
<p>因此我们可以利用这个事实，在数据段的开始位置创建一个GOT表（全局偏移量表）。每个被目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器会为每个条目创建一个重定位记录。在加载时，动态链接器会将GOT中的每个条目包含其目标正确的绝对地址以供跳转。每个全局目标的目标模块都有自己的GOT。</p>
<p>我们以下图为例：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/haxHKIr5d8QCB6z.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们想要知道addcnt的地址，我们实际上只需要知道PC指向的地址和GOT表的起始位置，以及指定全局目标在GOT表中的索引，然后我们可以计算出<code>固定距离 = （GOT基址-下一条指令的地址）+ GOT索引*8</code>。之后我们就可以实现位置无关的数据引用了。</p>
<h3 id="pic函数调用">PIC函数调用</h3>
<p>假设一个程序调用一个共享库定义的函数。编译器不知道这个函数的运行时地址，因为共享模块可能会被加载到任意内存位置。理想的方法时为它创建一个重定位记录，然后再动态链接器加载时解析它，可这也意味着在链接之后运行前，调用模块的代码段会被修改，可是我们又需要确保代码段只是可读的。因此我们使用<strong>延迟绑定技术+位置无关</strong></p>
<p>使用延迟绑定技术，我们将函数调用的加载延迟到被调用的地方，这样可以避免长时间的加载过程。同时只有第一次过程调用的运行时开销比较大，之后的每次的调用只需要支付一次跳转指令和一个间接的地址引用。</p>
<p>通过延迟绑定实现函数调用的位置无关，是通过两个数据结构实现的：GOT 和
PLT(过程链接表)。如果一个目标模块调用定义在共享库中的任何函数，那么它都会生成自己的GOT和PLT。GOT是数据段的一部分。PLT是代码段的一部分。我们可以详细了解下他们的作用：</p>
<ul>
<li><p><strong>过程链接表(PLT)</strong></p>
<p>PLT是一个数组，其中每个条目都是一个十六字节的代码。PLT[0]是一个特殊条目，它跳转到动态链接器延迟绑定函数的入口，来修改GOT表指定符号的内容。每个被调用的库函数都有自己的PLT条目，每个条目负责调用一个具体的函数。PLT[1]调用系统启动函数(<code>__libc_start_main</code>)，它初始化执行环境，调用main函数并返回值。从PLT[2]开始条目调用用户代码调用的函数。</p></li>
<li><p><strong>全局偏移量表(GOT)</strong></p>
<p>GOT是一个数组，每个条目都是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时需要的信息。GOT[2]是动态链接器ld-linux.so的模块的入口。其余每个每个条目对应一个被调用的函数，其地址在运行时被解析。每个条目都有一个相匹配的PLT条目。且初始时每个GOT条目都指向指定PLT条目的第二条指令。</p></li>
</ul>
<p>下面我们将会演示一个延迟绑定的过程：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/z6BxaW2gw5omtPO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于第一次调用：</p>
<ul>
<li>我们会直接程序调用到addvec的PLT条目PLT[2]</li>
<li>第一条PLT指令通过间接跳转将控制传递到了第二条PLT指令（因为GOT表初始指向第二条指令）</li>
<li>然后将符号addvec的ID(0x1)压入栈中，将控制转移到PLT[0]中</li>
<li>PLT[0]将存储在GOT[1]中的动态链接信息也压入栈中，然后将控制转移到动态链接器的入口。动态链接器将根据动态链接的符号信息和调用函数的符号ID来确定此时调用函数的绝对内存地址。并重写GOT[4]的存储地址，并将控制转移到addvec</li>
</ul>
<p>后续调用：</p>
<ul>
<li>控制传递到PLT[2]</li>
<li>不过这一次通过GOT[4]的间接跳转回将控制直接转移到addvec</li>
</ul>
<h2 id="库打桩机制">库打桩机制</h2>
<p>LInux链接器支持<strong>库打桩</strong>，它允许你截获对共享库的调用，取而代之执行自己的代码。使用过打桩机制，我们就可以追踪库函数的调用次数，验证和追踪它的输入和输出值，甚至将它替换为一个完全不同的实现。这样可以为开发者提供详细的调试信息。</p>
<p>它的核心思想是：给定一个需要打桩的目标函数，创建一个包装函数，它的原型和目标函数一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数返回值传递给调用者。</p>
<p>打桩可以发生在编译时，链接时，或当前程序被加载和执行的运行时。</p>
<h3 id="编译时打桩">编译时打桩</h3>
<p>我们用下面这个程序作为例子，我们的目标时用打桩来追踪对malloc和free的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>,(<span class="type">int</span>)size,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span>* ptr)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>,ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以通过头文件中指示预处理器用对相应包装函数的调用替换对目标函数的调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -DCOMPILETIME -c mymalloc.c</span><br><span class="line">ylin@Ylin:~/Program/test$ gcc -I . -o intc int.c mymalloc.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ./intc</span><br><span class="line">malloc(32) = 0x5a54efd432a0</span><br><span class="line">free(0x5a54efd432a0)</span><br></pre></td></tr></table></figure>
<p>其中<code>-DCOMPILETIME</code>是条件编译的开关，当我们启用它时，相当于对所有编译文件<code>#define COMPILETIME</code>，这个时候我们的包装函数就是生效的，它会替换我们的目标函数，从而实现编译时的库打桩。</p>
<h3 id="链接时打桩">链接时打桩</h3>
<p>Linux的静态链接器支持使用<code>--wrap f</code>的标志来进行链接时的打桩。这个标志链接器，将对符号<code>f</code>的引用解析为<code>__wrap_f</code>，把对符号<code>__real_f</code>的引用解析为<code>f</code>。因此我们可以写出我们用于链接时打桩的包装函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mymalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* __real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span>* ptr);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __wrap_malloc(<span class="type">size_t</span> size)&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = __real_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>,size,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span>* ptr)&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>,ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们将源文件编译成可重定位的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -DLINKTIME mymalloc.c -c</span><br><span class="line">ylin@Ylin:~/Program/test$ gcc -c int.c</span><br></pre></td></tr></table></figure>
<p>然后再将其链接为可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intc int.o mymalloc.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ./intc</span><br><span class="line">malloc(32) = 0x57af4d75b2a0</span><br><span class="line">free(0x57af4d75b2a0)</span><br></pre></td></tr></table></figure>
<p>其中<code>-Wl,option1,option2,...</code>则是将option作为参数传递给静态链接器。从而实现链接时的库打桩。</p>
<h3 id="运行时库打桩">运行时库打桩</h3>
<p>编译时打桩我们需要能够访问程序的源代码，链接时打桩我们需要能够访问程序的可重定位对象文件。不过，我们可以通过一种机制实现在运行时打桩，它只需要能够访问可执行文件。这个机制的原理基于动态链接器的<code>LD_PRElOAD</code>环境变量</p>
<p>如果<code>LD_PRELOAD</code>环境变量被设置为一个共享库路径名的列表（以空格或符号分隔），那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器会先搜索<code>LD_PRELOAD</code>库，然后再搜索其他的库。基于这个机制可以实现对任意共享库的任何函数进行打桩。</p>
<p>我们重写一份对malloc和free的包装函数(我们使用dlsym来返回指向libc函数的目标函数)，并将其打包为共享库，通过修改<code>LD_PRELOAD</code>来劫持目标函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    <span class="comment">//注意这里的RTLD_NEXT是GNU拓展的功能，用于忽略当前符号查找下一个符号（在此即查找标准函数）</span></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);	</span><br><span class="line">    <span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* ptr = mallocp(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>,(<span class="type">int</span>)size,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span>* ptr) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    </span><br><span class="line">    freep = dlsym(RTLD_NEXT,<span class="string">&quot;free&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>,ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们将其编译成共享库用于接下来的调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span><br></pre></td></tr></table></figure>
<p>我们正常编译并运行主程序，会发现没有打桩行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o intc int.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ./intc</span><br></pre></td></tr></table></figure>
<p>可是我们可以通过修改动态链接的<code>LD_PRELOAD</code>实现运行时的打桩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ LD_PRELOAD=&quot;./mymalloc.so&quot; ./intc</span><br><span class="line">malloc(32) = 0x62a4031192a0</span><br><span class="line">free(0x62a4031192a0)</span><br></pre></td></tr></table></figure>
<p>不过实际上这里遇到了问题，我们修改了printf，改用了系统调用<code>write</code>从而避免printf内部实现用到malloc从而导致无限递归。这样我们实现了运行时的库打桩，我们甚至可以利用它去对任何程序的库函数进行调用打桩：</p>
<figure>
<img src="https://s2.loli.net/2025/08/05/m95F1NldBWOKcRo.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/26/67-%E9%93%BE%E6%8E%A5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/26/67-%E9%93%BE%E6%8E%A5-3/" class="post-title-link" itemprop="url">67:链接(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-26 19:10:01" itemprop="dateCreated datePublished" datetime="2025-07-26T19:10:01+08:00">2025-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-27 13:17:13" itemprop="dateModified" datetime="2025-07-27T13:17:13+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>介绍完了目标文件是怎么链接到可执行程序的，我们不妨进一步学习可执行程序是怎么被加载到内存中并运行的。以及动态链接库是怎么和程序一起被加载的。</p>
<h2 id="可执行目标文件">可执行目标文件</h2>
<p>我们已经学习了链接器是怎么将多个目标文件合并成一个可执行目标文件的。我们的C程序，从一开始的一组ASCII文本文件，被转换成了一个二进制文件。这个二进制文件包含加载程序到内存并运行它所需的所有信息。一个典型的ELF可执行文件有以下内容：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/QkOnFtTLvVGSwC3.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>和可重定位目标文件还是有较大的区别。ELF头描述文件的总体格式。它还包括程序的入口点（entryPoint），也就是当程序运行时要执行的第一条指令的地址。<code>.text .rodata .data</code>节和可重定位目标文件中的节是相似的。此外，还有一个<code>.init</code>节，这个节中定义了一个小函数，叫做<code>_init</code>，程序初始化代码时会调用它。同时，因为可执行文件是完全链接的，所以不再需要<code>rel</code>节</p>
<p>ELF可执行文件被设计的很容易加载到内存中，可执行文件的连续的片被映射到连续的内存段。程序头部表则描述了这种映射关系。我们使用<code>objdump -p</code>来查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只读代码段</span></span><br><span class="line">LOAD off    0x0000000000001000 vaddr 0x0000000000401000 paddr 0x0000000000401000 align 2**12</span><br><span class="line">     filesz 0x000000000007d80d memsz 0x000000000007d80d flags r-x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读/写数据段</span></span><br><span class="line">LOAD off    0x00000000000a4f50 vaddr 0x00000000004a5f50 paddr 0x00000000004a5f50 align 2**12</span><br><span class="line">     filesz 0x0000000000005b60 memsz 0x000000000000b2d8 flags rw-</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><strong>off：</strong>目标文件中的段的第一个节的偏移</li>
<li><strong>vaddr/paddr：</strong>虚拟地址/物理地址（物理地址在现代操作系统中无意义）</li>
<li><strong>align：</strong>指定的对齐要求，使得段能够有效率的传送到内存中</li>
<li><strong>filesz：</strong>目标文件中的段大小</li>
<li><strong>memsz：</strong>内存中的段大小</li>
<li><strong>flags：</strong>运行时的访问权限</li>
</ul>
<p>我们以读写数据段的加载为例。开始于内存地址<code>0xa4f50</code>处，总的内存大小为<code>0xb2d8</code>，于是从目标文件中偏移<code>0xa4f50</code>处开始的<code>.data</code>节中的<code>0x5b60</code>个字节初始化。该段剩下的字节对应于运行时将被初始化为0的<code>.bss</code>数据。</p>
<p>对于任何段s，链接器必须选择一个起始地址<code>vaddr</code>，使得：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vaddr mod align = off mod align</span><br></pre></td></tr></table></figure>
<p>off是段在可执行文件本身的起始位置。根据对齐要求对齐，是为了更好的优化加载的效率。会在虚拟内存中进一步学习。</p>
<h2 id="加载可执行文件">加载可执行文件</h2>
<p>当我们运行一个程序时:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br></pre></td></tr></table></figure>
<p>由于prog不是一个内置的shell命令，所以shell会将它视作一个可执行目标文件，通过调用驻留在存储器中称为<strong>加载器</strong>的操作系统代码来运行它。任何Linux程序，都可以通过调用<code>exevce</code>函数来调用加载器。</p>
<p>记载其将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序到内存并运行的过程叫<strong>加载</strong></p>
<p>为了解释加载器的运行，我们还需要认识以下每个Linux程序的内存映像：</p>
<figure>
<img src="https://s2.loli.net/2025/07/27/XVZWDh7G2uLUdCP.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>在LInux
x86_64中，代码段总是从0x400000处开始的，后面是数据段。运行时堆在数据段之后，通过调用用malloc库向上增长。堆之后的区域则是为共享库模块保留的。用户栈是从最大合法与用户地址(2<sup>48</sup>-1)开始的，向低地址处生长。栈上的地址，从2<sup>48</sup>处开始，是为内核中的代码和数据保留的。</p>
<p>不过这只是简图，实际上的内存空间分布略有不同，由于对齐有要求，段之间会有一定的间隙。而且现代编译器使用地址空间布局随机化，使得每次程序运行时这些区域的地址都会改变，但他们的相对位置是不会改变的</p>
<p>当加载器运行时，它会一个内存映像。在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据毒啊。接下来加载器跳转到程序的入口，也就是<code>_start</code>函数的地址。这个函数在系统目标问及那<code>ctrl.o</code>中定义。<code>_start</code>函数调用系统启动函数<code>__libc_start_main</code>，该函数定义在libc.so中。它负责初始化执行环境，调用用户层的main函数，处理main函数的返回值，并在需要时将控制返回给内核。</p>
<p>加载器的具体工作原理实际上涉及到多个方面：进程、虚拟内存、内存映射。我们之后会回头重新理解分析这个过程。</p>
<h2 id="动态链接共享库">动态链接共享库</h2>
<p>静态库仍然面临着几个问题：</p>
<ul>
<li><strong>需要要更新和维护：</strong>这导致一个程序员如果想更新它的程序使用的库的最新版本。那他需要重新显式的链接一遍。</li>
<li><strong>占用较多的空间资源：</strong>我们需要明确计算机中的空间资源始终是稀缺的，我们要尽可能的利用好计算机中的磁盘空间。但是静态链接则不符合这个问题。静态链接将目标模块复制到每一个使用它的目标文件，这就导致一个系统里可能有上百个这个目标模块。</li>
</ul>
<p>为了解决这个问题，我们就要引入<strong>共享库</strong>的概念。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>，由一个叫做动态链接器的程序来执行，共享库也被称为共享目标，在LInux中以<code>.so</code>表示，在Windows中以<code>.dll</code>来表示</p>
<p>我们可以尝试构建一个动态链接库并使用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o libtest.so -fpic -shared addvec.c multvec.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fpic指示编译器生成位置无关代码	-shared指示链接器创建一个共享的目标文件</span></span><br><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog main.c ./libtest.so</span><br></pre></td></tr></table></figure>
<p>共享库的共享方式和静态库不同。在任何给定的文件系统中，对于一个库只有一个<code>.so</code>文件，所有引用这个库的可执行程序，共享这个文件中的数据和代码。在内存中，一个共享库的.text节的副本，可以被不同的正在要运行的进程共享。我们会在之后详细的研究这个过程。动态链接的过程如下:</p>
<figure>
<img src="https://s2.loli.net/2025/07/27/pvoukltrQNM4agO.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>当加载器加载和运行可执行文件prog时，加载器注意到prog中包含一个<code>.interp</code>节，这一节包含动态链接器的路径名，动态链接器本身就是有一个共享目标（ld-linux.so）。加载器不会直接将控制传递给应用程序，而是加载和运行这个动态链接器。然后动态链接器通过执行下面的重定位完成链接任务：</p>
<ul>
<li>重定位<code>libc.so</code>的文本和数据到某个内存段</li>
<li>重定位<code>libtest.so</code>的文本和数据到另一个内存段</li>
<li>重定位prog中所有堆由<code>libc.so</code>和<code>libtest.so</code>定义的符号的引用</li>
</ul>
<p>最后动态链接器将控制传递给应用程序。此时共享库的位置就固定了，在程序执行的过程中不再改变。</p>
<h2 id="从应用程序中加载和链接共享库">从应用程序中加载和链接共享库</h2>
<p>正常情况下，我们的动态链接是在程序加载之后，执行之前进行的。可是在一些特殊的情况下，我们需要在运行的过程中（比如热更新、插件拓展…）动态链接共享库。此时我们可以用到LInux系统为动态链接器提供的接口——允许应用程序在运行是加载和链接共享库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfnc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flag)</span>;	</span><br><span class="line"><span class="comment">// 成功则返回指向句柄的指针，失败则返回NULL</span></span><br><span class="line"><span class="comment">// dlopen函数用来将共享库映射到内存，如果在编译时设置了 -rdynamic 那么当前可执行文件里的全局符号也可以被共享库使用。此外，RTLD_GLOBAL 设置可以让此次打开的库里的符号能被后续加载的库使用。RTLD_NOW和RTLD_LAZY分别时立即解析和延迟解析。他们可以通过|和RTLD_GLOBAL拼接</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">dlsym</span><span class="params">(<span class="type">void</span>* handle, <span class="type">char</span>* symbol)</span>;</span><br><span class="line"><span class="comment">// 若成功则返回指向符号的指针，失败则返回NULL</span></span><br><span class="line"><span class="comment">// dlsym的输入是一个指向前面已经打开了的共享库的句柄和一个symbol的名字</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span>* handle)</span>;</span><br><span class="line"><span class="comment">// 如果成功返回0，失败则返回-1</span></span><br><span class="line"><span class="comment">// 如果没有其他共享库还在使用这个共享库，就关闭它</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 如果前面的几个函数的调用失败，则为错误信息。如果调用成功，则为NULL</span></span><br><span class="line"><span class="comment">// dlerror会返回有一个字符串，它描述调用时发生的最近的错误</span></span><br></pre></td></tr></table></figure>
<p>我们可与尝试编写一个程序来在运行过程中加载我们的共享库，然后调用它的<code>addvec</code>例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">void</span>* handle;</span><br><span class="line">	<span class="type">void</span> (*addvec)(<span class="type">int</span>*,<span class="type">int</span>*,<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line">	<span class="type">char</span>* error;</span><br><span class="line"></span><br><span class="line">	handle = dlopen(<span class="string">&quot;./libtest.so&quot;</span>,RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addvec = dlsym(handle,<span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,error);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addvec(x,y,z,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d %d %d %d]&quot;</span>,z[<span class="number">0</span>],z[<span class="number">1</span>],z[<span class="number">2</span>],z[<span class="number">3</span>],z[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(dlclose(handle)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s\n&quot;</span>,dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后可以正常运行！我们简单的实现了运行过程中动态库的加载和更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/66-%E9%93%BE%E6%8E%A5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/66-%E9%93%BE%E6%8E%A5-2/" class="post-title-link" itemprop="url">66:链接(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-21 20:08:23" itemprop="dateCreated datePublished" datetime="2025-07-21T20:08:23+08:00">2025-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-26 15:04:19" itemprop="dateModified" datetime="2025-07-26T15:04:19+08:00">2025-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来我们要探讨学习一下<strong>符号解析</strong>和<strong>重定位</strong>实现的原理。</p>
<h2 id="符号解析">符号解析</h2>
<p>连接器解析符号引用，实际上就是将每个引用，和它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。当局部符号的引用和引用定义在相同模块的时候，符号解析简单明了。编译器只允许每个模块中每个局部符号只有一个定义，因此编译器要确保它们又唯一的名字。</p>
<p>不过，对于全局符号的引用解析就十分难以处理。当编译器遇到一个不是在当前模块定义的符号时，会假设这个符号已经被其他模块定义了，生成一个链接器符号表条目，将它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就会报错。比如我们尝试编译这个程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	foo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会毫无障碍的编译，但是链接器却无法解析对foo的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc test.c -o test -Wall -Og</span><br><span class="line">/usr/bin/ld: /tmp/ccKOmx5V.o: in function `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.c:(.text+0xe): undefined reference to `foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因此对于全局符号的处理比较困难，而且可能会出现多个目标文件定义相同名字的全局符号。此时，链接器要么选出一个定义抛弃其他定义，要么就给出一个错误。</p>
<h3
id="链接器如何解析多重定义的全局符号">链接器如何解析多重定义的全局符号</h3>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有的是局部的（只对本地模块可见），有的是全局的（对其他模块也可见）。但是如果多个模块的定义了同名的全局符号，Linux编译系统会怎么做？</p>
<p>在编译时，编译器向汇编器输出每个全局符号，或是强或是弱，而汇编器把这个信息隐含地编码在可重定位的目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>
<p>Linux链接器会根据以下规则来处理多重定义的符号名：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li>
</ul>
<p>我们可以看下各个规则的具体表现：</p>
<ul>
<li><strong>规则一</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">/usr/bin/ld: /tmp/ccYSd6rb.o: in function `main&#x27;:</span><br><span class="line">2.c:(.text+0x0): multiple definition of `main&#x27;; /tmp/ccogxBxO.o:1.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>这是因为强符号<code>main</code>被定义了多次，造成了冲突。下面也是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">514</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">/usr/bin/ld: /tmp/cc9GFQfr.o:(.data+0x0): multiple definition of `x&#x27;; /tmp/ccljmBRr.o:(.data+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>这里是因为被初始化的全局变量（强符号）<code>x</code>出现了多次，造成冲突。</p>
<ul>
<li><strong>规则二</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">114</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">514</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br><span class="line">514</span><br></pre></td></tr></table></figure>
<p>这里虽然没有造成冲突，但是可以看到另一个模块对x的使用，修改了它的值。</p>
<ul>
<li><strong>规则三</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">114</span>;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.c</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    x = <span class="number">514</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -o prog 1.c 2.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ./prog</span><br><span class="line">514</span><br></pre></td></tr></table></figure>
<p>结果和上面基本一致，但是我们并不知道最终使用了哪个符号，因为它们都是弱符号，是随机的。</p>
<p>当然现代的编译器为了避免多重定义的全局符号给我们带来的错误，往往在编译时，会开启<code>GCC-fno-common</code>选项，以保证遇到多重定义的全局符号时，会发生错误，无法通过链接。</p>
<p>在上一篇中我们提到了编译器会按规则将符号分配到<code>COMMON</code>或<code>.bss</code>，但是我们并不清楚为什么要这样做。现在我们知道了，在编译器翻译一个模块时，对于一个弱全局符号，它并不知道其他模块是否也定义了相同的符号。如果是的话，它无法预测链接器会使用多重定义中的哪一个，所以编译器将它这个弱全局符号放入COMMON中，交给链接器来决定。如果这个符号被初始化为0的话，那么它就是一个强符号，编译器就可以直接将它分配为<code>.bss</code>。相似的，对于静态变量(不用考虑多重定义)，也是如此放入<code>.bss</code>或<code>.data</code>。</p>
<h3 id="与静态库链接">与静态库链接</h3>
<p>到目前为止，我们都是假设链接器会读取一组可重定位目标文件，并将其链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都支持一种机制——把所有相关的目标模块打包成为一个单独的文件，被称为<strong>静态库</strong>。当链接器要构造一个输出的可执行文件时，它只会复制静态库中被程序引用的目标模块。这么做有以下好处：</p>
<ul>
<li>如果将模块合并到一个可重定位目标文件中，会导致程序每次链接都会包含一份完整的标准库。其中大部分的模块并不会被使用，这导致程序占用的磁盘空间会更大。</li>
<li>如果将标准函数内联至编译器，这虽然很便捷。但是会导致编译器开发的难度更大。且每次标准库的更新都需要修改编译器</li>
<li>如果为每个标准函数都创建一个独立的可重定位文件，将他们放在一个目录下。这会导致链接时需要大量的显式链接合适模块到可执行文件中。</li>
</ul>
<p>所以链接库的概念被提出来。相关的函数可以被编译为独立的目标模块然后封装在一个单独的静态库文件。然后应用程序可以在命令行中指定单独的文件名字来使用这些在库中定义的函数。</p>
<p>在链接时，链接器将只复制被程序引用的模块，这就减少了可执行文件在磁盘和内存中的大小。且减少了程序员对库文件引用次数。</p>
<p>在Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件时一组连接起来的可重定位目标文件集合，它的头部来描述每个成员目标文件的大小和为止。存档文件的后缀为<code>.a</code></p>
<p>我们可以简单的实现一下这个过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addvec.c</span></span><br><span class="line"><span class="type">int</span> addcnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span>*x,<span class="type">int</span>*y,<span class="type">int</span>*z,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    addcnt++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//multvec.c</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span>*x,<span class="type">int</span>*y,<span class="type">int</span>*z,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    multvec++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        z[i] = x[i]*y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用这两个函数创建一个静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -c addvec.c multvec.c</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">addvec.c  addvec.o  multvec.c  multvec.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ar rcs libtest.a addvec.o multvec.o</span><br></pre></td></tr></table></figure>
<p>然后我们可以利用这个静态库来编写我们的程序，来验证是否只调用了我们需要的目标模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span>	<span class="comment">//包含两个函数的原型</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> y[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> z[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        multvec(x,y,z,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d %d %d]&quot;</span>,z[<span class="number">0</span>],z[<span class="number">1</span>],z[<span class="number">2</span>],z[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc -static -o prog main.o -L . -ltest</code>编译（其中<code>-static</code>是静态链接，<code>-L</code>指定静态库的查询目录，<code>-ltest</code>是<code>./libtest.a</code>的缩写），我们使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ objdump -d prog | grep &quot;addvec&quot;</span><br></pre></td></tr></table></figure>
<p>发现程序中并没有<code>addvec目标模块</code>，静态库的链接很好的完成了工作。整个过程我们可以用这个图来大致的表现。</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/iWRXFasmOHUq76P.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3
id="链接器如何使用静态库来解析引用">链接器如何使用静态库来解析引用</h3>
<p>解释一下静态库使用的原理和可能遇到的一些问题。</p>
<p>Linux链接器在解析外部引用的时候，是从左往右按照编译器驱动程序命令行上的顺序来扫描，可重定位目标文件和存档文件（驱动程序会自动将源程序文件翻译成可重定位目标文件）。在扫描中，链接器会维护一个可重定位目标文件中的集合E(该集合文件中的目标文件会被链接成可执行文件)，一个未解析的符号集合U（引用了但是尚未定义的符号），一个在前面的输入文件中已定义的符号集合D。初始时，E、U、D均为空：</p>
<ul>
<li>对于命令行上的每个输入文件<code>f</code>，链接器会判断它的类型，是目标文件还是存档文件。如果是目标文件，则将其放入E中，然后修改U和D来反映<code>f</code>中符号定义和引用，并继续下一个输入文件。</li>
<li>如果<code>f</code>是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且修改U和D来反映m的符号定义和引用。对存档文件中的每一个程序进行这个尝试，知道U和D都不再变化。此时不包含在E中的目标文件被丢弃。开始处理下一个输入文件。</li>
<li>如果链接器处理完所有的输入文件之后，U是非空的，链接器就会输出一个错误并停止。反之，则合并重定位E中的目标文件，构建输出的可执行文件。</li>
</ul>
<p>不过因此，命令行上的库和目标文件的顺序也很重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不会被解析，链接会失败。对于存档文件之间的顺序也是如此。如果一个库a中的引用在另一个库b中被定义，那么要先a后b。反之，如果库直接都是相互独立的，就可以不在乎输入顺序。</p>
<h2 id="重定位">重定位</h2>
<p>当链接器完成了符号解析，代码中的每个符号引用和它的符号定义（即目标模块中的符号表条目）就会被关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以重定位操作了，在这个步骤中，将合并输入模块，并为每个符号分配运行时的地址。</p>
<ul>
<li><p><strong>重定位节和符号定义:</strong></p>
<p>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给每个节的每个符号。当这一步完成时。程序中的每条指令和全局变量都有唯一的运行时内存地址。</p></li>
<li><p><strong>重定位节中的符号引用：</strong></p>
<p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时的地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构，我们接下来将会描述这种数据结构。</p></li>
</ul>
<h3 id="重定位条目">重定位条目</h3>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码在运行时会被存放在内存中的哪个位置。也不知道模块引用的外部定义的函数或全局变量的位置在哪里。所以，当汇编器遇到最终位置未知的目标引用，他就会生成一个重定位条目（用来为链接器修正未知提供“导航”），用来告诉链接器，在合并目标模块时如何修改这个引用。代码的重定位条目存放在<code>.rel.text</code>，数据的重定位条目存放在<code>.rel.data</code></p>
<p>下面是一个典型的重定位条目格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,</span><br><span class="line">    	symbol:<span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> addend;</span><br><span class="line">&#125;Elf64_Rela;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>offset：</strong>需要被修改的引用的节偏移</li>
<li><strong>type：</strong>如何修改新的引用</li>
<li><strong>symbol：</strong>被修改的引用应该指向的符号</li>
<li><strong>addend：</strong>一个有符号常数，个别类型的重定位需要使用它对被修改引用的值做偏移调整</li>
</ul>
<p>ELF定义了32中不同的重定位类型，但是我们需要考虑两种最常见的类型：</p>
<ul>
<li><p><strong>R_X86_64_PC32：</strong></p>
<p>重定位一个使用32位PC相对地址的引用。一个PC相对地址就是据PC当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，他就将在指令中编码的32位值加上当前的PC值，得到<strong>有效地址</strong>，PC值通常是下一条指令在内存中的地址</p></li>
<li><p><strong>R_X86_64_32:</strong></p>
<p>重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址</p></li>
</ul>
<h3 id="重定位符号引用">重定位符号引用</h3>
<p>根据重定位算法，来分析一下重定位的过程。下面展示重定位算法的伪代码，为了方便表示，假设每个节s是一个字节数组，每个重定位条目r都是一个类型为Elf64_Rela的结构。用<code>ADDR()</code>来获取对应的运行时的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (section:s)&#123;</span><br><span class="line">    <span class="keyword">for</span> (relocation_entry:r)&#123;</span><br><span class="line">        refptr = s + r.offset;	<span class="comment">//重定位编码的地址</span></span><br><span class="line">        <span class="comment">//相对PC地址引用</span></span><br><span class="line">        <span class="keyword">if</span>(r.type == R_X86_64_PC32)&#123;</span><br><span class="line">            refaddr = <span class="built_in">ADDR</span>(s) + r.offset;	<span class="comment">//运行时的待重定位地址</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(<span class="built_in">ADDR</span>(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//绝对PC地址引用        </span></span><br><span class="line">        <span class="keyword">if</span>(r.type == R_X86_64_32)</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(<span class="built_in">ADDR</span>(r.symbol) + r.addend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下面这个反汇编代码为例，我们来分析一下链接器是怎么重定位这些引用的：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/i61CN8W5OpJQLR4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h4 id="重定位pc相对引用">重定位PC相对引用</h4>
<p>第6行，call开始于节偏移值为<code>0xe</code>的地方，包括1字节的操作码<code>0xe8</code>，还有四个字节的占位符。其中sum的重定位条目r为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = <span class="built_in">sum</span></span><br><span class="line">r.<span class="built_in">type</span> = R_X86_64_PC32</span><br><span class="line">r.addend = -<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器修改开始于偏移量<code>0xf</code>的32位PC相对引用，在运行时它会指向sum例程。此时链接器已知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = <span class="number">0x4004d0</span></span><br><span class="line">ADDR(r.symbol) = ADDR(<span class="built_in">sum</span>) = <span class="number">0x4004e8</span></span><br></pre></td></tr></table></figure>
<p>我们重定位的过程应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">    	= <span class="number">0x4004d0</span> + <span class="number">0xf</span></span><br><span class="line">    	= <span class="number">0x4004df</span></span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x4004e8</span> + (<span class="number">-4</span>) - <span class="number">0x4004df</span>)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x5</span>)</span><br></pre></td></tr></table></figure>
<p>最终得到<code>4004de: e8 05 00 00 00  callq 4004e8 &lt;sum&gt;</code></p>
<h4 id="重定位绝对引用">重定位绝对引用</h4>
<p>第4行，mov开始于节偏移值位<code>0x4</code>的地方，包括1字节的操作码<code>0xbf</code>，还有四个字节的arrary地址的占位符。其中array的重定位条目r为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span></span><br><span class="line">r.symbol = array</span><br><span class="line">r.<span class="built_in">type</span> = R_X86_64_32</span><br><span class="line">r.addend = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器要修改从偏移量<code>0xa</code>开始的绝对引用，这样在运行时它会指向arrary的第一个字节。此时链接器已知：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDR(r.symbol) = ADDR(array) = <span class="number">0x601018</span></span><br></pre></td></tr></table></figure>
<p>我们重定位的过程为是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend)</span><br><span class="line">     	= (<span class="type">unsigned</span>) (<span class="number">0x601018</span> + <span class="number">0</span>)</span><br><span class="line">    	= (<span class="type">unsigned</span>) (<span class="number">0x601018</span>)</span><br></pre></td></tr></table></figure>
<p>最终得到<code>4004d9: bf 18 10 60 00  mov $0x601018,%edi</code>。最终的效果如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/26/YIWXe4917imDMgn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/21/65-%E9%93%BE%E6%8E%A5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/21/65-%E9%93%BE%E6%8E%A5-1/" class="post-title-link" itemprop="url">65:链接(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-07-21 10:52:19 / 修改时间：16:39:47" itemprop="dateCreated datePublished" datetime="2025-07-21T10:52:19+08:00">2025-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">链接</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始学习新的章节——链接。我们现在要研究在gcc调用的过程中，到底有哪些过程是被我们所忽略的，在编译的过程中它们又有着什么作用呢？</p>
<h2 id="编译器驱动程序">编译器驱动程序</h2>
<p>我们以下面的这段代码为例，将以此来分析整个编译的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数编译系统都会提供一个编译驱动程序，在用户需要时调用语言处理器，编译器，汇编器，链接器。比如我们要用GNU编译系统进行编译时，我们就需要使用<code>gcc</code>编译驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -Og -o test main.c sum.c</span><br></pre></td></tr></table></figure>
<p>但是实际上省略了很多中间过程并没有让我们看到，我们可以通过加入<code>-v</code>参数来观察这个过程：</p>
<figure>
<img src="https://s2.loli.net/2025/07/21/lQcAwLsiMN4v2zm.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>红色框出来的分别时<code>ccl as ld</code>的调用，我们之后会分析这几个程序的作用。现在我们可以将从ASCIII源码到执行文件的编译驱动的过程总结一下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/21/Sdly6v84LWu1JTX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>首先预处理器cpp(预处理器实际上和编译器是集成在一起的)将ASCII源文件翻译成一个ASCII码的中间文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ cpp main.c -o main.i</span><br></pre></td></tr></table></figure>
<p>然后驱动程序运行C编译器ccl（这里我们使用gcc实现），将中间文件翻译成汇编语言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ gcc -S main.i</span><br></pre></td></tr></table></figure>
<p>接着驱动程序运行汇编器as，将main.s翻译成一个可重定位目标文件main.o:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ as main.s -o main.o</span><br></pre></td></tr></table></figure>
<p>然后对sum.c进行同样的操作，得到sum.o。然后驱动程序运行链接器程序ld（在<code>gcc -v</code>的过程中可以看到链接过程使用的是collect2，实际上是ld的封装用法），将main.o和sum.o以及一些必要的系统目标文件编译起来，创建一个可执行的目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ld -o test sum.o main.o</span><br></pre></td></tr></table></figure>
<p>最后当我们执行编译出来的<code>test</code>程序时，shell会调用一个名为加载器loader的函数，将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ./test</span><br></pre></td></tr></table></figure>
<p>不过实际上，这些中间过程是被什么略的，其中生成的中间文件会被存放在<code>\tmp</code>下，待编译结束后被清理。</p>
<h2 id="静态链接">静态链接</h2>
<p>像<code>ld</code>这样的静态连接器以一组可重定位目标文件个命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输出的可重定位目标文件由各种不同的代码和数据节<code>section</code>组成，每一节都是一个连续的字节序列。指令在一个节中，初始化了的全局变量在另一个节中，而未初始化的变量又在另一个节中…</p>
<p>为了构建一个可重定位文件，链接器要实现一下的功能：</p>
<ul>
<li><p><strong>符号解析：</strong></p>
<p>目标文件会定义和引用符号。每个符号可能对应一个全局变量、一个函数或一个静态变量（static声明的变量），符号解析则是将每个符号的引用和它的定义联系起来。</p></li>
<li><p><strong>重定位：</strong></p>
<p>编译器和汇编器会生成从地址0开始的代码和数据节。链接器通过把每个符号的定义和一个内存位置关联起来，从而重定位这些节，然后修改这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位信息条目的详细指令给，进行这些重定位操作</p></li>
</ul>
<p>之后我们会详细的分析这几个过程。实际上我们只需要清除，目标文件实际上就是字节块的集合。这些块中，有的包含程序代码，有的包含程序数据，其他的则包含引到链接器和加载器的数据结构。链接器负责将这些块连接起来，确定被连接块的运行时的位置，并且修改代码和数据块中的各种位置。</p>
<h2 id="目标文件">目标文件</h2>
<p>目标文件有三种形式：</p>
<ul>
<li><p><strong>可重定位目标文件：</strong></p>
<p>主要包含二进制代码和数据，其形式可以在链接时与其他的可重定位目标文件合并起来，创建一个可执行目标文件。</p></li>
<li><p><strong>可执行目标文件：</strong></p>
<p>包含二进制代码和数据，其形式可以直接被复制到内存中并执行。</p></li>
<li><p><strong>共享目标文件：</strong></p>
<p>一种特殊类型的可重定位目标文件，可以在加载或者运行时，被动态地加载进内存并链接。</p></li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。</p>
<p>从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存储在磁盘中的目标模块。本质上它们是一样的。</p>
<p>不同的系统有不同的目标文件格式，如：</p>
<ul>
<li>Unix ：a.out格式</li>
<li>Windows ：可移植可执行格式（PE）</li>
<li>Mac ：Mach-O格式</li>
<li>现代Linux/Unix ：可执行可链接格式（ELF）</li>
</ul>
<h2 id="可重定位目标文件">可重定位目标文件</h2>
<figure>
<img src="https://s2.loli.net/2025/07/21/SGLuOf3gCEZp4Bc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这是一个典型的ELF可重定位目标文件的格式。我们从ELF头开始说起，我们可以使用<code>readelf -h</code>来获取一个程序的ELF头信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ readelf -h test</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1040</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14016 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure>
<p>以一个16字节长的字节序列Magic开始，这个序列用于系统判断是否为ELF文件格式（字节序和位宽），ELF头的其他部分则包含了帮链接器语法分析和解释目标文件的信息。其中包括</p>
<ul>
<li>ELF头的大小 –&gt; Size of this header</li>
<li>目标文件的类型 –&gt; Type</li>
<li>机器类型 –&gt; Machine</li>
<li>节头部表的文件偏移 –&gt; Start of section headers</li>
<li>节头部表条目的大小和数量 –&gt; Number of section headers + Size of
section headers</li>
</ul>
<p>不同节的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定的条目（entry）。夹在ELF头和节头部表中间的都是节。一个典型的ELF可重定位目标文件包含以下的节：</p>
<ul>
<li><p><strong>.text</strong></p>
<p>已编译程序的机器代码</p></li>
<li><p><strong>.rodata</strong></p>
<p>只读数据(常量数据，运行期间不可更改)</p></li>
<li><p><strong>.data</strong></p>
<p>已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，不被保存在节</p></li>
<li><p><strong>.bss</strong></p>
<p>未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据任何实际的空间，仅仅是一个占位符。区分已初始化和未初始化是为了空间效率，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0</p></li>
<li><p><strong>.symtab</strong></p>
<p>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。和使用<code>-g</code>编译出的程序得到的符号表信息不同，<code>.symtab</code>中不包含局部变量的条目</p></li>
<li><p><strong>.rel.text</strong></p>
<p>重定位节。一个<code>.text</code>节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。这个时候<code>.text</code>中有哪些地址/符号需要在链接或加载时被修正的内容，就记录在<code>.rel.text</code>中。</p></li>
<li><p><strong>.rel.data</strong></p>
<p>数据的重定位节。记录<code>.data</code>中哪些变量/指针需要链接器修改地址</p></li>
<li><p><strong>.debug</strong></p>
<p>调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有在使用gcc时加上<code>-g</code>选项，才可以得到这张表</p></li>
<li><p><strong>.line</strong></p>
<p>原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有使用<code>-g</code>时得到。</p></li>
<li><p><strong>.strtab</strong></p>
<p>一个字符串表，内容包括其他节中的字符串信息。它自己不包含逻辑结构，只是被其他节按索引引用，用来存放符号名，段名，动态库名等文本。因此其他节只需要存放对应字符串的偏移索引就行了，真正的字符内容放在<code>.strtab</code>.</p></li>
</ul>
<h2 id="符号和符号表">符号和符号表</h2>
<h3 id="符号">符号</h3>
<p>每个可重定位模块m都有一个符号表，它包含m定义和引用的符号的信息。在连接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块引用的<strong>全局符号</strong>。全局符号对应于非静态的C函数和全局变量。</li>
<li>由其他模块定义并被模块m引用的全局符号，称之为<strong>外部符号</strong>，对应于在其他模块中定义的非静态C函数和全局变量</li>
<li>只被模块m定义和引用的<strong>局部符号</strong>。它们对应于带<code>static</code>属性的C函数和全局变量。这些符号在模块m中任何位置可见但是，不能被其他模块引用。</li>
</ul>
<p>链接器不关心本地局部变量。同样的<code>.symtab</code>中的符号表也不包含对应于本地非静态程序变量的任何符号。这些符号在运行时由栈管理。不被链接器考虑。</p>
<p>不过定义为带有C<code>static</code>属性的本地过程变量时不在栈中管理的（使用static属性可以隐藏模块内部的变量和函数声明，就像class中使用private，来保护变量和函数只能被本地模块使用）。相反，编译器在<code>.data</code>或<code>.bss</code>中会为每个定义分配空间，并在符号表中创建一个有唯一名字的本地连接符号。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会向汇编器输出两个不同名字的局部链接符号。比如，可以用<code>x.1</code>表示函数f中的定义，用<code>x.2</code>表示函数g中的定义。</p>
<h3 id="符号表">符号表</h3>
<p>符号表是由汇编器构造的，使用的是编译器给出的符号。ELF符号表被存放在<code>.symtab</code>中。这个符号表包含着一个<strong>条目</strong>的数组，其条目结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> name;			</span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>;		</span><br><span class="line">    	 binding:<span class="number">4</span>;		</span><br><span class="line">    <span class="type">char</span> reversed;		</span><br><span class="line">    <span class="type">short</span> section;		</span><br><span class="line">    <span class="type">long</span> value;			</span><br><span class="line">    <span class="type">long</span> size;			</span><br><span class="line">&#125;ELF64_symbol;</span><br></pre></td></tr></table></figure>
<p>它们的作用分别是：</p>
<ul>
<li><strong>name：</strong>字符串表中的字节偏移，指向符号的字符串名字</li>
<li><strong>type：</strong>表示符号的种类（数据/函数）</li>
<li><strong>binding：</strong>表示符号的可见性（本地/全局）</li>
<li><strong>reverse：</strong>暂时无用，留作数据对齐。</li>
<li><strong>section：</strong>节头部表的索引，用于定位节</li>
<li><strong>value：</strong>指定节中的偏移，相当于一个绝对运行时的地址</li>
<li><strong>size：</strong>目标的大小（字节大小）</li>
</ul>
<p>每个符号都会被分配到目标文件的某个节中。由<code>section</code>字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节，它们在节头部表中并没有条目：</p>
<ul>
<li>ABS，表示符号值是绝对的，不应该被重定位</li>
<li>UNDEF，表示符号未定义，就是在本模块中使用，但是在其他地方定义的符号。</li>
<li>COMMON，表示未被分配位置的未初始化的数据目标 &gt;
只有在可重定位目标文件中才有伪节，可执行目标文件中没有</li>
</ul>
<p>对于COMMON符号，value给出的是对齐要求，size给出的是最小的大小。</p>
<p>这么一看COMMON和<code>.bss</code>似乎差不多。现代的汇编器根据以下规则来将符号分配到COMMON和<code>.bss</code>中：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMON  未初始化的全局变量</span><br><span class="line">.bss	未初始化的静态变量，以及初始化为<span class="number">0</span>的全局变量和静态变量</span><br></pre></td></tr></table></figure></p>
<p>之后我们会详细解释这个设置的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/18/64-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/18/64-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">64:存储器层次结构与性能利用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-18 20:13:30" itemprop="dateCreated datePublished" datetime="2025-07-18T20:13:30+08:00">2025-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-21 16:43:16" itemprop="dateModified" datetime="2025-07-21T16:43:16+08:00">2025-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">存储器层次结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们学习一下现代计算机中的存储器架构，以及它的一些具体实现。我们该如何利用存储器的性能来实现对局部性的高效利用？它背后的原理又是什么呢？</p>
<h2 id="存储器存储结构">存储器存储结构</h2>
<p>不同的存储器有着不同的存储技术和存储性能，可喜的是，它们的属性很好的互相补齐各自的不足，利用这个性质，出现了一种组织存储器系统的方法，称之为存储器层次结构。</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/3uLzemwU7fWyakJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从高层往底层走，存储器的容量、成本、速度都越来越慢。所以我们以下面为基础，不断的向上层提供数据。其中我们就不得不提到存储器结构中最为关键的
<strong>缓存</strong></p>
<h3 id="缓存">缓存</h3>
<p>存储器之间的属性有着较大的差异，通常我们需要在其之间设置一个缓冲，以更好的实现数据的读取和转移。其中，<strong>高速缓存</strong>就是一种小而迅速的存储设备，它作为更大、更慢的存储器设备的数据的缓存区域。而使用高速缓存的过程我们就称之为<strong>缓存</strong>。缓存的基本原理如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/xz59LVFONkpycWg.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>对于缓存，我们还要理解它的各个状态：</p>
<h4 id="缓存命中">缓存命中</h4>
<p>当程序需要k+1层的某个数据对象d时，它首先到k层中去查找，如果找到了，则此时数据d<strong>缓存命中</strong>。</p>
<h4 id="缓存不命中">缓存不命中</h4>
<p>相反，如果k层没有找到数据d时，我们则发生<strong>缓存不命中</strong>。此时k层的缓存从第k+1层中取出包含d的块。如果此时k层的缓冲已经满了，就会覆盖其中的一个块，这个过程叫做替换/牺牲。具体替换哪个块由替换策略所决定。</p>
<h4 id="缓存不命中的状态">缓存不命中的状态：</h4>
<ul>
<li>强制不命中（冷不命中）：此时缓存为空，无论什么数据都不会命中。</li>
<li>容量不命中：当前的工作集的大小大于缓存的大小。</li>
<li>冲突不命中：有些替换策略会将符合同一规则的块指定替换到上层换从中的指定块，这种策略比较简洁容易实现。此时就可能会出现同组的块互相冲突。类似于哈希表中的哈希冲突。</li>
</ul>
<p>存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。所以在每一层中，都需要有某种形式的逻辑来管理缓存（将缓存分块，在不同层之间传送块，判定是否命中，并处理它们），不论是硬件还是软件。下面有一张表，大致的说明了各个缓存的管理实现：</p>
<figure>
<img src="https://s2.loli.net/2025/07/18/Fa1w6TYjCsQM3h9.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="高速缓存存储器">高速缓存存储器</h3>
<p>为了更好的理解存储器缓存的原理，我们需要介绍一下高速缓存存储器的组织架构。</p>
<p>计算机的地址数量通常由存储器的位数所决定，当存储器的位数为m时，计算机的内存空间就有2<sup>m</sup>个地址。而高速缓存存储器的结构如下：</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/1VcKdQSgRA7W3CT.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>一个高速缓存存储器被分作S(2<sup>s</sup>)个高速缓存组，每个高速缓存组有E个高速缓存行，每个高速缓存行中有B(2<sup>b</sup>)个数据块。我们通过对地址字段进行划分，从而实现对高速缓存的定位。</p>
<p>当我们拿到一个地址，想要尝试从高速缓存存储器中取出一个数据块时，都要经历以下过程：</p>
<ul>
<li><strong>读组索引：</strong>根据地址中的s位的数据来确定数据所在的缓存组</li>
<li><strong>标记比对：</strong>当数据行有效时，与其比较t位标记值，如果标记相同则确定数据存储行。</li>
<li><strong>读块索引：</strong>根据地址中的b位数据确定数据在缓存块中的偏移地址。</li>
<li><strong>缓存不命中：</strong>则重复上述的步骤向下取需要的数据。</li>
</ul>
<p>你可能会好奇，为什么使用中间的几位作为组索引，而不是高位呢？这是为了避免高位的一致性从而导致连续的内存空间被分配到一个组，从而引发冲突不命中，下图很好的说明了这一点：</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/63JE5yiz9P7Wlun.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>同时，根据每个组的高速缓存行的数量，也可以分成以下高速缓存存储器类型：</p>
<ul>
<li><p><strong>直接映射高速缓存</strong></p>
<p>E=1，每组高速缓存行只有一行，所以不需要再组中查找对应的缓存行，且实现起来比较简单。但是对于冲突不命中的应对上效果很差，因为每个组只能取一条数据。</p></li>
<li><p><strong>全相联高速缓存</strong></p>
<p>S = 0，E =
C/B。所有的缓存行都存储在一个组中，由于没有固定的映射关系，所以任何主存块可以存储在缓存的任何位置。灵活性很高，很好的避免了冲突的关系。但是由于结构复杂，且每次访问时，需要匹配缓存行，消耗了大量的时间，访问速度慢。</p></li>
<li><p><strong>组相联高速缓存</strong></p>
<p>相当于直接映射和全相联的中和版本。每个组有一定的缓存行。</p></li>
</ul>
<h4 id="高速缓存层次结构分析">高速缓存层次结构分析</h4>
<p>我们给出一个真实的高速缓存层次结构</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/eRbqK4Nzot6y2Gj.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>实际上高速缓存存储器不仅存储数据，同时存储着指令，只不过指令是只读的，数据则可读可写。芯片上的每个核有着自己的高速缓存，同时共享一个高速缓存和主存。在复杂的资源共享管理下，实现工作</p>
<h4 id="高速缓存参数的性能影响">高速缓存参数的性能影响</h4>
<p>定性的分析高速缓存的影响参数：</p>
<ul>
<li><p><strong>高速缓存大小</strong></p>
<p>较大的高速缓存可以提高缓存的命中率，但也意味着会造成更大的运行开销，这也是为什么越上层的存储器越小，这可以减少访问的时间。</p></li>
<li><p><strong>块大小</strong></p>
<p>大的块可以更好的利用程序中的空间局部性。但是在缓存空间给定的情况下，较大的块会导致较少的缓存内存行，会加剧数据冲突。从而导致时间局部性所受到的损耗大于空间局部性带来的好处。</p></li>
<li><p><strong>相联度</strong></p>
<p>即高速缓存行数E的选择，较高的相联度可以减少冲突不命中导致的不命中处罚，但是访问速度低，而且较大的块也会导致更严重的不命中处罚。而较低的相联度虽然访问速度快，但是也会导致更多的不命中处罚。所以需要根据不同的情况选择不同的相联度。</p>
<p>在L1中，通常使用相联度低的存储方式，因为不命中的处罚较小（数据较少）。但是对于底层的主存等区域，每次不命中的处罚很严重，所以要提高相联度，尽可能的减少不命中。</p></li>
<li><p><strong>写策略</strong></p>
<p>直写（立即将高速缓存块写入第一层的存储器中）比较容易实现，而且可以使用写缓冲区进行内存更新，但是会导致总线的流量增大。写回（尽可能的推迟更新，只有该块被替换的时候才将数据块更新到第一层的存储器中）引起的传送会更少。此外，越往底层走，传送的时间更长。所以在下层，会尽可能的使用写回。</p></li>
</ul>
<h2 id="局部性">局部性</h2>
<p>一个具有良好局部性的程序，通常会有着更好的效率。它们倾向于使用离它们较近的数据项，或是最近引用过的数据项，这被称为局部性原理。</p>
<p>局部性别分为<strong>空间局部性</strong>和<strong>时间局部性</strong>。对于一个良好的时间局部性程序，被引用过一次的内存位置会在不久后再次被引用。对于一个良好的空间局部性程序，如果一个内存位置被使用，那么它领近的内存位置也会被使用。</p>
<h3 id="对程序数据引用的局部性">对程序数据引用的局部性</h3>
<p>我们以一个简单的程序为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        sum += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于sum，由于它在每次迭代中都被使用，所以我们称它有良好的时间局部性，但是它是一个标量，所以不存在空间局部性。对于向量v，它是被顺序读取的，所以我们称它有良好的空间局部性，但是由于每个位置只访问一次，所以我们说v的时间局部性很差。</p>
<p>我们说像sumvec这样顺序访问一个向量每个元素的函数，是具有步长为1的引用模式（相对于元素的大小）。有时我们称步长为1的引用模式为顺序引用模式。一个连续向量中，每隔k个元素进行访问，就称为步长为k的引用模式，步长越长，空间局部性就越差。</p>
<h3 id="取指令的局部性">取指令的局部性</h3>
<p>程序指令存放在内存中，CPU需要取出这些指令，所以我们也可以评价一个程序关于取指令的局部性。对于循环，通常是在连续的空间中进行的，所以它有良好的空间局部性，由于它会被反复调用，所以也有着良好的时间局部性。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// clang-format off</span><br><span class="line">hotblock1:</span><br><span class="line">    Stmts; // &lt;-- 热！</span><br><span class="line">    if (/* 边界条件不成立 */ true)</span><br><span class="line">        goto hotblock2; // 经常发生！ ------+</span><br><span class="line">coldblock:                           /*   |   */</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |  跨越了大量指令，代价高昂！</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">    Stmt; // &lt;- 冷                        |</span><br><span class="line">hotblock2:                          /*    |   */</span><br><span class="line">    Stmts; // &lt;- 热！           &lt;----------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// clang-format off</span><br><span class="line">hotblock1:</span><br><span class="line">    Stmts; // &lt;-- 热！</span><br><span class="line">    if (/* 边界条件 */ false)</span><br><span class="line">        goto coldblock; // 很少发生</span><br><span class="line">hotblock2:                         /*   |  低代价！  */</span><br><span class="line">    Stmts; // &lt;- 热！  &lt;-----------------+</span><br><span class="line">coldblock:</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br><span class="line">    Stmt; // &lt;- 冷</span><br></pre></td></tr></table></figure>
<p>代码区别于程序数据的一点在于，在运行时它是不能被修改的，CPU只从内存中读取指令，并不修改它。</p>
<h3 id="编写高速缓存友好的代码">编写高速缓存友好的代码</h3>
<p>明白了高速缓存的工作原理之后，我们可以更准确的描述局部性了，局部性较好的程序通常意味着较高的命中率，不命中率较低的程序往往运行的会更快。所以编写局部性好的程序实际上是编写对高速缓存友好的程序。</p>
<p>下面就是我们用来确保代码高速缓存友好的基本方法：</p>
<ul>
<li><strong>让常见的情况运行得快</strong>，程序通常把大部分时间花在少量的核心函数上，而这些函数通常把大部分时间花在了少量的循环上，所以要把注意力击中在核心函数的循环上，忽略其他部分。</li>
<li><strong>尽量减少每个循环内部的缓存不命中数量</strong>，在其他条件相同的情况下（加载存储操作次数），不命中率低的程序通常循环运行的更快。</li>
</ul>
<p>同时还有几个重要问题：</p>
<ul>
<li>对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器中（时间局部性）</li>
<li>步长为1的顺序引用是好的，因为存储器层次结构中所有层次上的缓存都是讲数据存储为连续的块（空间局部性）</li>
</ul>
<p>我们这里以n*n矩阵相乘为例：</p>
<p>让 C = A x B，我们通常会写出以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            C[i][j] = A[i][k]*B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据i,j,k不同的循环顺序，实际上我们可以写出六个版本的矩阵乘法，但是它们是否互相等价呢？</p>
<figure>
<img src="https://s2.loli.net/2025/07/19/EgcLfyzU24imTY1.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们可以分析，对于循环的过程中，我们总是希望步长是尽可能小的。所以我们优先考虑B矩阵的数据，对于<code>B[k][j]</code>的迭代，我们希望是kj顺序的，此时是顺序执行，空间局部性良好。对于左边的<code>A[i][k]</code>，我们应该优先考虑对k的迭代，以保证步长尽可能的小，所以使用ik顺序迭代。综上所述，ikj循环才是性能最好的，其他的就不过多赘述。反向分析即可。</p>
<p>在对程序空间局部性的分析过程中，我们要考虑到缓存时是行缓存存储的，所以应该尽可能的让要使用的数据在空间上是连续接近的。同时将目光聚焦于内循环（程序中迭代次数最多的代码块）中，以获得最好的局部性。对于新引入的数据对象，我们也应该多使用它，利用好时间局部性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">223k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:29</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
