<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta property="og:type" content="website">
<meta property="og:title" content="Ylin&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ylin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/29/92-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-2/" class="post-title-link" itemprop="url">92:c4编译器回顾(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-29 12:59:29" itemprop="dateCreated datePublished" datetime="2025-10-29T12:59:29+08:00">2025-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-30 16:27:12" itemprop="dateModified" datetime="2025-10-30T16:27:12+08:00">2025-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一节中完成了对虚拟机的实现和初始化，还有指令集的定义，接下来就是对源文件的词法分析部分</p>
<h2 id="词法分析">词法分析</h2>
<h3 id="什么是词法分析">什么是词法分析</h3>
<p>源文件的内容对于我们的解释器而言，本质上就是一系列ASCII字符串，是毫无意义的，我们需要通过语法分析将其解析为简单的指令，然后再执行。可是这样一来，这就使得语法分析的部分十分庞大。所以编译器一般会对整个过程进行前后端的分离。前端负责对源文件进行预处理，将其解析为一系列标识符流，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span> * (<span class="number">4</span> - <span class="number">5</span>)</span><br><span class="line">=&gt;</span><br><span class="line">(Number, <span class="number">2</span>) Add (Number, <span class="number">3</span>) Multiply Left-Bracket (Number, <span class="number">4</span>) Subtract (Number, <span class="number">5</span>) Right-Bracket</span><br></pre></td></tr></table></figure>
<p>然后后端就可以根据直接对标识符流进行处理，就避免了中间处理过程臃肿的情况。</p>
<h3 id="词法分析和编译器">词法分析和编译器</h3>
<p>词法分析从某种意义上来讲，本质上也是一种编译器，它以源代码作为输入流，然后输出标识符流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+</span><br><span class="line">-- source code --&gt; | lexer | --&gt; token stream --&gt; | parser | --&gt; assembly</span><br><span class="line">                   +-------+                      +--------+</span><br></pre></td></tr></table></figure>
<p>直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h3 id="词法分析器的实现">词法分析器的实现</h3>
<p>这里我们就不用现有的词法分析器了，我们手动的实现这一部分。当然我们需要注意，词法分析并不是一次性的将所有的源码转换成标记流。因为在代码中的大多数操作符，和字符关键字都是和代码有上下文关系的。</p>
<p>所以实际的做法是，提供一个<code>next()</code>函数，每次调用这个函数就返回下一个标识。</p>
<h4 id="支持的标识">支持的标识</h4>
<p>我们的编辑器支持以下标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	Num = <span class="number">128</span>, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">	Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">	Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里之所以让标识符从128开始，是为了避免和前面设置的指令枚举变量发生冲突。</p>
<p>上面的运算符的枚举变量是有顺序的，实际上他们是按优先级进行排列的，之后的语法分析过程中会用到。现在我们就要进行token的匹配了。例如将<code>==</code>匹配成<code>Eq</code>，将<code>=</code>匹配成<code>Assign</code>。在下面的实现中，我们会分析这些匹配是怎么实现的。</p>
<p>当然这里还需要注意一些字符，他们自己就构成了标记，如右方括号<code>]</code>和波浪号<code>~</code>等，我们不需要对他们做额外的处理，因为他们不属于多字符的共同标记，也不参与运算（没有优先级关系）</p>
<h4 id="框架">框架</h4>
<p>我们的<code>next()</code>的主体框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *last_pos;</span><br><span class="line">    <span class="keyword">while</span>(*src)&#123;</span><br><span class="line">        ++src;</span><br><span class="line">	<span class="comment">// 具体的匹配逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用whlie来跳过我们分析过程中的遇到的空白字符和未知的符号。下面我们先把几个比较特殊的标识符进行一下处理：</p>
<h4 id="换行符号">换行符号</h4>
<p>换行符也和空格类似，只不过遇到换行符号，我们需要将当前的行号+1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(token == <span class="string">&#x27;\n&#x27;</span>) &#123;++line;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="宏定义">宏定义</h4>
<p>我们的解释器不支持宏定义所以直接跳过<code>#</code>后面部分的内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="number">0</span> || *src == <span class="string">&#x27; &#x27;</span>) &#123;++src;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标识符和符号表">标识符和符号表</h4>
<p>标识符可以理解为变量名。对于语法分析而言，我们并不关心一个变量叫什么，而是在意这个变量的标识符，我们需要从它唯一的标识符中获取这个变量的信息。</p>
<p>基于这个理由，我们让词法分析器将扫描到的标识符保存在一张表中，每当我们遇到标识符，就去表中查找，如果标识符存在就返回它的唯一标识符，不存在则创建有一个新的标识符存放在表中。</p>
<p>我们用结构体来存放标识符的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识符信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">id</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> token;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> Bclass;</span><br><span class="line">    <span class="type">int</span> Btype;</span><br><span class="line">    <span class="type">int</span> Bvalue;</span><br><span class="line">&#125; ID;</span><br></pre></td></tr></table></figure>
<p>这里解释一下各个字段的具体含义：</p>
<ul>
<li><strong>token：</strong>该标识符返回的标记，这里主要是存储变量的信息，所以标记类型注意要是<code>Id</code></li>
<li><strong>hash：</strong> 这个标识符的hash值，用于快速比较标识</li>
<li><strong>name：</strong>存放标识符的变量名</li>
<li><strong>class：</strong>
存放标识符的类型，例如全局、局部、数字等</li>
<li><strong>type：</strong>
标识符的类型，如果是个变量，可能是指针、int或者char</li>
<li><strong>value：</strong>
存放这个标识符的值，如果标识符是函数的，则存放函数地址</li>
<li><strong>BXXX：</strong>
C语言的标识符中可能是全局的也是局部的，当我们局部标识符和全局标识符冲突时，这个字段用于保存全局变量的信息。</li>
</ul>
<p>上面这些信息用于我们在语法分析部分进行解析，更加方便快捷：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> token_val;          <span class="comment">// 当前标识符的值</span></span><br><span class="line">ID *Symbols;            <span class="comment">// 符号表</span></span><br><span class="line">ID *current_id;         <span class="comment">// 当前标识符</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;z&#x27;</span> || token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;Z&#x27;</span> || (*src &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *src &lt;= <span class="string">&#x27;9&#x27;</span>) || token==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 标识符处理</span></span><br><span class="line">            last_pos = src - <span class="number">1</span>; <span class="comment">// 标识符起始位置</span></span><br><span class="line">            <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;z&#x27;</span> || *src&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;Z&#x27;</span> || *src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span> || *src==<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">                hash = hash * <span class="number">147</span> + *(src++);</span><br><span class="line">            <span class="comment">// 查找符号表</span></span><br><span class="line">            current_id = Symbols;</span><br><span class="line">            <span class="keyword">while</span>(current_id-&gt;token)&#123;</span><br><span class="line">                <span class="keyword">if</span>(current_id-&gt;hash == hash &amp;&amp; !<span class="built_in">memcmp</span>(current_id-&gt;name, last_pos, src - last_pos))&#123;</span><br><span class="line">                    token = current_id-&gt;token;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current_id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新标识符</span></span><br><span class="line">            token = current_id-&gt;token = Id;</span><br><span class="line">            current_id-&gt;hash = hash;</span><br><span class="line">            current_id-&gt;name = (<span class="type">int</span>)last_pos;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们通过以上形式实现对标识符的识别。</p>
<h4 id="数字">数字</h4>
<p>当遇到数字时我们也需要，进行对应的解析，这一部分的难点在于不同进制的识别。然后将数字转换为对应的数据并求值，我们把它的值保存在<code>token_value</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">           <span class="comment">// 数字处理</span></span><br><span class="line">           token_val = token - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(token_val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                   token_val = token_val *<span class="number">10</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(*src == <span class="string">&#x27;x&#x27;</span> || *src == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                   token = *(++src);</span><br><span class="line">                   <span class="keyword">while</span>((token&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;9&#x27;</span>) || (token&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;f&#x27;</span>) || (token&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;token&lt;=<span class="string">&#x27;F&#x27;</span>))&#123;</span><br><span class="line">                       token_val = token_val *<span class="number">16</span> + (token&amp;<span class="number">15</span>) + (token&gt;=<span class="string">&#x27;A&#x27;</span> ?<span class="number">9</span>:<span class="number">0</span>);</span><br><span class="line">                       token = *(++src);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(*src&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;*src&lt;=<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">                       token_val = token_val *<span class="number">8</span> + *(src++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           token = Num;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>在实际的分析过程中，当我们遇到字符串，我们需要将它的内容保存在<code>data</code>段中，然后返回它<code>data</code>段中的地址，之后我们对字符串的使用都指向这个地址。另一个特殊的地方在于，我们需要支持部分转义字符的实现，这里我们只对<code>\n</code>做一个支持，也支持<code>\x</code>表示字符<code>x</code>的语法。</p>
<p>在分析时，我们将单个字符<code>'a'</code>按<code>Num</code>的形式保存并返回，我们将<code>"a string"</code>按字符串的形式进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&quot;&#x27;</span>||token==<span class="string">&#x27;\&#x27;&#x27;</span>)&#123;</span><br><span class="line">          last_pos = data;</span><br><span class="line">          <span class="keyword">while</span>(*src!=token &amp;&amp; *src!=<span class="number">0</span>)&#123;</span><br><span class="line">              token_val = *src++;</span><br><span class="line">              <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">                  token_val = *src++;</span><br><span class="line">                  <span class="keyword">if</span>(token_val==<span class="string">&#x27;n&#x27;</span>) token_val = <span class="number">10</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;t&#x27;</span>) token_val = <span class="number">9</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;r&#x27;</span>) token_val = <span class="number">13</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(token_val==<span class="string">&#x27;\\&#x27;</span>) token_val = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">                  *data++ = token_val;</span><br><span class="line">          &#125;</span><br><span class="line">          src++;  <span class="comment">// 跳过结束符</span></span><br><span class="line">          <span class="keyword">if</span>(token == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">              *data++ = <span class="number">0</span>;</span><br><span class="line">              token_val = (<span class="type">int</span>)last_pos;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;token = Num;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这一部分可能比较难理解，首先就是判断这个是单字符还是多字符的字符串。然后分别做不同的处理即可。</p>
<h4 id="注释">注释</h4>
<p>在我们的C中，只支持<code>//</code>类型的注释，不支持多行<code>/**/</code>的注释方法。处理方式和前面对<code>#</code>的方式差不多，需要注意的是，这里要前瞻的观察下一位是什么<code>/</code>可能是除法，也可能是<code>//</code>注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">              <span class="keyword">while</span>(*src!=<span class="number">0</span> &amp;&amp; *src!=<span class="string">&#x27;\n&#x27;</span>) ++src;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Div; <span class="keyword">return</span>;&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们利用src比token快一个字符的特点，实现了对多个字符的观察，我们称这个概念为前瞻（lookahead）</p>
<h4 id="其他">其他</h4>
<p>其他的大多数是一些简单的操作符，我们简单的附上代码即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Eq;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Assign;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;+&#x27;</span>)&#123;++src; token = Inc;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Add;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;-&#x27;</span>)&#123;++src; token = Dec;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Sub;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ne;&#125; </span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Le;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&lt;&#x27;</span>)&#123;++src; token = Shl;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Lt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&gt;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;=&#x27;</span>)&#123;++src; token = Ge;&#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(*src==<span class="string">&#x27;&gt;&#x27;</span>)&#123;++src; token = Shr;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;token = Gt;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;|&#x27;</span>)&#123;++src; token = Lor;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = Or;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(*src==<span class="string">&#x27;&amp;&#x27;</span>)&#123;++src; token = Lan;&#125; </span><br><span class="line">          <span class="keyword">else</span> &#123;token = And;&#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">          token = Xor;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">          token = Mod;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">          token = Mul;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">          token = Brak;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">          token = Cond;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;~&#x27;</span> || token==<span class="string">&#x27;;&#x27;</span> || token==<span class="string">&#x27;&#123;&#x27;</span> || token==<span class="string">&#x27;&#125;&#x27;</span> || token==<span class="string">&#x27;(&#x27;</span> || token==<span class="string">&#x27;)&#x27;</span> || token==<span class="string">&#x27;]&#x27;</span> || token==<span class="string">&#x27;,&#x27;</span> || token==<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>基本的思想就是利用前瞻确定标记。</p>
<h4 id="关键字和内置函数">关键字和内置函数</h4>
<p>完成了上述的词法分析之后，我们需要在正式开始词法分析之前，预处理我们的关键字和内置的函数。我们将它们加入符号表，并提前为他们赋予必要的信息。</p>
<p>我们在<code>main</code>函数中对其进行初始化:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理关键字</span></span><br><span class="line">    &#123;</span><br><span class="line">        Symbols = <span class="built_in">malloc</span>(poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(Symbols, <span class="number">0</span>, poolsize);</span><br><span class="line">        src = <span class="string">&quot;char else enum if int return sizeof while &quot;</span></span><br><span class="line">              <span class="string">&quot;open read close printf malloc memset memcmp exit void main&quot;</span>;</span><br><span class="line">        i=Char;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=While)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;token = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i = OPEN;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=EXIT)&#123;</span><br><span class="line">            next();</span><br><span class="line">            current_id-&gt;value = i++;</span><br><span class="line">            current_id-&gt;<span class="class"><span class="keyword">class</span> =</span> Sys;</span><br><span class="line">            current_id-&gt;type = INT;</span><br><span class="line">        &#125;</span><br><span class="line">        next(); current_id-&gt;token = Char;</span><br><span class="line">        next(); idmain = current_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们就完成了对源代码的词法分析，程序会通过词法分析将我们的源代码转换成标记流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/28/91-c4%E7%BC%96%E8%AF%91%E5%99%A8%E5%9B%9E%E9%A1%BE-1/" class="post-title-link" itemprop="url">91:c4编译器回顾(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-28 16:37:10" itemprop="dateCreated datePublished" datetime="2025-10-28T16:37:10+08:00">2025-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-29 10:39:50" itemprop="dateModified" datetime="2025-10-29T10:39:50+08:00">2025-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/c4%E7%BC%96%E8%AF%91%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">c4编译器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们将尝试构建一个C语言的解释器，这个项目也是我C语言的大作业。现在回顾看来，当时对整个项目都是知其然不知其所以然，从现在的眼光来看，当时很多做法都是很稚嫩的。尤其是对于这个项目结构的理解也远远不足，所以打算重构一遍。</p>
<h2 id="构建流程">构建流程</h2>
<p>首先是整个编译器的构建流程，一般来讲，编译器的编写有三个步骤：</p>
<ol type="1">
<li>词法分析器，用于将文本文件转换为内部的表示结构</li>
<li>语法分析器，在词法分析得到的标记的基础之上，构建一棵语法树</li>
<li>目标代码的生成，将语法树转换成目标代码</li>
</ol>
<p>但是由于这里我们编写的是一个解释器，所以我们自定义自己的虚拟机框架和指令。我们通过语法分析词法分析之后得到的语法树，来生成使用自定义虚拟机框架的指令的目标代码。</p>
<h2 id="编译器的框架">编译器的框架</h2>
<p>仿照c4编译器的写法：</p>
<p>这里我们的解释器主要包括4个函数：</p>
<ul>
<li><code>next()</code> 用于词法分析，获取下一个标记</li>
<li><code>program()</code> 用于语法分析，分析整个C语言的程序</li>
<li><code>expression(level)</code> 用于解析一个表达式</li>
<li><code>eval()</code> 虚拟机的入口，用于执行目标代码</li>
</ul>
<p>可能在此基础之上我会做出一点自己的改动，但是总体框架还是确定的，首先是实现对要解释的文件的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件全局变量</span></span><br><span class="line"><span class="type">int</span> line;       <span class="comment">// 当前行数</span></span><br><span class="line"><span class="type">char</span> *src;      <span class="comment">// 源文件内容</span></span><br><span class="line"><span class="type">char</span> *old_src;  <span class="comment">// 源文件备份</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> poolsize = <span class="number">256</span>*<span class="number">1024</span>; <span class="comment">// 内存池大小</span></span><br><span class="line">    line = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取源文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(*argv,<span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not open %s\n&quot;</span>, *argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(src = old_src = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((i=read(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not read %s\n&quot;</span>, *argv);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        src[i] = <span class="number">0</span>; <span class="comment">// 文件结束符</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将读取到的文件内容复制到<code>src</code>内存空间中。</p>
<p>现在我们就需要开始模拟一台计算机应有的功能了，我们的指令需要运行在我们的虚拟机上。那么首先，我们就需要定义一个自己的虚拟机，一台机器必须要有以下几个部分：</p>
<ul>
<li>内存： 这是用来存放数据的主要空间，我们的代码段数据
还有函数调用时的栈段都存放在这里</li>
<li>寄存器：我们需要寄存器帮助我们实现各种命令，同时也需要程序计数器指向我们的指令</li>
<li>CPU：本来这一部分应该是一大堆电路，但是这里我们可以通过操作指针和寄存器的方式，用一系列程序，简单的模拟它</li>
</ul>
<h2 id="计算机内部实现">计算机内部实现</h2>
<h3 id="内存">内存</h3>
<p>首先是内存部分，一般情况下，内存会被分成几个段。由于我们是简单实现的理想模型，我们只需要设置几个最基本的部分就可以了：</p>
<ul>
<li>代码段： 我们分析得到的指令就被存放在这里</li>
<li>数据段： 这里用来存放我们源程序中用的数据，通常和token信息绑定</li>
<li>栈段： 我们处理函数调用将会用到它，存放栈帧和局部变量等数据</li>
</ul>
<p>现在我们就可以简单的对我们的模拟的计算机内存进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 内存布局</span></span><br><span class="line"><span class="type">int</span> *text;          <span class="comment">// 代码段</span></span><br><span class="line"><span class="type">int</span> *old_text;      <span class="comment">// 代码段备份</span></span><br><span class="line"><span class="type">int</span> *<span class="built_in">stack</span>;         <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> *data;         <span class="comment">// 数据段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(text = old_text = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for text\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">stack</span> = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for stack\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(data = <span class="built_in">malloc</span>(poolsize)))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Could not malloc %d bytes for data\n&quot;</span>, poolsize);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(text, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, poolsize);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, poolsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄存器">寄存器</h3>
<p>寄存器用来存放计算机的运行状态，我们的虚拟机中只简单的使用四个寄存器，分别是：</p>
<ul>
<li><code>PC</code>程序计数器，用于存放一个内存地址，该地址中用于存放下一条要执行的指令</li>
<li><code>SP</code>寄存器，永远指向当前的栈顶（注意这里的栈是从高地址向低地址增长的）</li>
<li><code>BP</code>基址寄存器，用于指向栈底，当我们在函数调用解析参数时需要用到它</li>
<li><code>AX</code>通用寄存器，用来存放一条指令执行后的结果</li>
</ul>
<p>我们对他们进行简单的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 寄存器</span></span><br><span class="line"><span class="type">int</span> *pc;            <span class="comment">// 程序计数器</span></span><br><span class="line"><span class="type">int</span> *bp;            <span class="comment">// 基址指针</span></span><br><span class="line"><span class="type">int</span> *sp;            <span class="comment">// 栈指针</span></span><br><span class="line"><span class="type">int</span> ax;             <span class="comment">// 通用寄存器</span></span><br><span class="line"><span class="type">int</span> cycle;          <span class="comment">// 时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 寄存器初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        bp = sp = (<span class="type">int</span>*)((<span class="type">char</span>*)<span class="built_in">stack</span> + poolsize);</span><br><span class="line">        ax = <span class="number">0</span>;</span><br><span class="line">        cycle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<p>现在我们的虚拟机已经有了基本的骨架，我们可以开始尝试实现我们我们虚拟机最基本的指令集。不过首先我们需要明确我们需要用到哪些指令。这里我们直接照搬C4的指令集就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">       LEA, IMM, JMP, CALL, JZ, JNZ, ENT, ADJ, LEV,</span><br><span class="line">       LI, LC, SI, SC, PUSH,</span><br><span class="line">       OR, XOR, AND, EQ, NE, LT, GT, LE, GE,</span><br><span class="line">       SHL, SHR, ADD, SUB, MUL, DIV, MOD,</span><br><span class="line">       OPEN, READ, CLOS, PRTF, MALC, MSET, MCMP, EXIT </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些指令顺序是有意的，带有参数的指令在前，没有参数指令的放在后面，为了方便我们之后打印调试信息。</p>
<h4 id="mov">MOV</h4>
<p><code>MOV dest,src</code>x86中最基础重要的一个公式，它将<code>SOURCE</code>中的内容放在<code>DEST</code>中。但在我们的虚拟机中只提供了一个通用寄存器<code>AX</code>，加上由于对参数类型的识别是一件复杂的事情，所以我们将<code>MOV</code>拆分成五个子操作来实现：</p>
<ul>
<li><code>IMM &lt;num&gt;</code>
将<code>num</code>放入寄存器<code>ax</code>中</li>
<li><code>LC</code>
将对应地址中的字符载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>LI</code>
将对应地址中的整数载入<code>ax</code>中，要求<code>ax</code>中存放地址</li>
<li><code>SC</code>将<code>ax</code>中的数据作为字符存放入地址中，要求栈顶存放地址</li>
<li><code>SI</code>将<code>ax</code>中的数据作为整数存放入地址中，要求栈顶存放地址</li>
</ul>
<p>这样的拆分，极大程度上的减小了指令实现的复杂度，现在我们可以开始具体的实现了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eval</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> op, *tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == IMM) &#123;ax = *pc++;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LC) &#123;ax = *(<span class="type">char</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == LI) &#123;ax = *(<span class="type">int</span>*)ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SC) &#123; *(<span class="type">char</span>*)*sp++ = ax;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == SI) &#123; *(<span class="type">int</span>*)*sp++ = ax;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里得<code>*sp++</code>实际上就是一个退栈操作，将值存储到弹出得地址中。</p>
<p>这里我之前一直没有搞懂，为什么<code>LI/LC</code>要将对应地址中的字符载入<code>ax</code>中，因为我们的默认的计算结果是存储在<code>ax</code>中的，也就是我们指令计算出的地址，可以直接被<code>LI/LC</code>所使用，这样就很高效。</p>
<h4 id="push">PUSH</h4>
<p><code>PUSH</code>的作用很简单，就是将值或者寄存器压入到栈中。在这里我们<code>PUSH</code>的作用给就是将<code>ax</code>的值压入栈中，因为我们只有这一个寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == PUSH) &#123;*--sp = ax;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jmp">JMP</h4>
<p><code>JMP &lt;addr&gt;</code>是跳转指令，无条件的将当前的<code>PC</code>寄存器设置为指定的<code>&lt;addr&gt;</code>，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JMP) &#123;pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>pc始终指向的是下一条指令，所以此时它存放的存放的是JMP指定的参数，即<code>&lt;addr&gt;</code>的值</p>
<h4 id="jzjnz">JZ/JNZ</h4>
<p>为了实现<code>if</code>语句
我们也需要条件判断相关的指令。这里我们只需要实现两个最简单的条件判断，即<code>ax==0/ax!=0</code>的情况下的跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JZ) &#123;pc = ax ? pc+<span class="number">1</span> : (<span class="type">int</span>*)*pc;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == JNZ) &#123;pc = ax ? (<span class="type">int</span>*)*pc : pc+<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子函数调用">子函数调用</h3>
<p>这个是比较重要的一部分，我很大程度上也是为了这一部分重新回头别写这个编译器。这里我们将根据子函数调用约定，用几个最简单的指令来实现这个过程，我们要引入的指令有<code>CALL ENT ADJ LEV</code>。</p>
<p>首先我们介绍<code>CALL</code>，它用于跳转到一个子函数的开始地址。程序将会跳转到地址<code>&lt;addr&gt;</code>，并将当前的位置信息保存起来，以用于函数调用后的返回。这里我们将返回的PC存放在栈中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == CALL) &#123;*--sp = (<span class="type">int</span>)(pc+<span class="number">1</span>); pc = (<span class="type">int</span>*)*pc;&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们能进入调用函数了，那么我们便需要进一步的规范我们的函数调用规则。在实际的函数调用中，我们不仅要考虑函数的地址，也要考虑如何传递参数和返回结果，这里我们将每次的返回结果保存在<code>ax</code>中，对于参数传递，我们需要遵循C语言的调用标准：</p>
<ul>
<li>由调用者将参数入栈</li>
<li>调用结束时，由调用者将参数出栈</li>
<li>参数逆序入栈（因为先进后出）</li>
</ul>
<p>我们可以看下面的这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callee</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">caller</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ret += <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会生成下面的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     1, esp       ; save stack for variable: i</span><br><span class="line">; push call arguments</span><br><span class="line">push    3</span><br><span class="line">push    2</span><br><span class="line">push    1</span><br><span class="line">; call subroutine &#x27;callee&#x27;</span><br><span class="line">call    callee</span><br><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, 12</span><br><span class="line">; use subroutine result</span><br><span class="line">add     eax, 5</span><br><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>但是我们的虚拟机难以解决其中的几个问题：</p>
<ul>
<li><code>push ebp</code> 我们的PUSH无法指定寄存器</li>
<li><code>mov ebp,esp</code> 我们的MOV也无法直接指定源和目的</li>
<li><code>add esp,12</code> 我们的ADD也无法直接实现两个操作数的加法</li>
</ul>
<p>所以我们需要额外的指令来代替这几个的功能，所以我们需要定义以下几个指令：</p>
<h4 id="ent">ENT</h4>
<p><code>ENT &lt;size&gt;</code>指的是<code>enter</code>我们用它实现<code>make new call frame</code>的操作，即保存当前的栈指针，并在栈上保留一定的空间，用来存放局部变量，汇编代码的表现形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; make new call frame</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     size, esp       ; save stack for variable</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ENT) &#123;*--sp = (<span class="type">int</span>)bp; bp = sp; sp = sp - *pc++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="adj">ADJ</h4>
<p><code>ADJ &lt;size&gt;</code>用于实现<code>remove argument from frame</code>。用于将调用子函数时压入栈中的数据清楚，之所以单独定义这个指令，是对我们ADD功能局限做出的妥协。其汇编实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; remove arguments from frame</span><br><span class="line">add     esp, size</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下形式实现它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == ADJ) &#123;sp = sp + *pc++;&#125;    <span class="comment">// add esp &lt;size&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lev">LEV</h4>
<p>本质上这个指令并不是必需的而且我们的指令集中并没有<code>POP</code>的指令，所以为了简洁的进行函数的退出操作，我们专门定义了<code>LEV</code>的封装。对应的汇编操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; restore old call frame</span><br><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">; return</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>我们用以下形式实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEV) &#123;sp = bp; bp = (<span class="type">int</span>*)sp++; pc = (<span class="type">int</span>*)*sp++;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>上述的指令解决了调用帧的问题，解决了我们函数的运行和返回的问题。现在，为了进一步的执行调用函数，我们需要想办法获取先前压入的参数。在此之前，我们首先需要了解当参数调用时，栈中的调用帧是什么样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sub_function(arg1, arg2, arg3);</span><br><span class="line"></span><br><span class="line">|    ....       | high address</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 1        |    new_bp + 4</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 2        |    new_bp + 3</span><br><span class="line">+---------------+</span><br><span class="line">| arg: 3        |    new_bp + 2</span><br><span class="line">+---------------+</span><br><span class="line">|return address |    new_bp + 1</span><br><span class="line">+---------------+</span><br><span class="line">| old BP        | &lt;- new BP</span><br><span class="line">+---------------+</span><br><span class="line">| local var 1   |    new_bp - 1</span><br><span class="line">+---------------+</span><br><span class="line">| local var 2   |    new_bp - 2</span><br><span class="line">+---------------+</span><br><span class="line">|    ....       |  low address</span><br></pre></td></tr></table></figure>
<p>我们首先将参数压入栈中，然后进行调用，调用会将返回地址压入栈中，然后保存当前的栈基址（我们将这个保存的栈帧称为<code>old_bp</code>），准备创建下一个栈帧。当前视图就是进行<code>push rbp; mov rbp,rsp;</code>之后的栈帧状态。此时如果我们想要访问函数的第一个参数，我们就需要访问<code>new_bp+4</code>地址上的内容。</p>
<p>但是这里有一个问题，我们的ADD指令无法对bp进行运算，所以我们需要设置一个新的指令，用于访问栈帧上的地址<code>LEA &lt;offset&gt;</code>。我们具体的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == LEA) &#123;ax = (<span class="type">int</span>)(bp + *pc++);&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们就完成了实现函数调用的所有指令了。</p>
<h3 id="运算符指令">运算符指令</h3>
<p>我们在C语言中支持的各种运算符号都是二元的，所以我们指令的参数也应该是由两个的，但是我们只有一个通用寄存器，这就导致我们需要将其中一个参数放在栈上，另一个参数存放在<code>ax</code>中，我们通过指令计算出来的结果也存放在ax上。</p>
<p>我们的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == OR)  ax = *sp++ | ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == XOR) ax = *sp++ ^ ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == AND) ax = *sp++ &amp; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == EQ)  ax = *sp++ == ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == NE)  ax = *sp++ != ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LT)  ax = *sp++ &lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == LE)  ax = *sp++ &lt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GT)  ax = *sp++ &gt;  ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == GE)  ax = *sp++ &gt;= ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHL) ax = *sp++ &lt;&lt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SHR) ax = *sp++ &gt;&gt; ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == ADD) ax = *sp++ + ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == SUB) ax = *sp++ - ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MUL) ax = *sp++ * ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == DIV) ax = *sp++ / ax;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == MOD) ax = *sp++ % ax;</span><br></pre></td></tr></table></figure>
<h3 id="内置命令">内置命令</h3>
<p>有很多由系统支持的函数，我们往往难以在机器上支持实现，所以这里我们简单的对函数进行封装，设置为内置的指令，用来支持一些常用的库函数调用。</p>
<p>这里我们就简单的对<code>exit open close read printf malloc memset</code>指令进行封装以确保我们的程序有基本的能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == EXIT) &#123;<span class="built_in">printf</span>(<span class="string">&quot;exit(%d)&quot;</span>, *sp); <span class="keyword">return</span> *sp;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == OPEN) &#123;ax = open((<span class="type">char</span> *)sp[<span class="number">1</span>], sp[<span class="number">0</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == CLOS) &#123;ax = close(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == READ) &#123;ax = read(sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == PRTF) &#123;tmp = sp+pc[<span class="number">1</span>]; ax = <span class="built_in">printf</span>((<span class="type">char</span>*)tmp[<span class="number">-1</span>],tmp[<span class="number">-2</span>],tmp[<span class="number">-3</span>],tmp[<span class="number">-4</span>],tmp[<span class="number">-5</span>],tmp[<span class="number">-6</span>]);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MALC) &#123;ax = (<span class="type">int</span>)<span class="built_in">malloc</span>(*sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MSET) &#123;ax = (<span class="type">int</span>)<span class="built_in">memset</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], sp[<span class="number">1</span>], *sp);&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(op == MCMP) &#123;ax = <span class="built_in">memcmp</span>((<span class="type">char</span>*)sp[<span class="number">2</span>], (<span class="type">char</span>*)sp[<span class="number">1</span>], *sp);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的参数在函数调用时是顺序入栈，所以看起来比较反直觉，结合栈是自顶向下索引的，所以我们最终可以很好的理解我们的参数调用顺序。</p>
<p>最后在加上一个错误判断，我们的虚拟机指令就完成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown instruction:%d\n&quot;</span>, op);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<p>现在我们的虚拟机指令就完成了，我们可以做一个简单的测试，来看我们的机器能否正确的运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">pc = text;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">12</span>;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">5</span>;</span><br><span class="line">text[i++] = DIV;</span><br><span class="line">text[i++] = PUSH;</span><br><span class="line">text[i++] = IMM;</span><br><span class="line">text[i++] = <span class="number">1</span>;</span><br><span class="line">text[i++] = EXIT;</span><br></pre></td></tr></table></figure>
<p>程序执行的结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/c4$ ./a.out</span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="number">2</span>)</span></span><br></pre></td></tr></table></figure>
<p>至此我们的虚拟机以及指令架构就完成了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/24/90-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/24/90-%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6-13/" class="post-title-link" itemprop="url">90:初始图形学(13)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-24 20:23:06" itemprop="dateCreated datePublished" datetime="2025-10-24T20:23:06+08:00">2025-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:30" itemprop="dateModified" datetime="2025-11-29T13:48:30+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">图形学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>自从上个学期之后，就怎么接触过图形学了。但是仔细感受下来，图形学是最让人有收获感的方向。它通过模拟真实的物理规则，通过计算模拟出真实的模拟场景，十分有趣，就是给人一种融汇贯通的感觉，学到的知识能结合在一起，我感觉这才是最有意义的地方。</p>
<p>然后进度的话是接着上一次”图形学(12)“最终的场景，在此之前，我把之前的项目代码熟悉了一下，在WSL环境上重构了一遍，感觉效率相对于原来还是快了一点。现在就正式开始吧</p>
<h2 id="运动模糊">运动模糊</h2>
<p>在真实的世界中，当我们按下快门，相机会接受一段时间内的光线信息，在此期间内，世界中的物体可能会发生移动，这样排除来的照片，我称之为运动模糊。为了真实的再现这个效果，需要对我们现有的程序进行补充：</p>
<h3 id="简介">简介</h3>
<p>我们可以在快门开启的期间随机选择一个时间点发射一条射线从而得到，这条射线上的光子信息。只要我们能够知道在那个随机时间点上，场景中每个物体的位置和姿态。我们就可以像处理静态场景一样，计算这条光线与物体的交点、着色等。这样，这条光线就能准确反映那个特定瞬间的光照情况。</p>
<p>因此光线追踪的过程只需要，在处理每条光线时，更新物体的位置，就可以是实现对物体动态的追踪了。为了实现这一点，我们需要让每条线携带时间信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time)</span><br><span class="line">        : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line">	<span class="comment">// 默认初始化时间为0</span></span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction)</span><br><span class="line">        : <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间管理">时间管理</h3>
<p>真实世界中的快门时间是由两部分决定的：</p>
<ul>
<li><strong>帧间隔</strong>：连续两帧画面之间的时间间隔</li>
<li><strong>快门开启时长：</strong>在每一帧的帧间隔中，快门实际打开、允许光线进入的时间长度（一般情况下开启时间越长，运动模糊越明显）</li>
</ul>
<p>但是这里为了简化光线追踪的实现，我们只对一帧的画面进行捕捉。当然，如果想要渲染一个完整的动画，只需要设置好适当的快门时间就可以了。如果世界是静态的，只有相机的位置在移动，那么我们的代码无需做出改变。但如果世界中的物体在进行运动，那么我们需要为<code>hittable</code>设置一种方法，使得每个物体都能感知到当前帧的时间周期，并更新他们此时的位置。</p>
<p>为了简化墨香，我们只渲染一帧，我们把时间设置为从时间t=0到t=1。我们将让相机在时间[0,1]之间随机发射光线，并更新我们的球体类。</p>
<h3 id="更新相机">更新相机</h3>
<p>我们更新相机，使其在开始和结束时间之间随机生成光线，这里我们通过相机类来对光线信息进行管理和生成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray <span class="title function_">get_ray</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> offset = sample_pixel_offset();</span><br><span class="line">    <span class="keyword">auto</span> pixel_sample = pixel_origin + (i + offset.x()) * pixel_delta_u + (j + offset.y()) * pixel_delta_v;</span><br><span class="line">    <span class="keyword">auto</span> ray_origin = (defocus_angle &gt; <span class="number">0.0</span>) ? defocus_disk_sample() : camera_origin;</span><br><span class="line">    <span class="keyword">auto</span> ray_direction = pixel_sample - ray_origin;</span><br><span class="line">    <span class="keyword">auto</span> ray_time = random_double();</span><br><span class="line">    <span class="keyword">return</span> ray(ray_origin, ray_direction, ray_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="球体运动属性">球体运动属性</h3>
<p>现在我们要让我们的世界动起来，我们需要更新球体类，使其中心在t=0到t=1的时间中，从center1线性速度的移动到center。我们将center属性修改成一个从t=0时刻指向t=1时刻的射线向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span>: <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center,<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;&#125;</span><br><span class="line">    <span class="comment">// 动态球体</span></span><br><span class="line">    <span class="built_in">sphere</span>(<span class="type">const</span> point3&amp; center1, <span class="type">const</span> point3&amp; center2, <span class="type">double</span> radius, shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">center</span>(center1,center2-center1), <span class="built_in">radius</span>(radius), <span class="built_in">mat</span>(mat) &#123;&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ray center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们需要更新<code>hit</code>方法，需要需要在更新动画中心的位置之后，也能正确的进行相交判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, interval t_range, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    point3 cur_center = center.<span class="built_in">at</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - cur_center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = std::<span class="built_in">sqrt</span>(discriminant);</span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (!t_range.<span class="built_in">contains</span>(root)) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (!t_range.<span class="built_in">contains</span>(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - cur_center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat = mat;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们只需要根据射线携带的时间信息，更新我们的球心位置，然后正常的进行计算就行了，如果<code>r.time()</code>等于0，就说明位置不变。就算变了，我们也不需要花费额外的计算开销。</p>
<h3 id="追踪光线的相交时间">追踪光线的相交时间</h3>
<p>现在光线有了时间属性，我们也需要记录每次光线和世界相交的时间信息，我们只需要简单的更新一下相交光线的信息就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br></pre></td></tr></table></figure>
<h3 id="最终效果">最终效果</h3>
<p>现在我们想世界中添加球体的运动属性，以实现最终的动态渲染效果，让我们看看怎么样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 世界场景</span></span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">-1000</span>,<span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-8</span>; a &lt; <span class="number">8</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-8</span>; b &lt; <span class="number">8</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span>*random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span>*random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>() * color::<span class="built_in">random</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">0.2</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, center2, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = color::<span class="built_in">random</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>,<span class="number">0.1</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, center2, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相机</span></span><br><span class="line">    camera cam;</span><br><span class="line">    cam.aspect_ratio = <span class="number">25.0</span> / <span class="number">16.0</span>;</span><br><span class="line">    cam.image_width = <span class="number">1250</span>;</span><br><span class="line">    cam.samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    cam.max_depth = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cam.vfov     = <span class="number">20</span>;</span><br><span class="line">    cam.lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cam.lookat   = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cam.vup      = <span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cam.defocus_angle = <span class="number">0.6</span>;</span><br><span class="line">    cam.focus_distance = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cam.<span class="built_in">render</span>(world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到较为明显的运动痕迹：</p>
<figure>
<img src="https://s2.loli.net/2025/10/27/LDBqli3PFQpcvxn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/21/89-makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/21/89-makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">89:makefile基本使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-21 16:27:29" itemprop="dateCreated datePublished" datetime="2025-10-21T16:27:29+08:00">2025-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:12" itemprop="dateModified" datetime="2025-11-29T13:48:12+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">自动构建</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="makefile教程">MAKEFILE教程</h1>
<p>之后要尝试做一些项目，在加上前一段时间接触PA，发现自己对自动构建项目一类的操作实在是一知半解，而且之后也需要要尝试自动化编译一些大型的源码，所以学习一下<code>makefile</code>的基本使用，完善一下自己对工具链的认知。这里我看的教程是廖雪峰的<code>makefile</code>入门</p>
<h2 id="makefile基础">Makefile基础</h2>
<p>在Linux中我们使用<code>make</code>命令时，他就会在当前目录下找一个名为<code>Makefile</code>的文件，并根据里面的内容进行自动化的执行。我们以下面这个需求为例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt + b.txt -&gt; m.txt</span><br><span class="line">m.txt + c.txt -&gt; x.txt</span><br></pre></td></tr></table></figure>
<p>上述逻辑我们编写makefile</p>
<h3 id="规则">规则</h3>
<p>Makefile由各种规则构成，每一条规则需要指出一个目标文件和若干个依赖文件，以及用于生成目标文件的命令，例如我们想要生成<code>m.txt</code>则规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标文件: 依赖文件1 依赖文件2 依赖文件...</span></span><br><span class="line"><span class="section">m.txt: a.txt b.txt</span></span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>其中<code>#</code>用来注释，一条规则的格式如上，<code>Tab</code>后使用命令来实现目标文件</p>
<p>现在我们就可以完整的实现上述的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">x.txt: m.txt c.txt</span></span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line"><span class="section">m.txt: a.txt b.txt</span></span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>我们可以尝试执行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile  m.txt  x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat x.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">I am c.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat m.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">ylin@Ylin:~/Program/test$</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>所以我们可以知道，实际上Makefile就是一堆规则(即你些的目标文件和依赖)，当满足规则时，就调用规则后的命令，创建出一个新的目标文件</p>
<p>把默认的规则放在第一条，其他规则的顺序makefile会自动判断依赖。<code>make</code>会把每次执行的命令输出出来，便于我们观察调试。</p>
<p>如果我们在不对任何目标文件进行修改的情况下，我们在此使用<code>make</code>就会得到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">make: &#x27;x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>会根据文件的创建和修改时间来判断是否应该更新一个目标文件，例如我们这里只修改<code>c.txt</code>，并不会触发对<code>m.txt</code>的更新，因为他的依赖文件没有发生改变：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ cat x.txt</span><br><span class="line">I am a.txt</span><br><span class="line">I am b.txt</span><br><span class="line">I am c.txt (modified)</span><br><span class="line">ylin@Ylin:~/Program/test$</span><br></pre></td></tr></table></figure>
<p><code>make</code>只会重新编译那些依赖被修改，或者是尚未完成的部分，重新编译的过程并不是每一条命令都会执行，<code>make</code>只会选择必要的部分执行，我们称这种编译为增量编译。能否正确的实现增量编译，取决于我们编写的规则。</p>
<h3 id="伪目标">伪目标</h3>
<p>为了进一步的便于自动化的构建，有时候我们会需要定义一些常用的规则。例如在我们使用<code>make</code>之后，我们自动生成了<code>m.txt</code>和<code>x.txt</code>，现在我们可以定义一个规则用于清理这些生成的文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然后我们可以通过<code>make clean</code>来调用这个规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile  m.txt  x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.txt  b.txt  c.txt  Makefile</span><br></pre></td></tr></table></figure>
<p>但是<code>make</code>这里实际上是把clean当作一个目标文件，我们使用<code>make clean</code>规则时，<code>make</code>检查到没有目标文件<code>clean</code>，于是调用命令尝试构建目标文件，但是<code>clean</code>文件不会被生成，所以我们总可以使用它。可是如果目录中有一个clean文件怎么办呢？<code>make</code>认为clean已经被构建了，就不会再使用命令。为了解决这个问题，我们希望<code>make</code>不要将clean视作文件，我们可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，clean就不再被视作一个文件，而是伪目标。一般大型项目会有<code>clean</code>，<code>install</code>一类的常用的伪目标规则，方便用户快速的构建一些任务</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>运行结果如下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ylin/Program/test</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ylin/Program/test</span><br></pre></td></tr></table></figure></p>
<p>我们发现命令<code>cd ..</code>并没有修改当前目录，导致每次输出的<code>pwd</code>都是一样的，这是因为<code>make</code>针对每条指令都会创建一个独立的shell环境，所以命令之间无法互相影响。但是我们可以用以下方法实现</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;		<span class="comment"># 使用;可以将多个命令写在一行(顺序执行,不管成功还是失败)</span></span><br></pre></td></tr></table></figure>
<p>我们查看新的执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd;</span><br><span class="line">/home/ylin/Program/test</span><br><span class="line">/home/ylin/Program</span><br></pre></td></tr></table></figure>
<p>当然也可以再<code>;</code>后加<code>\</code>便于分行阅读：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>我们需要注意，在<code>shell</code>中<code>;</code>代表无论当前命令是否生效，都会执行下一个命令。与其相反的一个执行多条命令的语法是<code>&amp;&amp;</code>，当前面的命令执行失败时，后续的命令就不会再继续执行了</p>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出执行的每一条命令，如果我们不想打印某一条命令，我们只需要在命令前面加上<code>@</code>，告诉<code>make</code>不打印该命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;no display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回值错误，就会中断执行。</p>
<p>例如我们手动构建一个错误（用<code>rm</code>删除一个不存在的文件）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;OK&#x27;</span><br></pre></td></tr></table></figure>
<p>会发生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: cannot remove &#x27;zzz.txt&#x27;: No such file or directory</span><br><span class="line">make: *** [Makefile:25: has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>但是有时候我们希望忽略错误，我们可以在特定的指令前面加上<code>-</code>用来忽略错误的命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: cannot remove &#x27;zzz.txt&#x27;: No such file or directory</span><br><span class="line">make: [Makefile:29: ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>对于执行可能出错，但是不影响逻辑的命令，可以使用<code>-</code>忽略</p>
<h2 id="编译c程序">编译C程序</h2>
<p>现在我们尝试一下编译一个简单的C语言程序，其依赖文件如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.c + hello.h -&gt; main.o</span><br><span class="line">hello.c -&gt; hello.o</span><br><span class="line">hello.o + main.o -&gt; a.out</span><br></pre></td></tr></table></figure>
<p>文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;starting main\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ending main\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以编写以下规则，用于自动构建可执行程序：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"><span class="section">hello.o: hello.c hello.h</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>同时也可以通过<code>make clean</code>来删除中间文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">a.out  hello.c  hello.h  hello.o  main.c  main.o  Makefile</span><br><span class="line">ylin@Ylin:~/Program/test$ make clean</span><br><span class="line">rm -f a.out main.o hello.o</span><br><span class="line">ylin@Ylin:~/Program/test$ ls</span><br><span class="line">hello.c  hello.h  main.c  Makefile</span><br></pre></td></tr></table></figure>
<p>我们可以看到完整的命令流程如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make clean &amp;&amp; make</span><br><span class="line"><span class="built_in">rm</span> -f a.out main.o hello.o</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o a.out main.o hello.o</span><br></pre></td></tr></table></figure>
<h3 id="隐式规则">隐式规则</h3>
<p>为了编译这个项目，我们一共编写了三条规则，现在我们尝试删除两个<code>.o</code>文件的规则，然后再编译试试：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>然后我们执行<code>make</code>，输出如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc -o a.out main.o hello.o</span><br></pre></td></tr></table></figure>
<p>然后可以发现
我们并没有制定相关的规则，可是程序还是正常的进行了编译，这是<code>make</code>中的隐式规则，因为<code>make</code>本来就是为了编译C程序设计的，所以为了避免重复的编译<code>.o</code>文件，在一开始没有找到对应的规则时，会自动的调用隐式规则。对于<code>C C++ ASM ...</code>等程序，都有内置的隐式规则，这里不展开叙述。</p>
<h2 id="使用变量">使用变量</h2>
<p>我们在编译时难免会遇到许多重复的文件名，为了方便使用，我们引入变量用来解决重复的问题。我们以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: main.o hello.o</span></span><br><span class="line">	cc -o a.out main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f a.out main.o hello.o	</span><br></pre></td></tr></table></figure>
<p>我们可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = a.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: main.o hello.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> main.o hello.o</span><br></pre></td></tr></table></figure>
<p>对于变量定义，我们使用<code>变量名 = 值</code>，变量名通常使用大写。在引用变量时通常使用<code>$(变量名)</code></p>
<p>当然，对于我们的依赖文件列表，也可以使用变量进行替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">OBJS := main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>但是对于依赖文件很多的情况下，我们可能需要一个自动化的方式，来将我们的源文件批量编译成目标文件。我们注意到每个<code>.o</code>文件都是由对应的<code>.c</code>文件编译产生的，我们可以让<code>make</code>先获取<code>.c</code>文件列表再替换生成得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line"><span class="comment"># wildcard意为通配符,即使用通配符去匹配*.c</span></span><br><span class="line"><span class="comment"># patsubst是pattern substitute的缩写,即模式替换,参数为(源模式,目标模式,文件列表)</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<h3 id="内置变量">内置变量</h3>
<p>为了方便我们使用，<code>make</code>也内置了很多的内置变量，例如我们可以用<code>$(CC)</code>替换命令<code>cc</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>这样方便我们在交叉编译时，指定编译器。诸如此类的内置变量还有很多，遇到了再学吧。</p>
<h3 id="自动变量">自动变量</h3>
<p>在<code>makefile</code>中，经常会看到<code>$@</code>、<code>$&lt;</code>之类的变量，这种变量称为自动变量，它们在一个规则中自动指向某个值。例如<code>$@</code>标识目标文件，<code>$^</code>表示所以依赖文件，所以我们也可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<h2 id="模式规则">模式规则</h2>
<p>我们前面提到隐式转换可以在必要时自动创建<code>.o</code>文件，但实际上隐式规则的命令是固定的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>我们只能修改编译器变量和编译选项变量，但没办法运行多条命令。</p>
<p>此时我们就要引入自定义模式规则，它使用<code>make</code>的匹配模式规则，如果匹配上了，就自动创建一条模式规则，我们可以把我们的<code>makefile</code>写成以下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo <span class="string">&quot;Compiling <span class="variable">$&lt;</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>当程序执行<code>a.out: hello.o main.o</code>时，发现没有<code>hello.o</code>，于是查找以<code>hello.o</code>为目标文件的规则，结果匹配到模式规则<code>*.o : *.c</code>，于是模式规则会动态的创建以下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo <span class="string">&quot;Compiling <span class="variable">$&lt;</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>我们可以尝试执行一下<code>make</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line">Compiling hello.c to hello.o</span><br><span class="line">cc -c hello.c -o hello.o</span><br><span class="line">Compiling main.c to main.o</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这样他可以比隐式的规则更灵活。但是我们现在也遇到一个问题，就是当我们修改<code>hello.h</code>头文件时，不会触发<code>main.c</code>重新编译的问题，我们之后在解决。</p>
<h2 id="自动完成依赖">自动完成依赖</h2>
<p>我们刚刚提到，在我们可以解决自动把<code>.c</code>编译成<code>.o</code>文件，但是难以解决<code>.c</code>文件对<code>.h</code>文件的依赖规则。因为要想知道<code>.h</code>的依赖关系，我们需要分析文件内容才能做到，并没有一个简单的文件名映射规则。</p>
<p>好在我们可以使用<code>gcc</code>提供的<code>-MM</code>参数，自动分析我们所需要的<code>.h</code>文件参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，我们可以利用这个功能，为每个<code>.c</code>文件都生成一个依赖项，并把它保存到<code>.d</code>(中间文件中)，再使用<code>include</code>将其导入<code>makefile</code>中，这样我们就精准的实现了<code>.c</code>文件的依赖分析。</p>
<p>我们可以更新我们的<code>makefile</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TARGET := a.out</span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line">DEPS := $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>当我们运行时，通过include会引入<code>.d</code>文件，但是一开始<code>.d</code>文件并不存在，这时会通过模式规则匹配到<code>%.d: %.c</code>。这里用了一个复杂的<code>sed</code>将<code>.d</code>文件创建了出来。我们运行<code>make</code>结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line"><span class="built_in">rm</span> -f main.d; \</span><br><span class="line">cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27;</span> &lt; main.d.tmp &gt; main.d; \</span><br><span class="line"><span class="built_in">rm</span> -f main.d.tmp</span><br><span class="line"><span class="built_in">rm</span> -f hello.d; \</span><br><span class="line">cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27;</span>&lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line"><span class="built_in">rm</span> -f hello.d.tmp</span><br><span class="line">cc -c hello.c -o hello.o</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>.d</code>文件中类似：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>现在，我们文件的依赖就加入了头文件，当我们对头文件进行修改时，就会触发重新编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ make</span><br><span class="line"><span class="built_in">rm</span> -f main.d; \</span><br><span class="line">cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">sed <span class="string">&#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27;</span> &lt; main.d.tmp &gt; main.d; \</span><br><span class="line"><span class="built_in">rm</span> -f main.d.tmp</span><br><span class="line">cc -c main.c -o main.o</span><br><span class="line">cc -o a.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h2 id="完善makefile">完善Makefile</h2>
<p>我们现在对项目目录进行整理，我们将源码放入<code>src</code>目录，将编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/Program/test$ tree .</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── Makefile</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>现在我们可以使用我们上述的操作，更新我们的makefile:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR := ./src</span><br><span class="line">BUILD_DIR := ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/a.out</span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)\1</span>.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>我们通过设置目录路径变量实现了对一个简单项目的自动化编译。至此我们的对<code>makefile</code>的基本使用就了解了</p>
<p>对于makefile，它还有很多的复杂的用法，但是之后我会更好的利用它去做更多的项目。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/21/88-%E5%8D%81%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/21/88-%E5%8D%81%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">88:十月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-21 13:00:11" itemprop="dateCreated datePublished" datetime="2025-10-21T13:00:11+08:00">2025-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:48:06" itemprop="dateModified" datetime="2025-11-29T13:48:06+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>802</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上个月都没怎么学习，几乎每天都在发呆想事情，因为我和一个傻瓜的事情。前几天去北京和她在一起呆了很久呀，感觉她还是像以前一样对我很好。但是可能异地恋的负担对于她来说还是太大了，所以我也不强求什么了。只求我能努力一点，以后和她一起去北京读书。我和她约好了我会去找她，会陪着她。</p>
<p>她对我一直都很好，很爱我的一个女生，我们从高一在一起，到十月底我们就刚好在一起四年了。我们俩的感情很好，但是我感觉自己还总是没有考虑到她的感受，导致我们的感情总是她一个人承担，所以她真的好幸苦。现在她累累的，就轮到我来照顾她了。我打算好好学习，研究生去北京陪她一起，在她需要我的时候能一直在她身边。</p>
<p>然后这次去北京，听北理的老师和其他高校的学生交流，感觉触动还是很大的吧。感觉他们的眼里都是有光的，他们有自己想做的事，想要做到的事，和自己热爱的事情。而且他们的技术氛围也很好，我感觉自己一直是固步自封，偏于一隅，眼光和格局一直放的很小，总是安于当下。我感觉自己就像一个游魂，每天就是想干啥就干啥，以前我觉得这是一种坦然，现在我感觉这是一种迷茫吧。我应该好好接受生活，体验各种事情，学习各种事情，我想接受更多的东西，不仅仅是知识和技术上的内容。</p>
<p>要做的事情很多呀，确实会很辛苦，但是我认为这是一件很值得的事情。我想和我喜欢的女生在一起，希望自己优秀一点，以后能一直陪在她身边，保护她，我爱她。现在我也不知道应该做什么吧，先把这个学期要学的东西都先学起来，争取这个学期把绩点做好一点，如果有机会保研的话就保研，如果不行的话就考研。</p>
<p>这个月暂时就是整理一下自己，然后开始学一些概率论和离散数学好了，还有一些408的课程。以前我总是不太能接受这些干巴巴的知识，我也更喜欢自己亲自动手实践，但是现在也慢慢开始理解和去接受他们的重要性了。接下来的时间，重要的事情就是先把概率论和离散数学好好学一下。尤其是离散数学，其实我一直都很感兴趣，但是苦于不知道怎么开始学习。</p>
<p>有空的话我想把图形学捡起来好好学一下，打算重构一遍上个学期写的内容，然后进一步的学习一下。</p>
<p>感觉身体也很重要，要做的事情很多，我还要接着加油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/02/87-NJU-PA-STUDY-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/02/87-NJU-PA-STUDY-4/" class="post-title-link" itemprop="url">87:NJU_PA_STUDY(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-02 21:01:08" itemprop="dateCreated datePublished" datetime="2025-10-02T21:01:08+08:00">2025-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-19 12:19:08" itemprop="dateModified" datetime="2025-10-19T12:19:08+08:00">2025-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一篇博客中,我将完成PA1的收尾部分，我将完成完成对表达式求值的功能拓展，和程序监视点的实现，预计要花费较多的时间。可能很多内容也需要好好学习理解一下。</p>
<h1 id="pa1-监视点">PA1 监视点</h1>
<h2 id="扩展表达式求值的功能">扩展表达式求值的功能</h2>
<p>之前我们实现了算数表达式基本的求值（对整数的基本四则运算与结合律），但这些表达式都是常数组成的，他们的值不会发生变化，导致这样的表达式在监视点中没有任何意义，所以我们需要为我们的表达式拓展以下功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;    # 以&quot;0x&quot;开头</span><br><span class="line">  | &lt;reg_name&gt;              # 以&quot;$&quot;开头</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;==&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;</span><br><span class="line">  | &quot;*&quot; &lt;expr&gt;              # 指针解引用</span><br></pre></td></tr></table></figure>
<p>那么首先我们就需要向框架中添加对应的解析，即更新程序的正则匹配逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_NOTYPE = <span class="number">256</span>, </span><br><span class="line">  TK_EQ, TK_NEQ, TK_AND,</span><br><span class="line">  TK_HEX, TK_NUM, TK_REG,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *regex;</span><br><span class="line">  <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,                <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,                    <span class="comment">// equal</span></span><br><span class="line">  &#123;<span class="string">&quot;!=&quot;</span>, TK_NEQ&#125;,                   <span class="comment">// unequal</span></span><br><span class="line">  &#123;<span class="string">&quot;&amp;&amp;&quot;</span>, TK_AND&#125;,                   <span class="comment">// and</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,                     <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,                       <span class="comment">// minus</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,                     <span class="comment">// multi</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,                       <span class="comment">// div</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,                     <span class="comment">// left brace</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,                     <span class="comment">// right brace</span></span><br><span class="line">  &#123;<span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span>, TK_HEX&#125;,    <span class="comment">// hex number</span></span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_NUM&#125;,               <span class="comment">// number</span></span><br><span class="line">  &#123;<span class="string">&quot;\\$(zero|ra|sp|gp|tp|t[0-6]|s[0-9]|s1[0-1]|a[0-7])&quot;</span>, TK_REG&#125;,   <span class="comment">// reg</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意两个问题：</p>
<ul>
<li><p>一是
对于reg值得获取，框架代码在<code>/src/isa/$ISA/reg.c</code>中提供了<code>isa_reg_str2val()</code>作为接口，它将返回名字为s的寄存器的值，且设置success用于指示是否匹配成功。</p></li>
<li><p>二是
我们需要注意到对指针解引用的识别，对于符号<code>*</code>它可能是乘号，也可能是对地址的解引用。实际上我们可以通过看其前一个标识的类型，我们就可以判断它的用法，所以可以给出框架代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">  *success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Implement code to evaluate the expression. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_token; i ++) &#123;						<span class="comment">// certain type 视具体情况而定</span></span><br><span class="line">  <span class="keyword">if</span> (tokens[i].type == <span class="string">&#x27;*&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tokens[i - <span class="number">1</span>].type == certain type) ) &#123;</span><br><span class="line">    tokens[i].type = DEREF;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> eval(?, ?);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现在我们开始进一步的拓展我们的表达式的能力：</p>
<h3 id="寄存器接口完善">寄存器接口完善</h3>
<p>我们需要根据<code>$</code>后的寄存器名，来获取对应的寄存器的值，并设置success:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_reg_str2val</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  *success = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(s,<span class="string">&quot;zero&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(s,regs[i])) <span class="keyword">return</span> cpu.gpr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发现寄存器返回值为-1时，则说明寄存器名称错误，我们要停止计算</p>
<h3 id="表达式计算拓展">表达式计算拓展</h3>
<p>我们添加的功能有十六进制数的解析、寄存器的解析、还有部分简单逻辑运算的解析，我们依次分析，需要在哪些地方添加哪些功能：</p>
<p>首先是token的解析存储阶段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> TK_HEX:</span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j];</span><br><span class="line">            tokens[nr_token].str[substr_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TK_NUM:  </span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j];</span><br><span class="line">            tokens[nr_token].str[substr_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> TK_REG:</span><br><span class="line">            tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len<span class="number">-1</span>;j++)</span><br><span class="line">              tokens[nr_token].str[j] = substr_start[j+<span class="number">1</span>];</span><br><span class="line">            tokens[nr_token].str[substr_len<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们添加了对十六进制标识符和寄存器的存储。</p>
<p>同时我们也要注意在<code>eval()</code>，由于我们引入了十六进制和寄存器进入表达式解析中，所以对于最小的子表达式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;   </span><br><span class="line">  | &lt;reg_name&gt;      </span><br></pre></td></tr></table></figure>
<p>我们的解析应该展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[start].type==TK_REG)&#123;</span><br><span class="line">      <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">word_t</span> val = isa_reg_str2val(tokens[start].str,&amp;success);</span><br><span class="line">      <span class="keyword">if</span>(success) <span class="keyword">return</span> val;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Invalid register name: %s\n&quot;</span>, tokens[start].str);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strtol(tokens[start].str,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由于我们添加了逻辑表达式，所以我们还需要更新其对表达式的拆分和运算，首先是运算部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TK_EQ: <span class="keyword">return</span> (val1==val2);</span><br><span class="line">      <span class="keyword">case</span> TK_NEQ: <span class="keyword">return</span> (val1!=val2);</span><br><span class="line">      <span class="keyword">case</span> TK_AND: <span class="keyword">return</span> (val1&amp;&amp;val2);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>与之而来的问题是，在引入逻辑表达式之后，我们该怎么拆分我们的表达式呢？我们知道对于目前已有的运算符，我们有<code>* / &gt; + - &gt;逻辑运算</code>的优先级关系，所以我们可以根据上一节中的规则来更新我们的主运算符号的选择：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_token</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> token = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> par = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> min_priority = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=tokens[i].type;</span><br><span class="line">    <span class="keyword">if</span>(tmp==TK_NUM) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="string">&#x27;(&#x27;</span>) par++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      par--;</span><br><span class="line">      <span class="keyword">if</span>(par&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(par!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> TK_EQ: <span class="keyword">case</span> TK_NEQ: <span class="keyword">case</span> TK_AND:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">3</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(token != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Main operator: %c at position %d\n&quot;, tokens[token].type, token);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No operator found in range [%d, %d]\n&quot;</span>, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了对于运算符的解析和拓展。</p>
<h3 id="解引用分析">解引用分析</h3>
<p>最后我们还需要解决的一个问题就是对于指针的解引用，我们根据框架代码，对负号和解引用的标识符进行替换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nr_token;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((tokens[i].type==<span class="string">&#x27;*&#x27;</span>||tokens[i].type==<span class="string">&#x27;-&#x27;</span>)&amp;&amp;</span><br><span class="line">        (i==<span class="number">0</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;+&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;-&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;*&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;/&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==<span class="string">&#x27;(&#x27;</span>||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_AND||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_EQ||</span><br><span class="line">        tokens[i<span class="number">-1</span>].type==TK_NEQ)</span><br><span class="line">      )&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i].type == <span class="string">&#x27;*&#x27;</span>) tokens[i].type = DEREF;</span><br><span class="line">        <span class="keyword">else</span> tokens[i].type = NEGATIVE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">word_t</span> val = eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line">  *success = (val!=<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于他们都是一元运算符，在计算的过程中拥有最高的优先级，所以我们需要更新搜索主运算符的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> DEREF: <span class="keyword">case</span> NEGATIVE:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">0</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TK_EQ: <span class="keyword">case</span> TK_NEQ: <span class="keyword">case</span> TK_AND:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">3</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后再最终的对表达式的整合中优先处理一元运算符号，再处理二元运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tokens[op].type == DEREF || tokens[op].type == NEGATIVE) &#123;</span><br><span class="line">      <span class="type">word_t</span> val = eval(op+<span class="number">1</span>, end);</span><br><span class="line">      <span class="keyword">if</span>(val == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(tokens[op].type == DEREF) <span class="keyword">return</span> vaddr_read(val, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> -val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> TK_EQ: <span class="keyword">return</span> (val1==val2);</span><br><span class="line">      <span class="keyword">case</span> TK_NEQ: <span class="keyword">return</span> (val1!=val2);</span><br><span class="line">      <span class="keyword">case</span> TK_AND: <span class="keyword">return</span> (val1&amp;&amp;val2);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>至此我们完成了对表达式运算符的拓展。</p>
<h2 id="实现监视点">实现监视点</h2>
<p>监视器允许我们设置监视点，当监视点中的表达式满足时，<code>nemu</code>就将<code>nemu_state</code>设置成<code>NEMU_STOP</code>，此时我们就可以对程序状态进行观察。</p>
<p>不过首先我们需要能够将所有监视点管理组织起来，在框架代码中已经定义好了监视点的结构和监视点池的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> NO;	<span class="comment">// 监视器的编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line"></span><br><span class="line">&#125; WP;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> WP wp_pool[NR_WP] = &#123;&#125;;</span><br><span class="line"><span class="type">static</span> WP *head = <span class="literal">NULL</span>, *free_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>我们需要管理两个链表<code>head</code>和<code>free_</code>。<code>head</code>用于存放使用中的监视点结构，<code>free_</code>用于组织空闲的监视点结构，我们可以使用<code>init_wp_pool()</code>函数，对两个链表进行初始化。</p>
<p>为了进一步的管理监视点池，我们需要两个函数：</p>
<ul>
<li><code>WP* new_wp()</code>：用于从空闲的监视点池中选择一个监视点进行使用，同时也要对剩余监视点的数量进行判断</li>
<li><code>void free_wp(WP* wp)</code>：
用于将正在使用中的监视点存回空闲链表中</li>
</ul>
<p>实现了对监视点池的管理之后，我们就需要实现监视点的相关功能了（以下是需要完成的要求）：</p>
<ul>
<li>当用户给出一个待监视表达式时,
你需要通过<code>new_wp()</code>申请一个空闲的监视点结构,
并将表达式记录下来.
然后在<code>trace_and_difftest()</code>函数(在<code>nemu/src/cpu/cpu-exec.c</code>中定义)的最后扫描所有的监视点,
每当<code>cpu_exec()</code>的循环执行完一条指令,
都会调用一次<code>trace_and_difftest()</code>函数. 在扫描监视点的过程中,
你需要对监视点的相应表达式进行求值(你之前已经实现表达式求值的功能了),
并比较它们的值有没有发生变化, 若发生了变化,
程序就因触发了监视点而暂停下来,
你需要将<code>nemu_state.state</code>变量设置为<code>NEMU_STOP</code>来达到暂停的效果.
最后输出一句话提示用户触发了监视点,
并返回到<code>sdb_mainloop()</code>循环中等待用户的命令.</li>
<li>使用<code>info w</code>命令来打印使用中的监视点信息, 至于要打印什么,
你可以参考GDB中<code>info watchpoints</code>的运行结果.</li>
<li>使用<code>d</code>命令来删除监视点,
你只需要释放相应的监视点结构即可.</li>
</ul>
<h3 id="监视点池的管理">监视点池的管理</h3>
<p>这里我想监视点的结构中添加了一个<code>used</code>属性，用来判断当前监视点是否被启用，据此，我们就可以实现对监视点池中的监视点的使用和空闲的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">WP* <span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(free_==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No free watchpoint avilable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WP* wp = free_;</span><br><span class="line">  free_ = free_-&gt;next;</span><br><span class="line">  wp-&gt;used = <span class="number">1</span>;</span><br><span class="line">  wp-&gt;next = head;</span><br><span class="line">  head = wp;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Create watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">  <span class="keyword">return</span> wp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP* wp)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(wp==<span class="literal">NULL</span>||!wp-&gt;used) <span class="built_in">printf</span>(<span class="string">&quot;Invalid watchpoint to free\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(head==wp)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    WP* prev = head;</span><br><span class="line">    <span class="keyword">while</span>(prev!=<span class="literal">NULL</span>&amp;&amp;prev-&gt;next!=wp) prev = prev-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="literal">NULL</span>) prev-&gt;next = wp-&gt;next;</span><br><span class="line">    wp-&gt;used=<span class="number">0</span>;</span><br><span class="line">    wp-&gt;next = free_;</span><br><span class="line">    free_ = wp;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Free watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要进一步的完成监视点的功能，以及用于调用的接口</p>
<h3 id="监视点功能实现">监视点功能实现</h3>
<p>监视点的功能实际上就是在每一次执行之后，遍历一遍监视点链表，如果设置的表达式发生了改变，那么我们说监视点被触发了。所以我们要做的事情很简单，遍历计算表达式的值是否发生改变，如果是，则触发监视点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wp_diff</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* wp = head;</span><br><span class="line">  <span class="keyword">while</span>(wp)&#123;</span><br><span class="line">    <span class="type">bool</span> _;</span><br><span class="line">    <span class="type">word_t</span> new = expr(wp-&gt;expr,&amp;_);</span><br><span class="line">    <span class="keyword">if</span>(wp-&gt;val!=new)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Watchpoint #%d: %s\n Old value = 0x%08x\n New value = 0x%08x\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO,wp-&gt;expr,wp-&gt;val,new);</span><br><span class="line">      wp-&gt;val = new;</span><br><span class="line">      nemu_state.state = NEMU_STOP;</span><br><span class="line">    &#125;</span><br><span class="line">    wp = wp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于NEMU在每次执行时都会在<code>execute()</code>中调用<code>trace_and_difftest()</code>我们在这个程序中加入每次对监视点的判断<code>wp_diff()</code></p>
<p>现在我们只需要进一步完成监视点的接口，使得我们可以方便的创建销毁查看他们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">P* <span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(free_==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No free watchpoint avilable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WP* wp = free_;</span><br><span class="line">  free_ = free_-&gt;next;</span><br><span class="line">  wp-&gt;used = <span class="number">1</span>;</span><br><span class="line">  wp-&gt;next = head;</span><br><span class="line">  head = wp;</span><br><span class="line">  <span class="keyword">return</span> wp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WP* <span class="title function_">NO2wp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;wp_pool[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP* wp)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(wp==<span class="literal">NULL</span>||!wp-&gt;used)&#123;<span class="built_in">printf</span>(<span class="string">&quot;Invalid watchpoint to free\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">if</span>(head==wp)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    WP* prev = head;</span><br><span class="line">    <span class="keyword">while</span>(prev!=<span class="literal">NULL</span>&amp;&amp;prev-&gt;next!=wp) prev = prev-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="literal">NULL</span>) prev-&gt;next = wp-&gt;next;</span><br><span class="line">    wp-&gt;used=<span class="number">0</span>;</span><br><span class="line">    wp-&gt;next = free_;</span><br><span class="line">    free_ = wp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Free watchpoint #%d\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_set</span><span class="params">(<span class="type">char</span>* expr,<span class="type">word_t</span> val)</span>&#123;</span><br><span class="line">  WP* wp = new_wp();</span><br><span class="line">  <span class="built_in">strcpy</span>(wp-&gt;expr,expr);</span><br><span class="line">  wp-&gt;val = val;</span><br><span class="line">  <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;Create watchpoint #%d: %s\n&quot;</span>,ANSI_FG_BLUE),wp-&gt;NO,wp-&gt;expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_display</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* tmp = head;</span><br><span class="line">  <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在终端进行调用，实现<code>info w</code>，<code>d NO</code>，<code>w EXPR</code>等功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_w</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">word_t</span> val = expr(args,&amp;success);</span><br><span class="line">  <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid expression: %s\n&quot;</span>,args);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wp_set(args,val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_d</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">int</span> NO = atoi(args);</span><br><span class="line">  free_wp(NO2wp(NO));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wp_display</span><span class="params">()</span>&#123;</span><br><span class="line">  WP* tmp = head;</span><br><span class="line">  <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Watchpoint #%d -&gt; %s\n&quot;</span>,tmp-&gt;NO,tmp-&gt;expr);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们就实现了监视点的功能。</p>
<p>对于断点我们可以通过<code>w $pc=？</code>的方式来让程序停止</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/29/86-NJU-PA-STUDY-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/29/86-NJU-PA-STUDY-3/" class="post-title-link" itemprop="url">86:NJU_PA_STUDY(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-29 12:14:57" itemprop="dateCreated datePublished" datetime="2025-09-29T12:14:57+08:00">2025-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 13:57:29" itemprop="dateModified" datetime="2025-10-02T13:57:29+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们先前反复提到了一个式子<code>EXPR</code>，它代表着表达式含义，常见的表达式是通过操作符连接的。这里我们需要为我们的框架实现一个表达式求值的功能。我们要解决的问题是求值一个字符串表示的表达式。</p>
<h1 id="pa1-表达式求值">PA1 表达式求值</h1>
<p>为了简单起见，我们先从数学表达式求值实现开始。</p>
<h2 id="数学表达式求值">数学表达式求值</h2>
<p>如下的一个表达式的字符串：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;5 + 4 * 3 / 2 - 1&quot;</span><br></pre></td></tr></table></figure>
<p>我们应该怎么求出它的值？我们可以分成两个简单的步骤：</p>
<ul>
<li>首先识别出表达式中的单元</li>
<li>根据表达式的归纳定义进行递归求值</li>
</ul>
<h3 id="词法分析">词法分析</h3>
<p>词法分析要做的事情就是识别出表达式中的单元，这里的单元指的就是有着独立含义的子串，我们称之为token。具体而言我们需要将表达式中所有的单元都赋予一个标签，方便之后根据标签来对表达式进行处理。这里我们使用正则表达式来对<code>token</code>进行处理。</p>
<p>出于简单起见，这里我们暂时只对以下的<code>token</code>类型进行处理：</p>
<ul>
<li>十进制整数</li>
<li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code></li>
<li><code>(</code>，<code>)</code></li>
<li>空格串（一个或者多个空格）</li>
</ul>
<p>首先我们需要使用正则表达式来编写用于识别这些<code>token</code>类型的规则，框架中演示了怎么对其进行匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *regex;</span><br><span class="line">  <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">   * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,    <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,         <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,        <span class="comment">// equal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些规则，在<code>init_sdb()</code>时调用了<code>init_regex()</code>来将其编译成正则结构体并存储在<code>re</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_regex</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> error_msg[<span class="number">128</span>];</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">    ret = regcomp(&amp;re[i], rules[i].regex, REG_EXTENDED);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      regerror(ret, &amp;re[i], error_msg, <span class="number">128</span>);</span><br><span class="line">      panic(<span class="string">&quot;regex compilation failed: %s\n%s&quot;</span>, error_msg, rules[i].regex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果编译不通过，可能是你编写的<code>token</code>匹配的规则不符合正则表达式的语法。现在，我们可以给出一个待匹配的表达式，我们利用<code>make_token()</code>来识别出其中的token。用<code>position</code>变量指示当前待匹配的位置，然后按顺序对当前位置的字符串进行匹配。当一个规则匹配成功，并且匹配出的字串属于position指出的位置时，我们就成功的识别出了一个token。我们则使用Token结构体来将它的内容记录下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">32</span>];</span><br><span class="line">&#125; Token;</span><br><span class="line"><span class="type">static</span> Token tokens[<span class="number">32</span>] __attribute__((used)) = &#123;&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_token __attribute__((used))  = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>type</code>成员用于记录<code>token</code>的类型，然后<code>str</code>用来保存<code>token</code>相应的字串。<code>tokens</code>数组用来保存识别出的<code>token</code>信息，而<code>nr_token</code>则用来指示被识别出的<code>token</code>数目。</p>
<p>现在我们需要向算数表达式中的各种<code>tokens</code>类型添加规则，在成功识别出<code>token</code>hi后，将token的信息一次记录到<code>tokens</code>数组之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules[] = &#123;</span><br><span class="line">  <span class="comment">// 这里需要注意对这些内容的匹配是有优先顺序的，从上到下</span></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,    <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,        <span class="comment">// equal</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,         <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,           <span class="comment">// minus</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,         <span class="comment">// multi</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,       	<span class="comment">// div</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,         <span class="comment">// left brace</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, <span class="string">&#x27;)&#x27;</span>&#125;,         <span class="comment">// right brace</span></span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_NUM&#125;,   <span class="comment">// number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们就需要将匹配到的token放入tokens中，并对它的各个字段进行赋值。对于大多数类型，我们只需要简单的保存它的类型就行了，但是对于有数据内容的token，我们需要保存它的<code>data</code>，在这里既是保存它的子串内容信息，方便我们进行进一步的计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">make_token</span><span class="params">(<span class="type">char</span> *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">  <span class="type">regmatch_t</span> pmatch;</span><br><span class="line">  nr_token = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e[position] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">/* Try all rules one by one. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (regexec(&amp;re[i], e + position, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; pmatch.rm_so == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *substr_start = e + position;</span><br><span class="line">        <span class="type">int</span> substr_len = pmatch.rm_eo;</span><br><span class="line">        Log(<span class="string">&quot;match rules[%d] = \&quot;%s\&quot; at position %d with len %d: %.*s&quot;</span>,</span><br><span class="line">            i, rules[i].regex, position, substr_len, substr_len, substr_start);</span><br><span class="line">        position += substr_len;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Now a new token is recognized with rules[i]. Add codes</span></span><br><span class="line"><span class="comment">         * to record the token in the array `tokens&#x27;. For certain types</span></span><br><span class="line"><span class="comment">         * of tokens, some extra actions should be performed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> TK_NUM:  </span><br><span class="line">            tokens[index].type = rules[i].token_type;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;substr_len;j++)</span><br><span class="line">              tokens[index].str[j] = substr_start[j];</span><br><span class="line">            <span class="comment">// printf(&quot;The num is %s\n&quot;,tokens[index].str);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            tokens[index].type = rules[i].token_type;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == NR_REGEX) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;no match at position %d\n%s\n%*.s^\n&quot;</span>, position, e, position, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到整个识别token的过程，每当我们获取一个<code>token</code>时，我们都会使用<code>Log()</code>将它的匹配规则，子串下标，子串长度，和对应的子串信息打印出来。便于我们观察标识符匹配的中间过程。对于未匹配到的类型，我们也会将其内容进行返回。</p>
<p>中间部分则是我们对token信息的存储过程，目前我们只对十进制整数的内容进行了保存，对于其他的标识符号，则是简单的保存类型。现在我们可以进一步的进行表达式求值了。</p>
<h3 id="递归求值">递归求值</h3>
<p>我们现在将求值表达式的<code>token</code>识别出来之后就可以进行求值了。我们现在是对<code>token</code>数组进行处理，方便起见，我们称其为<code>token</code>表达式。（将空格忽略）</p>
<p>接下来，根据表达式的归纳定义特性，我们可以使用递归来进行求值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;number&gt;    # 一个数是表达式</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;     # 在表达式两边加个括号也是表达式</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;  # 两个表达式相加也是表达式</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;  # 接下来你全懂了</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>这种表示方法就是我们常说的BNF，我们可以这里理解，长表达式是由短表达式构成的，那么我们可以先对短表达式进行求值，然后再进一步的对长表达式进行求值。</p>
<p>为了在token表达式中指示一个子表达式，我么可以使用两个整数<code>p</code>和<code>q</code>来指示子表达式的开始和结束位置，现在我们就可以写出一个求值函数的框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">    <span class="comment">/* Bad expression */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">    <span class="comment">/* Single token.</span></span><br><span class="line"><span class="comment">     * For now this token should be a number.</span></span><br><span class="line"><span class="comment">     * Return the value of the number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (check_parentheses(p, q) == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* The expression is surrounded by a matched pair of parentheses.</span></span><br><span class="line"><span class="comment">     * If that is the case, just throw away the parentheses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> eval(p + <span class="number">1</span>, q - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* We should do more things here. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>check_parentheses()</code>用于判断表达式是否被一堆匹配的括号所包围，同时检查表达式左右的括号是否匹配，如果不匹配，那么这个表达式就是非法的。我们以此来尝试实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_parentheses</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> cond=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(tokens[start].type!=<span class="string">&#x27;(&#x27;</span>||tokens[end].type!=<span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[i].type==<span class="string">&#x27;(&#x27;</span>) cond++;</span><br><span class="line">    <span class="keyword">if</span>(tokens[i].type==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      cond--;</span><br><span class="line">      <span class="keyword">if</span>(cond&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cond==<span class="number">0</span>) <span class="keyword">return</span> (i == end) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (cond==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们的框架代码，已经可以处理BNF的开始两种情况啦。像现在我们需要进一步的考虑剩下的情况，即四则运算的处理。但是问题在于，我们怎么对一个长表达式处理，将其分解为各个小的短表达式，并保证语法的正确呢？</p>
<p>我们以下为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;4 + 3 * ( 2 - 1 )&quot;</span></span><br><span class="line"><span class="comment">/*********************/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="string">&quot;+&quot;</span></span><br><span class="line">   /   \</span><br><span class="line"><span class="string">&quot;4&quot;</span>     <span class="string">&quot;3 * ( 2 - 1 )&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="string">&quot;*&quot;</span></span><br><span class="line">       /   \</span><br><span class="line"><span class="string">&quot;4 + 3&quot;</span>     <span class="string">&quot;( 2 - 1 )&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="string">&quot;-&quot;</span></span><br><span class="line">             /   \</span><br><span class="line"><span class="string">&quot;4 + 3 * ( 2&quot;</span>     <span class="string">&quot;1 )&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到只有第一种情况是正确的，第二种情况违背了算术符号的优先级，而第三种情况则使得表达式的括号不再匹配。通过以上的例子，我们就可以总结出寻找主运算符（可以将一个长表达式分解成两个短表达式的运算符号）的逻辑了：</p>
<ul>
<li>非运算符的<code>token</code>不是主运算符</li>
<li>出现在一对括号中的<code>token</code>不是主运算符号</li>
<li>主运算符的优先级在表达式中应该是最低的</li>
<li>有多个运算符的优先级最低时，根据结合性，最后被结合的运算符为主运算符号</li>
</ul>
<p>现在我们根据以上规则来扫描出每个表达式中的主运算符号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_token</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="type">int</span> token = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> par = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> min_priority = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=tokens[i].type;</span><br><span class="line">    <span class="keyword">if</span>(tmp==TK_NUM) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="string">&#x27;(&#x27;</span>) par++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      par--;</span><br><span class="line">      <span class="keyword">if</span>(par&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(par!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tmp)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">1</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>(min_priority&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        min_priority=<span class="number">2</span>;</span><br><span class="line">        token=i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(token != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Main operator: %c at position %d\n&quot;, tokens[token].type, token);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No operator found in range [%d, %d]\n&quot;</span>, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到表达式的主运算符之后，事情就变得简单了，我们先对两个分裂出来的子表达式进行递归求值，然后根据主运算符号的两个子表达式进行计算即可，现在我们的框架代码更新如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">eval(p, q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">    <span class="comment">/* Bad expression */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">    <span class="comment">/* Single token.</span></span><br><span class="line"><span class="comment">     * For now this token should be a number.</span></span><br><span class="line"><span class="comment">     * Return the value of the number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (check_parentheses(p, q) == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* The expression is surrounded by a matched pair of parentheses.</span></span><br><span class="line"><span class="comment">     * If that is the case, just throw away the parentheses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> eval(p + <span class="number">1</span>, q - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    op = the position of 主运算符 in the token expression;</span><br><span class="line">    val1 = eval(p, op - <span class="number">1</span>);</span><br><span class="line">    val2 = eval(op + <span class="number">1</span>, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1 + val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们需要利用现有的规则和函数来填补实现我们的求值函数<code>eval()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown expression.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">    <span class="keyword">return</span> atoi(tokens[start].str);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(check_parentheses(start,end)==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> eval(start+<span class="number">1</span>,end<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(check_parentheses(start,end)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parenthese mismatch error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> op = get_token(start,end);</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: No valid operator found in expression\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">word_t</span> val1 = eval(start,op<span class="number">-1</span>);</span><br><span class="line">    <span class="type">word_t</span> val2 = eval(op+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">switch</span>(tokens[op].type)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> val1+val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> val1-val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> val1*val2;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">        <span class="keyword">if</span>(val2==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by 0\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1/val2;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试，基本可以处理大多数情况了。我们现在可以将其封装在<code>expr()</code>中，然后实现<code>p</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">word_t</span> val = eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line">  *success = (val!=<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_p</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">bool</span> success;</span><br><span class="line">  <span class="type">word_t</span> val=expr(args,&amp;success);</span><br><span class="line">  <span class="keyword">if</span>(success==<span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于限制，我们只使用<code>uint32_t</code>作为我们的返回类型。</p>
<h3 id="测试代码">测试代码</h3>
<p>按照PA的要求，我们现在应该测试一下我们这个函数，但是我就跳过这一部分了，因为赶时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/28/85-NJU-PA-STUDY-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/28/85-NJU-PA-STUDY-2/" class="post-title-link" itemprop="url">85:NJU_PA_STUDY(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-28 09:34:21 / 修改时间：13:13:00" itemprop="dateCreated datePublished" datetime="2025-09-28T09:34:21+08:00">2025-09-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>NEME是一个用于执行其他用户程序的虚拟计算机，对于运行在NEMU中的应用程序，外部的调试器难以获取其详细的信息，往往需要对引用程序内部下断点的方法来观察程序运行。</p>
<p>但是对于NEMU而言，应用程序的状态是可见的，因此我们需要一个简单有效的方法来观察并调试应用程序的内部状态，所以我们需要设计简易调试器，作为NEMU的基础设施，方便日后的进一步处理。</p>
<h1 id="pa1-基础设施">PA1 基础设施</h1>
<p>我们需要在monitor中实现一个简单的sdb。相关的框架代码存放在<code>src\monitor\sdb</code>中，我们可以在cmd_table中查看目前已有的指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *description;</span><br><span class="line">  <span class="type">int</span> (*handler) (<span class="type">char</span> *);</span><br><span class="line">&#125; cmd_table [] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display information about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在PA1中我们要实现的功能还有：</p>
<figure>
<img src="https://s2.loli.net/2025/09/28/dQbZXDc6zxEKeNS.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>今天则从最基本的三个功能开始实现：</p>
<ul>
<li>单步执行</li>
<li>打印寄存器状态</li>
<li>扫描内存状态</li>
</ul>
<h2 id="解析命令">解析命令</h2>
<p>NEMU通过<readline>库对命令行输入进行处理。我们可以在函数<code>rl_gets()</code>中看到对<code>readline()</code>函数的包装。然后在<code>sdb_mainloop()</code>中通过调用其获取，命令行内容。后续对获取的命令行内容进行解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> *str; (str = rl_gets()) != <span class="literal">NULL</span>; ) &#123;</span><br><span class="line">    <span class="type">char</span> *str_end = str + <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* extract the first token as the command */</span></span><br><span class="line">    <span class="type">char</span> *cmd = strtok(str, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="literal">NULL</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* treat the remaining string as the arguments,</span></span><br><span class="line"><span class="comment">     * which may need further parsing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *args = cmd + <span class="built_in">strlen</span>(cmd) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (args &gt;= str_end) &#123;</span><br><span class="line">      args = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里程序将命令行内容解析为命令<code>cmd</code>和命令行参数<code>args</code>，我们接受cmd和args的指针，然后根据cmd调用对应的指令。不过这里需要注意。对于多参数的指令，我们需要对<code>args</code>进行额外的处理。</p>
<h2 id="单步执行">单步执行</h2>
<p>现在我们开始进行单步执行的操作，首先我们需要向<code>cmd_table</code>中添加我们的指令和对应的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;si&quot;</span>, <span class="string">&quot;si [N]&quot;</span>, cmd_si&#125;,</span><br></pre></td></tr></table></figure>
<p>然后对于<code>si</code>的执行逻辑我们写在处理函数<code>cmd_si</code>中。</p>
<p>对于单步执行的实现，我们希望CPU一次只执行一条指令，我们自然会想到先前的负责CPU执行的函数<code>cpu_exec()</code>，我们可以参考<code>c/continue</code>的实现来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(args==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    cpu_exec(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> step = strtol(args,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  cpu_exec(step);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用<code>si</code>是默认步进一条指令，当给出指定参数时，不仅指定的步数。</p>
<h2 id="显示寄存器">显示寄存器</h2>
<p>寄存器和ISA架构是相关的，所以框架中为我们在<code>src/isa/$ISA/reg.c</code>中设置了相应的接口<code>isa_regs_display()</code>，我们只需要完善这个接口。然后在处理函数中调用它就好了。</p>
<p>我们先向<code>cmd_tale</code>中添加对应的功能:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;info&quot;</span>, <span class="string">&quot;info [r/w]&quot;</span>, cmd_info&#125;,</span><br></pre></td></tr></table></figure>
<p>使用<code>cmd_info()</code>作为命令的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;r\0&quot;</span>,<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown arguments &#x27;%s&#x27;\n&quot;</span>,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    isa_reg_display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于之后还要拓展所以需要对<code>info</code>的参数进行匹配。这里我们调用了框架提供的接口进行使用<code>isa_regs_display()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isa_reg_display</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i+=<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i],cpu.gpr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i+<span class="number">1</span>],cpu.gpr[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x |\t&quot;</span>,regs[i+<span class="number">2</span>],cpu.gpr[i+<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\t0x%08x\n&quot;</span>,regs[i+<span class="number">3</span>],cpu.gpr[i+<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过对应的格式打印<code>cpu</code>结构中的通用寄存器的值即可。</p>
<h2 id="扫描内存">扫描内存</h2>
<p>由于我们还没有实现对表达式的求值和解析，所以在指定内存时，我们暂时只支持十六进制。至于扫描内存，我们只需要从指定的位置起始，使用内存接口打印指定长度的字节即可。我们可以在<code>src\memory\vaddr.c</code>中找到我们可使用的接口。</p>
<p>由于我们的应用程序是运行在虚拟空间中的，所以我们使用的是虚拟内存读取<code>vaddr_read()</code>。现在我们可以尝试开始实现这个功能，首先我们需要向<code>cmd_table()</code>，添加功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;x&quot;</span>, <span class="string">&quot;x [N] EXPR&quot;</span>, cmd_x&#125;</span><br></pre></td></tr></table></figure>
<p>由于这一部分我们需要使用两个参数，所以我们还需要对<code>args</code>进行预处理，用于为内存扫描提供参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* arg1=strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(arg1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No argument1 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  len = strtol(arg1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* arg2=strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(arg2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No argument2 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  addr = strtol(arg2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>strtol</code>来划分参数，然后使用strtol将参数转换为对应的数值，作为接口的参数，然后我们就可以通过访问接口，遍历打印指定位置的内存数数据了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span>* args)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">char</span>* arg1=strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(arg1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No argument1 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    len = strtol(arg1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>* arg2=strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(arg2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No argument2 , the format &#x27;x [N] EXPR&#x27;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    addr = strtol(arg2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(ANSI_FMT(<span class="string">&quot;0x%08x:  &quot;</span>,ANSI_FG_BLUE),addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;len&amp;&amp;j&lt;<span class="number">4</span>;i++,j++)&#123;</span><br><span class="line">      <span class="type">uint32_t</span> data = vaddr_read(addr, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0x%08x  &quot;</span>,data);</span><br><span class="line">      addr += <span class="number">4</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了PA1中的基础设施。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/27/84-%E4%B9%9D%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/84-%E4%B9%9D%E6%9C%88%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">84:九月的反思</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-27 19:56:50" itemprop="dateCreated datePublished" datetime="2025-09-27T19:56:50+08:00">2025-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-29 13:47:54" itemprop="dateModified" datetime="2025-11-29T13:47:54+08:00">2025-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%88%E6%8A%A5/" itemprop="url" rel="index"><span itemprop="name">月报</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>793</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个月发生了各种各样的事情，我特别累也特别疲惫。对于上次以后的总结，我几乎记不得中间都做了哪些事情。我不想对这一个月的经历过多谈论，我心里是十分难过的。</p>
<p>接下来一段时间会很忙，忙在哪些地方呢？</p>
<ul>
<li>NJU PA实验，我要坚持写下去</li>
<li>操作系统真象还原，我也要坚持看下去，我希望能通过这本书的指引，实现一个自己的操作系统。之后我想仿写xv6的源代码，实现一个基本的操作系统内核。</li>
<li>最近新接的科研训练项目，主题是<code>基于动态欺骗的主动网络防护技术</code>，现在还在写文档阶段，非常无聊和痛苦</li>
<li>这个学期冗杂的课程，还有各种活动</li>
</ul>
<p>直白的说，我这个月是感情失利了。我和在一起四年的一个女生分开了。感觉就是很难过，不知道怎么用语言描述，我一开始天天躺着，天天打游戏来麻痹自己，但是感觉都没什么用。我不知道怎么办，我想各种办法去转移自己的注意力，但是无论做什么都没办法集中自己，这几天睡得也很晚，总之就是精神状态很差。</p>
<p>但是我也不该，也不愿意一直这么下去，我找各种各样得事情给自己，不知不觉就这么多事情了。现在已经过去了大半个月了，不想刚开始一样一想到就会好难过，但是偶尔还是会难过。我觉得生活还得继续，不能一直自暴自弃，继续走下去，也许我会遇到更好的女生，也许我会以更好的状态遇见她。我这么想着，慢慢开始忙碌起来，身体还是很疲惫，依然需要时间去习惯与适应。</p>
<p>可能十月份会非常忙吧，各种各样的事情，所以国庆也不能闲着，要抓紧时间。可能这个学期能玩游戏的时间会越来越少，但还是要坚持住。这也是我第一次参加科研训练，我对科研学习的过程也一直很感兴趣，我想好好体验一下这个过程。</p>
<p>还有PA实验和操作系统，本来操作系统是想跟着JYY老师的课程学习的，现在看来是没什么时间了。还要概率论、离散数学、密码学应用基础，这些课基本还没听过，也不知道怎么办。这个学期的408课程也是牢的没边，也不知道怎么办。</p>
<p>这么看了这个学期还真是坎坷，和我暑假时预想的一点也不一样。当然我也没想到会和她分手QAQ，不过现在她还是愿意陪我聊天的，说不定以后还有机会。事到如今只能，继续坚持下去。希望以后会越来越好，也希望我能在这段时间里慢慢获得成长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/27/83-NJU-PA-STUDY-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/83-NJU-PA-STUDY-1/" class="post-title-link" itemprop="url">83:NJU_PA_STUDY(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-27 07:37:21 / 修改时间：10:54:09" itemprop="dateCreated datePublished" datetime="2025-09-27T07:37:21+08:00">2025-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">项目练习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/NJUPA/" itemprop="url" rel="index"><span itemprop="name">NJUPA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="pa1-rtfsc">PA1 RTFSC</h1>
<h2 id="框架代码">框架代码</h2>
<p>由于NEMU-PA是一个很庞大的框架系统，所以要在其基础之上开发需要对框架代码进行熟悉。所以最重要的一步应该是阅读程序的源代码。在课件中，已经给出了相关代码的简要结构说明，按照标题简单理解即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── configs                    # 预先提供的一些配置文件</span><br><span class="line">├── include                    # 存放全局使用的头文件</span><br><span class="line">│   ├── common.h               # 公用的头文件</span><br><span class="line">│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   ├── cpu.h</span><br><span class="line">│   │   ├── decode.h           # 译码相关</span><br><span class="line">│   │   ├── difftest.h</span><br><span class="line">│   │   └── ifetch.h           # 取指相关</span><br><span class="line">│   ├── debug.h                # 一些方便调试用的宏</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── difftest-def.h</span><br><span class="line">│   ├── generated</span><br><span class="line">│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏</span><br><span class="line">│   ├── isa.h                  # ISA相关</span><br><span class="line">│   ├── macro.h                # 一些方便的宏定义</span><br><span class="line">│   ├── memory                 # 访问内存相关</span><br><span class="line">│   └── utils.h</span><br><span class="line">├── Kconfig                    # 配置信息管理的规则</span><br><span class="line">├── Makefile                   # Makefile构建脚本</span><br><span class="line">├── README.md</span><br><span class="line">├── resource                   # 一些辅助资源</span><br><span class="line">├── scripts                    # Makefile构建脚本</span><br><span class="line">│   ├── build.mk</span><br><span class="line">│   ├── config.mk</span><br><span class="line">│   ├── git.mk                 # git版本控制相关</span><br><span class="line">│   └── native.mk</span><br><span class="line">├── src                        # 源文件</span><br><span class="line">│   ├── cpu</span><br><span class="line">│   │   └── cpu-exec.c         # 指令执行的主循环</span><br><span class="line">│   ├── device                 # 设备相关</span><br><span class="line">│   ├── engine</span><br><span class="line">│   │   └── interpreter        # 解释器的实现</span><br><span class="line">│   ├── filelist.mk</span><br><span class="line">│   ├── isa                    # ISA相关的实现</span><br><span class="line">│   │   ├── mips32</span><br><span class="line">│   │   ├── riscv32</span><br><span class="line">│   │   ├── riscv64</span><br><span class="line">│   │   └── x86</span><br><span class="line">│   ├── memory                 # 内存访问的实现</span><br><span class="line">│   ├── monitor</span><br><span class="line">│   │   ├── monitor.c</span><br><span class="line">│   │   └── sdb                # 简易调试器</span><br><span class="line">│   │       ├── expr.c         # 表达式求值的实现</span><br><span class="line">│   │       ├── sdb.c          # 简易调试器的命令处理</span><br><span class="line">│   │       └── watchpoint.c   # 监视点的实现</span><br><span class="line">│   ├── nemu-main.c            # 你知道的...</span><br><span class="line">│   └── utils                  # 一些公共的功能</span><br><span class="line">│       ├── log.c              # 日志文件相关</span><br><span class="line">│       ├── rand.c</span><br><span class="line">│       ├── state.c</span><br><span class="line">│       └── timer.c</span><br><span class="line">└── tools                      # 一些工具</span><br><span class="line">    ├── fixdep                 # 依赖修复, 配合配置系统进行使用</span><br><span class="line">    ├── gen-expr</span><br><span class="line">    ├── kconfig                # 配置系统</span><br><span class="line">    ├── kvm-diff</span><br><span class="line">    ├── qemu-diff</span><br><span class="line">    └── spike-diff</span><br></pre></td></tr></table></figure>
<p>为了支持不同的ISA形式。框架代码将NEMU分成两部分：ISA的相关实现和ISA无关的框架代码。其中不同的ISA被存放在<code>src/isa</code>目录下，用于提供接口，其余部分框架则是相同的实现。这里我们选择RISCV作为我们的ISA，现在我们就可以对整个框架代码进行分析了。</p>
<h2 id="配置系统和项目构建">配置系统和项目构建</h2>
<p>系统的主要配置文件存放在主目录下的<code>Kconfig</code>文件中，当我们运行<code>make memuconfig</code>时，会弹出一个可视化的编辑界面，程序会将我们的选择对应的添加到<code>include\generate\autoconf.h</code>中，用于编译时设置。从而实现对框架代码的简易配置。</p>
<p>对于更复杂的过程，涉及到<code>makefile</code>的编写，这里暂时忽略。</p>
<h2 id="准备第一个客户应用">准备第一个客户应用</h2>
<p>NEMU作为一个模拟的计算机系统，主要的功能就是运行客户程序。我们可以从头观察NEMU的项目框架，来查看，NEMU是怎么进行初始化，并且将客户应用加载到内存中运行的。</p>
<p>首先是进入<code>nemu-main.c</code>中，可以看到形如<code>CONFIG_XX</code>的宏定义字样，我们可以在<code>autoconf.h</code>中找到相关的宏定义，根据部分宏的配置，可能会编译时忽略或是开启部分功能。</p>
<p>NEMU的框架代码主要通过函数进行包装，进入<code>nemu-main.c</code>中，首先执行的是<code>init_moniter()</code>,步进程序可以看到monitor的初始化过程，对于<code>mem</code>和<code>seed</code>都是简单的设置，可以之间看源代码</p>
<p>其中<code>init_isa()</code>的代码比较特殊，也比较关键：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* Set the initial program counter. */</span></span><br><span class="line">  cpu.pc = RESET_VECTOR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The zero register is always 0. */</span></span><br><span class="line">  cpu.gpr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_isa</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* Load built-in image. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(guest_to_host(RESET_VECTOR), img, <span class="keyword">sizeof</span>(img));</span><br><span class="line">  <span class="comment">/* Initialize this virtual computer system. */</span></span><br><span class="line">  restart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先将<code>img</code>（这里是初始程序，加载到主机的起始地址），具体的内容可以在<code>isa\risc32\init.c</code>中查看看，<code>restart()</code>的作用是将CPU复位成初始状态，这里主要是将pc置0，并将riscv的第一个寄存器设置为0，作为零寄存器。</p>
<p>通过查看<code>memory</code>目录我们可以知道，NEMU为客户计算机提供了<code>128MB</code>的物理内存，同时我们将客户程序读入到内存的固定内存位置<code>RESET_VECTOR</code>。</p>
<p>在这里我们需要分清楚主机和客户机的区别，主机就是运行NEMU的物理计算机，客户机就是在NEMU上运行的计算机程序。我们使用<code>guest_to_host()</code>和<code>host_to_guest()</code>进行主机和客户机地址的相互转换。<code>guest_to_host()</code>将我们在客户机的物理地址转换成在NEMU内存中的数组地址，<code>host_to_guest()</code>则将内存中的数组地址转换成客户机的物理地址。</p>
<p>我们可以在<code>include\memory\paddr.h</code>中找到对<code>RESET_VECTOR</code>的定义，由于这里我们没有设置<code>CONFIG_PC_RESET_OFFSET</code>所以内存的加载从<code>pmem[0]</code>开始。</p>
<p>接着程序调用<code>load_image()</code>用于向内存中加载程序，如果没有给出img参数，则NEMU使用内置的初始化程序，我们可以在<code>isa/risc32/init.c</code>中看到。</p>
<p>然后程序调用<code>welcome()</code>,我们编译运行时看到的信息就是来自这里。</p>
<h2 id="运行第一个客户运用">运行第一个客户运用</h2>
<p>在monitor完成初始化之后，<code>nemu-main.c</code>会进入下一个程序<code>engine_start</code>中的<code>sdb_mainloop()</code>，并输出提示符指示输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nemu)</span><br></pre></td></tr></table></figure>
<p>在<code>src\monitor\sdb\sdb.c</code>中，程序预设了一个<code>cnd_table</code>，设置在sdb中支持的指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd_table [] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display information about all supported commands&quot;</span>, cmd_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于参数的处理和选择执行可以通过阅读<code>sdb_mainloop</code>理解，这里我们主要将注意力放到<code>cmd_c()</code>的调用函数<code>cpu_exec()</code>上，它是我们模拟器运行程序的cpu执行的核心，这里传入了一个参数<code>-1</code>但由于是<code>uint64_t</code>表示，所以实际上的数值是<code>0xFFFFFFFFFFFFFFFF</code>，即持续执行，这里我们进一步的步入追踪，最终查看到<code>exec_once()</code>，他负责将pc设置成下一条指令执行的位置。</p>
<p>现在NEMU会不断的进行执行，首先它执行的便是我们的内置程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> img [] = &#123;</span><br><span class="line">  <span class="number">0x00000297</span>,  <span class="comment">// auipc t0,0</span></span><br><span class="line">  <span class="number">0x00028823</span>,  <span class="comment">// sb  zero,16(t0)</span></span><br><span class="line">  <span class="number">0x0102c503</span>,  <span class="comment">// lbu a0,16(t0)</span></span><br><span class="line">  <span class="number">0x00100073</span>,  <span class="comment">// ebreak (used as nemu_trap)</span></span><br><span class="line">  <span class="number">0xdeadbeef</span>,  <span class="comment">// some data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在NEMU中我们将<code>ebreak</code>的语义设置成，接受a0的数据作为退出状态。同时为了检测客户程序的退出，设置了以下三种状态：</p>
<ul>
<li><code>HIT GOOD TRAP</code> - 客户程序正确地结束执行</li>
<li><code>HIT BAD TRAP</code> - 客户程序错误地结束执行</li>
<li><code>ABORT</code> - 客户程序意外终止, 并未结束执行</li>
</ul>
<p>我们在nemu中使用<code>c</code>就可以获得以下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nemu: HIT GOOD TRAP at pc = 0x8000000c</span><br></pre></td></tr></table></figure>
<p>即nemu的客户程序在<code>pc = 0x8000000c</code>处成功退出。退出<code>cpu_exec()</code>之后，我们再使用<code>q</code>退出nemu程序。</p>
<h2 id="优美的退出">优美的退出</h2>
<p>我们运行NEMU后直接使用<code>q</code>会产生报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ylin@Ylin:~/ics2025/nemu$ make run</span><br><span class="line">/home/ylin/ics2025/nemu/build/riscv32-nemu-interpreter --log=/home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/utils/log.c:30 init_log] Log is written to /home/ylin/ics2025/nemu/build/nemu-log.txt</span><br><span class="line">[src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff]</span><br><span class="line">[src/monitor/monitor.c:51 load_img] No image is given. Use the default build-in image.</span><br><span class="line">[src/monitor/monitor.c:28 welcome] Trace: ON</span><br><span class="line">[src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig</span><br><span class="line">[src/monitor/monitor.c:32 welcome] Build time: 20:11:21, Sep 26 2025</span><br><span class="line">Welcome to riscv32-NEMU!</span><br><span class="line">For help, type &quot;help&quot;</span><br><span class="line">(nemu) q</span><br><span class="line">make: *** [/home/ylin/ics2025/nemu/scripts/native.mk:38: run] Error 1</span><br></pre></td></tr></table></figure>
<p>我们需要找出原因并解决这个问题。</p>
<p>这是<code>cmd_q</code>的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们输入q后会因为<code>sdb_mainloop</code>的判断逻辑退出到<code>nemu_main</code>执行<code>is_exit_status_bad()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_exit_status_bad</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.halt_ret == <span class="number">0</span>) ||</span><br><span class="line">    (nemu_state.state == NEMU_QUIT);</span><br><span class="line">  <span class="keyword">return</span> !good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会检测nemu的状态而决定以什么情况退出，我们之前的报错则是因为，我们没有为NEMU设置任何状态，NEMU以默认状态退出，因此返回错误。想要优雅的退出，我们只需要再退出前设置好NEMU的状态。因此我们对<code>cmd_q()</code>函数进行重写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  nemu_state.state = NEMU_QUIT;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">247k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:57</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
