<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta name="description" content="总是听到诸如页表，分页机制一类的词汇，听起来让人感到十分的复杂。实际上这些都是涉及到虚拟内存相关的只是。一直以来对这一部分的知识都是望而生畏，现在好好来理解一下它： 物理和虚拟寻址 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址，物理地址从0开始依次设置。这是最简单自然的结构，我们把CPU以这个结构用来访问地址的方式称为物理寻址。早期的计算机和">
<meta property="og:type" content="article">
<meta property="og:title" content="79:虚拟内存(1)">
<meta property="og:url" content="http://example.com/2025/08/27/79-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:description" content="总是听到诸如页表，分页机制一类的词汇，听起来让人感到十分的复杂。实际上这些都是涉及到虚拟内存相关的只是。一直以来对这一部分的知识都是望而生畏，现在好好来理解一下它： 物理和虚拟寻址 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址，物理地址从0开始依次设置。这是最简单自然的结构，我们把CPU以这个结构用来访问地址的方式称为物理寻址。早期的计算机和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/nIDLxybfH6TXhq4.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/LNcFv8UT5wEyRVn.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/E3GubmVq1HlvFWY.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/eXsFdkTt5cBQ68D.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/l57NgTqRbkWKtz3.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/06/mxfuyZFswWo1kbQ.png">
<meta property="og:image" content="https://s2.loli.net/2025/08/28/MYLDidmhXo6Kgtc.png">
<meta property="article:published_time" content="2025-08-27T08:50:33.000Z">
<meta property="article:modified_time" content="2025-08-28T03:14:28.586Z">
<meta property="article:author" content="Ylin">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/08/28/nIDLxybfH6TXhq4.png">

<link rel="canonical" href="http://example.com/2025/08/27/79-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>79:虚拟内存(1) | Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/27/79-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          79:虚拟内存(1)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-27 16:50:33" itemprop="dateCreated datePublished" datetime="2025-08-27T16:50:33+08:00">2025-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-28 11:14:28" itemprop="dateModified" datetime="2025-08-28T11:14:28+08:00">2025-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">虚拟内存</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>总是听到诸如页表，分页机制一类的词汇，听起来让人感到十分的复杂。实际上这些都是涉及到虚拟内存相关的只是。一直以来对这一部分的知识都是望而生畏，现在好好来理解一下它：</p>
<h2 id="物理和虚拟寻址">物理和虚拟寻址</h2>
<p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的<strong>物理地址</strong>，物理地址从0开始依次设置。这是最简单自然的结构，我们把CPU以这个结构用来访问地址的方式称为<strong>物理寻址</strong>。早期的计算机和一些数字处理器和嵌入式设备仍然使用这种方式，</p>
<p>现代处理器则是使用一种被称为<strong>虚拟寻址</strong>的方式来进行寻址。使用虚拟寻址，CPU会生成一个虚拟地址(VA)来访问主存，VA被送到内存之前会先转换为适当的物理地址，这个过程叫做<strong>地址翻译</strong>。有一个专门的硬件单元来完成这个任务——<strong>内存管理单元</strong>(MMU)。原理是利用存放在主存中的查询表来动态翻译虚拟地址，这个表中的内容由操作系统管理。</p>
<h2 id="地址空间">地址空间</h2>
<p>地址空间是非负整数地址的有序集合。如果地址空间中的整数时连续的，我们说它是一个<strong>线性地址空间</strong>，我们假定之后用到的所有地址空间都是线性的。在一个带虚拟内存的系统中，CPU从有一个有N=2^n个地址的地址空间中生成虚拟地址，则这个地址口空间称为<strong>虚拟地址空间</strong>。</p>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。对于一个包含N=2^n个地址的虚拟地址空间，我们可以将其叫做为一个n位的地址空间。一个系统还带有一个物理地址空间，对应于系统中的物理内存的M个字节。</p>
<p>地址空间的概念实际上区分了两个概念：</p>
<ul>
<li>数据对象(字节)</li>
<li>属性(地址)</li>
</ul>
<p>所以我们应该意识到数据对象实际上可以有多个地址，只不过每一个地址都选自一个不同的地址空间，这就是我们虚拟空间所用到的概念。例如主存中的每一个字节都有有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="虚拟内存作为缓存工具">虚拟内存作为缓存工具</h2>
<p>虚拟地址实际上就是一个由存放在磁盘上的N个连续的字节大小的单元组成数组，每一个字节都有着一个对应的虚拟地址，作为对这个数组的索引。磁盘上数组的内容被缓存在主存中。和其他的缓存一样，磁盘上的数据被分隔成块，这些快作为磁盘和主存之间的传输单元。</p>
<p>VM系统将虚拟内存分割为<strong>虚拟页</strong>的大小固定的块，每个虚拟页的大小为<code>P=2^p</code>字节。物理内存也被分隔为同样大小的<strong>物理页</strong>，也称页帧。</p>
<p>在任意时刻，虚拟页处于以下中的一种状态：</p>
<ul>
<li><strong>未分配：</strong>VM系统还没有创建的页。未分配的块不会有任何数据关联，不占用磁盘空间</li>
<li><strong>已缓存：</strong>当前已缓存在物理内存中的已分配页</li>
<li><strong>已分配：</strong>未缓存在物理内存中的已分配页</li>
</ul>
<h3 id="页表">页表</h3>
<p>在这里需要用到DRAM和SRAM的关系，可以查看存储器层次架构进行回顾。</p>
<p>和任何缓存一样，VM系统需要要一种方法来判定一个虚拟页是否被缓存在物理内存中的某个地方。如果命中，怎么确定这个虚拟页被存放在那个物理页中。如果不命中，系统需要判断虚拟页存放在磁盘的哪个位置，并在物理内存中选择有一个牺牲页，将虚拟页复制到这里，替换这个牺牲页。</p>
<p>通过操作系统软件、MMU和存放在物理内存中的页表，软硬联合，从而将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为一个物理地址的时候，都会读取页表。操作系统则负责维护页表中的内容，在磁盘和主存间来回传送页。页表的结构大致如下：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/nIDLxybfH6TXhq4.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>我们认识一下页表的基本数据结构，页表就是一个页表条目(PTE)的数组。虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE（也就是说PTE的大小是固定的）。根据上面的这个简化模型，每个PTE实际上是由一个有效位和一个n位地址字段组成的：</p>
<ul>
<li>有效位表明该虚拟也当前是否被缓存在主存中。</li>
<li>n位地址字段，在有效位被设置的情况下，表示主存中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么这个地址指向该虚拟页在磁盘中的起始位置。</li>
</ul>
<p>在上图中我们就可以看到虚拟页的三种状态：未分配、未缓存、已缓存。</p>
<h3 id="页命中">页命中</h3>
<p>当CPU想要读取包含在VP2中的虚拟内存的一个字时，地址翻译硬件会将虚拟地址作为一个索引来定位PTE2，然后再页表（内存）中读取它。因为设置了有效位，地址翻译硬件就会知道VP2被缓存在内存中，然后就会使用PTE中存储的物理内存地址，构造出这个字的物理地址。</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/LNcFv8UT5wEyRVn.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="缺页">缺页</h3>
<p>缺页实际上就是缓存不命中，同上图。CPU引用了VP3中的一个字，地址翻译硬件根据有效位发现VP3并没有被缓存在内存中，于是触发一个缺页异常。这个异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。程序将牺牲页复制回硬盘中，并将VP3覆盖牺牲页。并修改页表中它们的状态。然后返回，并将导致缺页的虚拟地址重新发送给地址翻译硬件，此时页命中，可以被正确处理：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/E3GubmVq1HlvFWY.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个在磁盘和内存之间传送页的活动叫做<strong>页面调度</strong>，仅在不命中的情况下才进行调度的策略是<strong>按需页面调度</strong>，我们之后都会使用这个策略。</p>
<h3 id="分配页面">分配页面</h3>
<figure>
<img src="https://s2.loli.net/2025/08/28/eXsFdkTt5cBQ68D.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>这个过程展示了当操作系统分配一个新的虚拟内存页时，对我们的示例页表产生的影响。在这个过程中，系统在磁盘上创建了一个空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p>
<h3 id="局部性分析">局部性分析</h3>
<p>对于虚拟内存的策略，我们可能会认为这是一个效率极低的方案，因为它的不命中惩罚很大。但是实际上，它有着良好的<strong>局部性</strong>。局部性保证了，在任意时刻中，程序将趋于一个较小的活动页面上工作，例如空间局部性，较大的页空间确保了很好的空间局部性，因为对于数据结构，程序是按序访问的；对于时间局部性，一段内存往往会被反复利用，所以有着良好的时间局部性。</p>
<p>当然如果出现了工作集大小超出内存大小的情况时，程序可能会发生<strong>抖动</strong>，页面会不停的换进换出，带来严重的不命中开销。</p>
<h2 id="虚拟内存作为内存管理的工具">虚拟内存作为内存管理的工具</h2>
<p>虚拟内存不仅有着很好的缓存性能，同时它也很好的简化了内存管理，为我们提供了一个很好的内存保护机制。</p>
<p>实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟空间，下图很好的展示了这一点：</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/l57NgTqRbkWKtz3.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>注意，这里可以看到多个虚拟页面实际上是可以映射到同一个共享物理页面上。</p>
<p>通过按需页面调度和独立的虚拟地址空间的结合，系统对内存的使用和管理被极大的简化，VM系统简化了链接和加载、代码和数据共享、以及应用程序的内存分配…</p>
<h3 id="简化链接">简化链接</h3>
<p>独立的地址空间也允许每个进程的内存映像使用相同的基本格式，而不用考虑代码和数据实际上被存储在哪里。这样的一致性简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p>
<figure>
<img src="https://s2.loli.net/2025/08/06/mxfuyZFswWo1kbQ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="简化加载">简化加载</h3>
<p>虚拟内存简化了向内存中加载可执行文件和共享对象文件的过程。要把目标文件中<code>.text</code>和<code>.data</code>节加载到一个新创建的进程中，Linux加载器会为代码段和数据段分配虚拟页，然后将其标为无效的（即未缓存）。而不是将其进行缓存，只有当页被引用到时，虚拟内存会按需调度这些页面。</p>
<p>将一组连续的虚拟页映射到任意一个文件的任意位置的表示法叫做<strong>内存映射</strong>我们会在之后涉及这些内容。</p>
<h3 id="简化共享">简化共享</h3>
<p>一般而言，每个进程都有自己私有的代码，数据，堆栈等区域，这个其他进程是不共享的。操作系统为每个进程提供页表，将相应的虚拟页映射到不同的物理页面。也就是说，对于不同进程来说，尽管是同一个虚拟地址，但是实际上映射的是不同的物理地址。极大程度上简化了进程间私有的问题。</p>
<p>当然有时候进程间有也需要共享代码和数据，例如每个进程都调用相同的操作系统内核代码，操作系统会将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是为每个进程都分配一个副本。</p>
<h3 id="简化内存分配">简化内存分配</h3>
<p>虚拟内存为用户进程提供了一个简单的分配额外内存的机制。当一个运行在用户进程的程序要求有一个额外的堆空间时，操作系统只需要分配适当的连续的虚拟内存页面，并将其映射到物理内存中的物理页面就行了。通过页表，操作系统也不用分配连续的物理页。使得页面可以随机的分布在物理内存中，提高了碎片空间的可用性。</p>
<h2 id="虚拟内存作为内存保护的工具">虚拟内存作为内存保护的工具</h2>
<p>操作系统需要有手段来控制对内存系统的访问，不应该允许用户进程对其只读代码段进行修改，也不应该允许它修改内核中的代码和数据结构，不应该允许它读写其他进程的私有内存或是修改和其他进程共享的虚拟原页面。而虚拟内存能够很好的实现这个机制：</p>
<p>当每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，我们可以通过有效位来判断这个页面的状态。我们也可以通过添加额外的许可页来控制对一个虚拟页面内容的访问。</p>
<figure>
<img src="https://s2.loli.net/2025/08/28/MYLDidmhXo6Kgtc.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>例如图中的，SUP位表示进程是否必须在内核模式下才能访问此页。READ和WRITE位则控制对原页面的读写访问。不同进程的页表中对同一个页的访问权是不同的，以此可以实现对进程内存访问的控制。</p>
<p>如果一条指令违反了这些许可条件，那么CPU就会触发保护故障，将控制传递给异常处理程序。LInux
Shell一般将这个异常报告为<code>Segmentation fault</code></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/26/78-%E5%88%9D%E7%AA%A5%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-4/" rel="prev" title="78:初窥深度学习(4)">
      <i class="fa fa-chevron-left"></i> 78:初窥深度学习(4)
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/28/80-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-2/" rel="next" title="80:虚拟内存(2)">
      80:虚拟内存(2) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="nav-number">1.</span> <span class="nav-text">物理和虚拟寻址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.</span> <span class="nav-text">地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">虚拟内存作为缓存工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%91%BD%E4%B8%AD"><span class="nav-number">3.2.</span> <span class="nav-text">页命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5"><span class="nav-number">3.3.</span> <span class="nav-text">缺页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E9%A1%B5%E9%9D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">分配页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">3.5.</span> <span class="nav-text">局部性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text">虚拟内存作为内存管理的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E9%93%BE%E6%8E%A5"><span class="nav-number">4.1.</span> <span class="nav-text">简化链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.2.</span> <span class="nav-text">简化加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%85%B1%E4%BA%AB"><span class="nav-number">4.3.</span> <span class="nav-text">简化共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">4.4.</span> <span class="nav-text">简化内存分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">5.</span> <span class="nav-text">虚拟内存作为内存保护的工具</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">238k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:37</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
