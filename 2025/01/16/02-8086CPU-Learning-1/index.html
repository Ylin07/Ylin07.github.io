<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    02:8086CPU_Learning(1) 丨
    

    Ylin&#39;s Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Ylin&#39;s Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">02:8086CPU_Learning(1)</div>
  <div class="post-meta">
    <div class="date">2025 一月 16日</div>
    <div class="tags">
      
      <div class="tag-item">8086CPU</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>搞了那么久的博客现在终于可以开始汇编语言的学习了</p>
<span id="more"></span>

<p>这里我用的教材是王爽老师的《汇编语言》，使用的环境是基于DOSBOX的模拟DOS环境</p>
<p>接下来开始正式的学习</p>
<p>今天的内容是 <strong>寄存器</strong>  和 <strong>实验一</strong></p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>8086CPU共有14个寄存器，每个寄存器都有对应的名称，他们分别是：</p>
<p><code>AX</code>，<code>BX</code>，<code>CX</code>，<code>DX</code>，<code>SI</code>，<code>DI</code>，<code>SP</code>，<code>BP</code>，<code>IP</code>，<code>CS</code>，<code>SS</code>，<code>DS</code>，<code>ES</code>，<code>PSW</code></p>
<p>我们不一次性的对其进行研究，我们在后续对这些寄存器的作用进行一一的讲解</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><blockquote>
<p>AX，BX，CX，DX 这四个寄存器用来放一般性的数据，所以被称为通用寄存器</p>
</blockquote>
<p>8086的所有寄存器都是16位的，可以存放两个字节</p>
<p>为了保证CPU的兼容性，这四个通用寄存器都可以被分为两个可独立使用的八位寄存器：</p>
<ul>
<li>AX &#x3D; AH + AL</li>
<li>BX &#x3D; BH + BL</li>
<li>CX &#x3D; CH + CL</li>
<li>DX &#x3D; DH + DL</li>
</ul>
<p>XL 指的是 XX寄存器的低八位(0-7位)，XH 指的是 XX 寄存器的高八位(8-15位)</p>
<h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><p>出于对兼容性的考虑，8086CPU可以对以下两种尺寸的数据进行操作：</p>
<ul>
<li>字节(Byte)：一个字节由八位组成，可以存储在八位寄存器中</li>
<li>字(Word): 一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和地位字节</li>
</ul>
<p>一个字可以存在一个16位寄存器中，那么这个字的高位字节和低位字节便存储在这个寄存器的高8位寄存器和低8位寄存器中</p>
<h2 id="基本的汇编指令"><a href="#基本的汇编指令" class="headerlink" title="基本的汇编指令"></a>基本的汇编指令</h2><blockquote>
<p>介绍 mov 与 add</p>
</blockquote>
<p>这里我们用几个例子来展示他们的用法</p>
<p>MOV:</p>
<ul>
<li>mov ax,18 -&gt; 将18送入寄存器ax中</li>
<li>mov ah,15 -&gt; 将15送入寄存器ah中</li>
<li>mov ax,bx -&gt; 将寄存器bx中的值送入寄存器ax</li>
</ul>
<p>ADD：</p>
<ul>
<li>add ax,8 -&gt; 将寄存器ax中的值加上8</li>
<li>add ax,bx -&gt; 将ax和bx的值相加，并将结果保存在ax中</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li><p>十六位寄存器的溢出：</p>
<p> 当ax &#x3D; bx &#x3D; 8226H时，执行 add ax,bx 后ax &#x3D; ?</p>
<p> ax本来应该等于 1044CH，但是由于最高位溢出了，所以ax &#x3D; 044CH</p>
</li>
<li><p>八位寄存器的溢出：</p>
<p> 当 ax &#x3D; 00C5H时，执行 add al,93H 后al &#x3D; ?</p>
<p> ax本来应该等于 0158H，但是由于最高位溢出了，所以ax &#x3D; 0058H，al &#x3D; 58H</p>
</li>
</ol>
<h2 id="8086给出物理地址的方法"><a href="#8086给出物理地址的方法" class="headerlink" title="8086给出物理地址的方法"></a>8086给出物理地址的方法</h2><blockquote>
<p>所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间都有唯一的地址，我们将这个唯一的地址称为物理地址。在CPU发出物理地址之前，必须要在内部先生成这个地址</p>
</blockquote>
<p>8086CPU有20位地址总线，最多可以传20位地址，达到1MB的寻址能力</p>
<p>可是8086是16位机器，按道理只能做到16位的64KB寻址，是怎么做到的呢？</p>
<p>这是因为我们使用了一种通过两个十六位地址合成一个二十位地址的方法</p>
<p>当8086CPU要读写内存时：</p>
<ul>
<li>CPU相关部件提供两个地址：一个是16位段地址，一个是16位偏移地址</li>
<li>这两个地址通过内部总线传输到地址加法器合成为一个20位的物理地址</li>
<li>将这20位的物理地址传输到地址总线上</li>
</ul>
<p>在这里地址加法器通过 <strong>物理地址 &#x3D; 段地址*16 + 偏移地址</strong> 生成20位的物理地址</p>
<p>**注意：*<em>段地址</em>16 本质上就是将段地址左移四位，将地址XXXXH变为XXXX0H</p>
<h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><blockquote>
<p>在根据编程需要时我们将若干连续的内存单元看作一个段</p>
</blockquote>
<p>先讲解一下<strong>段</strong>的含义，在这里，段并不意味着内存被分为一段一段，而是我们可以通过分段的方式来管理内存</p>
<p>段的划分来源于CPU ，由于我们使用  *<em>物理地址 &#x3D; 段地址</em>16 + 偏移地址 ** 的方式给出内存的物理地址</p>
<p>所以我们用 段地址*16 定位段的起始地址(基础地址),用偏移地址定位段中的内存单元</p>
<p>我们需要注意：</p>
<ul>
<li>段地址*16,即一个段的起始地址一定是16的倍数</li>
<li>偏移地址为16位,即其最大寻址位置为64KB,所以说一个段的最大长度为64KB</li>
</ul>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>8086 有四个段寄存器CS、DS、SS、ES，这里我们先只看CS</p>
</blockquote>
<p>其中CS，IP 是8086CPU中最重要的两个寄存器，他们指示了CPU当前要读取的指令的地址</p>
<p>CS 为代码段寄存器，IP为指令指针寄存器，我们可以这样理解，在8086机中任意时刻，CPU将CS:IP指向的内容当作指令执行</p>
<p>我们可以把8086CPU的工作过程表述为：</p>
<ol>
<li>从 CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区</li>
<li>IP &#x3D; IP + 所读取的指令的长度，从而指向下一条指令</li>
<li>执行指令，并返回步骤(1)，重复这个过程</li>
</ol>
<p>我们可以这么说，内存中的一段信息被CPU执行过，那么他所在的内存单元一定被CS:IP指向过</p>
<h3 id="修改CS、IP指令"><a href="#修改CS、IP指令" class="headerlink" title="修改CS、IP指令"></a>修改CS、IP指令</h3><p>8086CPU大部分的寄存器的值都可以通过mov来改变，但是mov不能用于修改CS:IP 的值，mov被称为传送指令</p>
<p>能够修改CS:IP的值的指令通称为转移指令，如简单的jmp指令</p>
<ul>
<li>若想同时修改CS、IP的值，我们可以使用指令 <strong>jmp 段地址：偏移地址</strong> 的指令完成</li>
<li>若想修改仅IP的内容，我们可以使用指令 <strong>jmp 某一合法的寄存器</strong> 的指令完成，这一步可以抽象理解为 <code>mov IP 该寄存器中的值 </code></li>
</ul>
<h3 id="第一条指令"><a href="#第一条指令" class="headerlink" title="第一条指令"></a>第一条指令</h3><p>在8086CPU加电启动或者复位后(即刚开始工作时),CS和IP被设置为 <code>CS=FFFFH ， IP=0000H</code></p>
<p>即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元存放着8086PC机开机后执行的第一条命令</p>
<h1 id="实验一：查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验一：查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验一：查看CPU和内存，用机器指令和汇编指令编程"></a>实验一：查看CPU和内存，用机器指令和汇编指令编程</h1><h2 id="使用DEBUG"><a href="#使用DEBUG" class="headerlink" title="使用DEBUG"></a>使用DEBUG</h2><blockquote>
<p>DEBUG 是 DOS，Windows 都提供的实模式（8086方式）程序的调试工具。可以用它查看CPU的各种寄存器中的内容、内存使用的情况和在机器码级跟踪程序的运行</p>
</blockquote>
<p>我们需要用到以下的Debug功能：</p>
<ul>
<li>R：查看、改变CPU寄存器的内容</li>
<li>D：查看内存中的内容</li>
<li>E：改写内存中的内容</li>
<li>U：将内存中的机器指令翻译成汇编指令</li>
<li>T：执行一条机器指令</li>
<li>A：以汇编指令的格式在内存中写入一条机器指令</li>
</ul>
<h2 id="R命令"><a href="#R命令" class="headerlink" title="R命令"></a>R命令</h2><pre><code class="highlight cmd">debug -r</code></pre>

<p>开启了debug的R模式</p>
<p><img src="https://s2.loli.net/2025/01/16/7hjvpH38KeAyswJ.png" alt="image.png"></p>
<p>我们可以看到一个用法 <strong>-r 寄存器名称</strong> 可以修改指定寄存器的值</p>
<h2 id="D命令"><a href="#D命令" class="headerlink" title="D命令"></a>D命令</h2><pre><code class="highlight cmd">debug -d</code></pre>

<p><img src="https://s2.loli.net/2025/01/16/IXTCdiu9c5HQpbA.png"></p>
<p>我们可以看出其显示的三部分：</p>
<ul>
<li>左边部分是每行的起始地址</li>
<li>中间部分是从指定地址开始的128个内存单元的内容，注意每行中间的”-“，这是用来区分每行的前八个字节和后八个字节的标志</li>
<li>右边是每个内存单元中的数据对应可显示的ASCII字符，如果不可显示，则用”.”替代</li>
</ul>
<p>其有以下三种用法：</p>
<ul>
<li>一是 <strong>d 段地址：偏移地址</strong> 指定地址CS:IP，对其进行128字节的查看</li>
<li>二是 <strong>d 段地址 ：偏移地址 结尾偏移地址</strong>  可以指定查看的范围 即从偏移地址到结尾偏移地址之间的内存空间</li>
<li>三是 <strong>d</strong> 直接查看，将列出Debug预设的地址处的内容</li>
</ul>
<h2 id="E命令"><a href="#E命令" class="headerlink" title="E命令"></a>E命令</h2><pre><code class="highlight cmd">debug -e</code></pre>

<p><img src="https://s2.loli.net/2025/01/16/x4iRGcMVPhC3dyK.png" alt="image.png"></p>
<p>我们可以通过E指令来进行内存空间的改写，其操作如下：</p>
<p>**e 起始地址 数据1 数据2 数据3 ……**这个操作对起始地址之后的内存空间进行覆盖</p>
<p>其中数据可以是字符，也可以是数值，甚至是字符串</p>
<p>或者我们可以使用提问式的方法来进行修改</p>
<p><img src="https://s2.loli.net/2025/01/16/GKvUefLSM9R1yhn.png" alt="image.png"></p>
<p>有以下步骤：</p>
<ul>
<li>首先，输入 <strong>e 起始地址</strong> ，按Enter</li>
<li>我们从起始地址的第一个值开始，“.”之前的数值是该单元的原数值，之后则是要修改的数值</li>
<li>我们使用空格跳过当前单元（无论是否修改），按下Enter表示结束修改</li>
</ul>
<h2 id="U指令"><a href="#U指令" class="headerlink" title="U指令"></a>U指令</h2><p>我们使用E指令写入以下的一段汲取嘛，然后用U指令对其内容翻译为汇编指令</p>
<pre><code class="highlight assembly">b80100		mov ax,0001
b90200		mov cx,0002
01c8  		add ax,cx</code></pre>

<p><img src="https://s2.loli.net/2025/01/17/kVnuXs5LMGiAKrp.png"></p>
<p>我们看到D命令的输出可以分为三部分：</p>
<ul>
<li>左边部分为指令占用的内存单元的起始地址和对应的机器码</li>
<li>右边部分为翻译后的汇编语言</li>
</ul>
<h2 id="T命令"><a href="#T命令" class="headerlink" title="T命令"></a>T命令</h2><p>现在我们尝试执行我们写的汇编语言，使用T命令执行一条或多条汇编指令</p>
<p>首先我们需要修改CS:IP 指向的命令 然后开始执行</p>
<p><img src="https://s2.loli.net/2025/01/17/jbu8Mz6gtUaclws.png" alt="image.png"></p>
<p>我们可以看到执行结果符合我们呢的期望</p>
<h2 id="A命令"><a href="#A命令" class="headerlink" title="A命令"></a>A命令</h2><p>前面我们使用E命令写入机器指令，这样很不方便，所以我们使用A指令直接写入指令</p>
<p>其效果如下：</p>
<p><img src="https://s2.loli.net/2025/01/17/2ZDof61t9vcaewH.png" alt="image.png"></p>
<p>我们看到再给出起始地址后可以直接进行编辑</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © Ylin</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>