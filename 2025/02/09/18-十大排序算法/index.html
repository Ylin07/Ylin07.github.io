<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>


  <meta name="description" content="用Python感受十大排序算法，首先我们对这十个排序进行分类 1234567891011121314151617十大排序算法：	非线性时间比较类：		交换类：			冒泡排序			快速排序		插入类：			直接插入排序			希尔排序		选择类：			简单选择排序			堆排序		归并类#：			归并排序	线性时间排序：		计数排序		桶排序		基数排序 非线性排序 冒泡排序  最经典的排序算">
<meta property="og:type" content="article">
<meta property="og:title" content="18:十大排序算法">
<meta property="og:url" content="http://example.com/2025/02/09/18-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Ylin&#39;s Blog">
<meta property="og:description" content="用Python感受十大排序算法，首先我们对这十个排序进行分类 1234567891011121314151617十大排序算法：	非线性时间比较类：		交换类：			冒泡排序			快速排序		插入类：			直接插入排序			希尔排序		选择类：			简单选择排序			堆排序		归并类#：			归并排序	线性时间排序：		计数排序		桶排序		基数排序 非线性排序 冒泡排序  最经典的排序算">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-09T10:48:33.000Z">
<meta property="article:modified_time" content="2025-04-18T05:16:43.902Z">
<meta property="article:author" content="Ylin">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/02/09/18-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>18:十大排序算法 | Ylin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ylin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/09/18-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Ylin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ylin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          18:十大排序算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-09 18:48:33" itemprop="dateCreated datePublished" datetime="2025-02-09T18:48:33+08:00">2025-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-18 13:16:43" itemprop="dateModified" datetime="2025-04-18T13:16:43+08:00">2025-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>用Python感受十大排序算法，首先我们对这十个排序进行分类</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">十大排序算法：</span><br><span class="line">	非线性时间比较类：</span><br><span class="line">		交换类：</span><br><span class="line">			冒泡排序</span><br><span class="line">			快速排序</span><br><span class="line">		插入类：</span><br><span class="line">			直接插入排序</span><br><span class="line">			希尔排序</span><br><span class="line">		选择类：</span><br><span class="line">			简单选择排序</span><br><span class="line">			堆排序</span><br><span class="line">		归并类#：</span><br><span class="line">			归并排序</span><br><span class="line">	线性时间排序：</span><br><span class="line">		计数排序</span><br><span class="line">		桶排序</span><br><span class="line">		基数排序</span><br></pre></td></tr></table></figure>
<h1 id="非线性排序">非线性排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<blockquote>
<p>最经典的排序算法</p>
</blockquote>
<h3 id="算法思想">算法思想</h3>
<p>将数据中的每个数与相邻的数进行比较并交换，大数往上冒，小数向下沉。将每个数遍历排序一遍</p>
<h3 id="算法步骤">算法步骤</h3>
<ul>
<li>取第一个数，依次与下一个数进行排序，然后与小于(或大于)自己的数交换位置直到最后一个数</li>
<li>如果未发生位置交换，说明数据有序，排序结束。如果发生了位置交换重复<strong>上一步</strong></li>
</ul>
<h3 id="算法分析">算法分析</h3>
<p>时间复杂度：</p>
<ul>
<li>当排序为正序时，只需要排序一次，比较n-1次，时间复杂度为<code>O(n)</code>,这是最优情况</li>
<li>当排序为逆序时，需要进行n-1次遍历，每次比较n-i次，时间复杂度为<code>O(n^2)</code>，这是最差情况</li>
</ul>
<h3 id="算法代码">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 冒泡排序进行的次数n-1,每次遍历确定一个最大值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># j为进行比较的数据下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>-i):</span><br><span class="line">            <span class="comment"># 若下标为j的数据大于其右相邻数据</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 二者交换数据</span></span><br><span class="line">                nums[j],nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>],nums[j]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序</h2>
<blockquote>
<p>也称为分区交换排序，它采用了分治思想，是冒泡排序的改良版。冒泡排序只能比较和交换两个数据，但是快速排序可以交换和比较两个分区，其效率更高</p>
</blockquote>
<h3 id="算法思想-1">算法思想</h3>
<p>选取一个基准值，将待排序数据分为左（小于基准值）和右（大于基准值）两个区间，然后对两个分区的数据进行相同的操作，最终得到一组有序数据</p>
<h3 id="算法步骤-1">算法步骤</h3>
<ul>
<li>选取待排序数据的第一个数值作为分区标准</li>
<li>遍历数组，将小于标准的放在左边，大于标准的放在右边，则中间为标准数</li>
<li>对标准数左右两个子序列分别进行（1）和（2）的操作</li>
<li>当左右序列的长度均小于等于1时，排序完成</li>
</ul>
<h3 id="算法分析-1">算法分析</h3>
<p>时间复杂度</p>
<ul>
<li>如果选取的标准数位待排序数组的中位数，即每次划分后的左右子序列长度基本一致，时间复杂度为
<code>O(n*log_2(n))</code>,为最好情况</li>
<li>如果待排序数组是逆序，且第一趟选取的标准数位待排序数组的最大值，经过n-1次比较后，得到一个n-1个元素的左子序列；然后第二趟选取的标准数仍然是最大值,…依次类推，最终的时间复杂度为
<code>O(n^2)</code>，这是最坏的情况</li>
</ul>
<h3 id="算法代码-1">算法代码</h3>
<p>学习版：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array)&lt;=<span class="number">1</span>:			<span class="comment"># 当子序列长度&lt;=1</span></span><br><span class="line">        <span class="keyword">return</span> array			<span class="comment"># 排序完成,停止递归</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        small = []				<span class="comment"># 由所有小于基准值的元素组成的子数组</span></span><br><span class="line">        equal = []				<span class="comment"># 包括基准值在内并且和基准相等的元素</span></span><br><span class="line">        large = []				<span class="comment"># 由所有大于基准值的元素组成的子数组</span></span><br><span class="line">        reference = array[<span class="number">0</span>]	 <span class="comment"># 选择第一个数作为基准值</span></span><br><span class="line">        <span class="comment"># 遍历array中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> array:</span><br><span class="line">            <span class="comment"># 当前元素小于基准值时</span></span><br><span class="line">            <span class="keyword">if</span> s &lt; reference:</span><br><span class="line">                <span class="comment"># 当前元素插入small</span></span><br><span class="line">                small.append(s)</span><br><span class="line">            <span class="comment"># 当前元素等于基准值</span></span><br><span class="line">            <span class="keyword">elif</span> s == reference:</span><br><span class="line">                equal.append(s)</span><br><span class="line">            <span class="comment"># 当前元素大于基准值</span></span><br><span class="line">        	<span class="keyword">else</span>:</span><br><span class="line">                large.append(s)</span><br><span class="line">            <span class="built_in">print</span>(small,equal,large)</span><br><span class="line">    <span class="comment"># 调用自身，即为递归</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(small) + equal + quick_sort(large)</span><br></pre></td></tr></table></figure>
<p>实用版：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        reference = array[<span class="number">0</span>]</span><br><span class="line">        small = [s <span class="keyword">for</span> s <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> s &lt; reference]</span><br><span class="line">        equal = [e <span class="keyword">for</span> e <span class="keyword">in</span> array <span class="keyword">if</span> e == reference]</span><br><span class="line">        large = [l <span class="keyword">for</span> l <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> l &gt; reference]</span><br><span class="line">    <span class="keyword">return</span> quick_sort(small) + equal + quick_sort(large)</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序">直接插入排序</h2>
<blockquote>
<p>直接插入法是直接排序的典型方法，毫无技术可言</p>
</blockquote>
<h3 id="算法思想-2">算法思想</h3>
<p>将排序数组中的数据逐一插入已排序的子序列中，从而得到一个完整的有序数组</p>
<h3 id="算法步骤-2">算法步骤</h3>
<ul>
<li>将数组的第一个数据看成一个有序的的子序列</li>
<li>从第二个数据开始，依次与前面的有序子序列进行比较，若待插入数据array[i]大于或等于array[i-1]，则原位插入；若待插入数据array[i]小于数据array[i-1]，则将array[i]临时存在临时变量temp中，将有序序列中大于temp的所有数据都后移一位，然后将temp插入对应的位置</li>
<li>重复步骤(2)</li>
</ul>
<h3 id="算法分析-2">算法分析</h3>
<p>时间复杂度：</p>
<ul>
<li>当数组为正序排列时，比较次数为n-1，移位次数为0，均为最小值，因此时间复杂度为
<code>O(n)</code></li>
<li>当数组为逆序排列时，每次比较都需要做一次位移，此时时间复杂度为
<code>O(n^2)</code>，是最差情况</li>
</ul>
<p>空间复杂度：</p>
<p>​ <code>O(1)</code></p>
<h3 id="算法代码-2">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接插入排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inset_sort</span>(<span class="params">array</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="comment"># 切记是从1到n-1，前闭后开</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    	<span class="comment"># 如果待插入数据小于前一个数据</span></span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; array[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># index为待插入的下标</span></span><br><span class="line">            index = i</span><br><span class="line">            <span class="comment"># 将待插入的数据放在temp中</span></span><br><span class="line">            temp = array[i]</span><br><span class="line">            <span class="comment"># 从i-1循环到0,反向取值，间距为1</span></span><br><span class="line">            <span class="comment"># 前两个参数为区间范围，第三个参数为取值方向和大小</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果array[j]大于temp</span></span><br><span class="line">                <span class="keyword">if</span> array[j] &gt; temp:</span><br><span class="line">                    <span class="comment"># 将array[j]后移一位</span></span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j]</span><br><span class="line">                    <span class="comment"># 更新待插入的下标</span></span><br><span class="line">                    index = j</span><br><span class="line">                <span class="comment"># 如果array[j]小于或等于temp</span></span><br><span class="line">            	<span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 跳出并结束</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 将temp插入有序子数列</span></span><br><span class="line">            array[index] = temp</span><br><span class="line">       <span class="comment"># 如果待插入数据大于前一个数据，则不需要移动</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序">希尔排序</h2>
<blockquote>
<p>即shell排序，也叫缩小增量排序，通过将原始列表分解为多个子列表来改进插入排序</p>
</blockquote>
<h3 id="算法排序">算法排序</h3>
<p>shell排序摒弃了直接插入排序逐一比较的区别，而是对指定距离(增量d)的元素进行比较，并不断把增量减小到1,直到排序完成</p>
<h3 id="算法步骤-3">算法步骤</h3>
<ul>
<li>选取增量<code>d = n/2</code></li>
<li>将排序数组分成d个子序列，然后分别进行直接插入排序</li>
<li>将增量取半，即 <code>d = d/2 = n/2/2</code></li>
<li>重复步骤(2)和(3)</li>
<li>对整个待排序数组进行直接插入排序</li>
</ul>
<h3 id="算法分析-3">算法分析</h3>
<p>似乎希尔排序并不比直接插入排序快多少，但是我们可以注意到它的特点：</p>
<ul>
<li>当d较大时，分组多，每组记录少，因此直接插入排序快</li>
<li>当d教小时，分组少，每组记录多，但是此时各组记录已经为正序，因此排序比正常的直接插入要快</li>
</ul>
<p>实际上希尔排序相较于直接排序，主要是优化了待排序数组的初始顺序，使其达到或接近于直接插入排序的最优情况</p>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>最好的情况下为<code>O(n^1.3)</code></li>
<li>最差的情况仍然为<code>O(n^2)</code></li>
</ul>
<h3 id="算法代码-3">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希尔排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="comment"># 设定初始增量d=n/2</span></span><br><span class="line">    d = <span class="built_in">len</span>(array)//<span class="number">2</span></span><br><span class="line">    <span class="comment"># 当增量大于0时执行,如果小于0,则退出循环</span></span><br><span class="line">    <span class="keyword">while</span> d&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># i 的取值范围为d到n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d,<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="comment"># 类似直接插入排序，比较当前值与指定增量的值</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=d <span class="keyword">and</span> array[i-d]&gt;array[i]:</span><br><span class="line">                <span class="comment"># 符号条件则交换</span></span><br><span class="line">                array[i],array[i-d] = array[i-d],array[i]</span><br><span class="line">                <span class="comment"># 取前一个指定增量的值，继续下一个判断</span></span><br><span class="line">                i -= d</span><br><span class="line">        <span class="comment"># 将增量取半,回到while循环</span></span><br><span class="line">        d = d//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="简单选择排序">简单选择排序</h2>
<blockquote>
<p>选择排序的思想和简单，每次从待排序数据中选择最小的一个放在最前面，直到将所有数据都遍历完</p>
</blockquote>
<h3 id="算法思想-3">算法思想</h3>
<p>遍历待排序数组并选出其中的最小数据元素，并于第一个元素交换位置，第二小的元素和第二个元素交换位置，直到剩下最后一个数据为最大数据，排序结束</p>
<h3 id="算法步骤-4">算法步骤</h3>
<ul>
<li>将第一个位置上的元素依次与后面的元素进行比较，若前者大，则交换二者位置</li>
<li>重复步骤（1），比较第二个位置上的元素，然后比较第三个位置上的元素…直到比到倒数第二个元素</li>
</ul>
<h3 id="算法分析-4">算法分析</h3>
<p>这个算法被视作在排序算法中最差劲的算法</p>
<p><strong>时间复杂度：</strong></p>
<p>无论时最好的情况还是最差的情况，都需要与所有数据进行遍历，因此时间复杂度始终为
<code>O(n^2)</code></p>
<h3 id="算法代码-4">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单选择排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="comment"># 从0遍历到待排序数组的长度len(array)-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># smallest为最小值的index，初始默认为当前的i</span></span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="comment"># j为比较index,从当前的index的下一位到数组结束</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="comment"># 如果当前最小值大于当前值</span></span><br><span class="line">            <span class="keyword">if</span> array[smallest]&gt;array[j]:</span><br><span class="line">                <span class="comment"># 则二者交换位置</span></span><br><span class="line">                array[smallest],array[j] = array[j],array[smallest]</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2
id="堆排序这个和数据结构相关我不是太理解">堆排序（这个和数据结构相关，我不是太理解）</h2>
<blockquote>
<p>简单排序只顾着，一次又一次的重新比对，却不对每一次的比较结果进行分析保存，所以导致效率低下，而堆排序加以改进</p>
</blockquote>
<h3 id="算法思想-4">算法思想</h3>
<p>首先需要直到什么是堆，堆是用数组实现的已标号的完全二叉树。接着需要引入小顶堆和大顶堆的思想：</p>
<ul>
<li>如果父节点的键值均不小于子节点，则为大顶堆：<code>arr[i]&gt;=arr[2*i+1] &amp;&amp; arr[i]&gt;=arr[2*i+2]</code></li>
<li>如果父节点的键值均不大于子节点，则为小顶堆：<code>arr[i]&lt;=arr[2*i+1] &amp;&amp; arr[i]&lt;=arr[2*i+2]</code></li>
</ul>
<p>也就是说，堆排序实际上就是一次又一次的将待排序数组构造成一个大顶堆，又一次次的将大顶堆的根节点(最大值)和最末尾的元素互换位置，并末尾的元素隔离，直到整个序列变得有序</p>
<h3 id="算法步骤-5">算法步骤</h3>
<ul>
<li>将待排序数组构建成一个大顶堆（如果降序排列，则使用小顶堆）。为了构建大顶堆，我们需要从从最后一个非叶子节点开始先从上到下，再从左往右进行调整。最后一个非叶子节点的计算公式为
<code>arr.length//2-1</code></li>
<li>将堆顶元素与末尾元素交换，使最大元素沉至数组末尾</li>
<li>重复步骤（1）和（2），直到整个序列都变得很有序。重新调整数组结构，使其满足大顶堆的结构</li>
</ul>
<h3 id="算法分析-5">算法分析</h3>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>最好的情况是正序，只需要进行
<code>O(n*log_2(n)</code>复杂度的比较操作，而不需要移动</li>
<li>最坏的情况时间复杂度还是<code>O(n*log_2(n)</code></li>
<li>从上面可以看出待排序数据的原始分布情况堆堆排序的效率影响较少</li>
</ul>
<h3 id="算法代码-5">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需要注意两点：</span></span><br><span class="line"><span class="string">    （1）递归思想</span></span><br><span class="line"><span class="string">    （2）切片思想</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="comment"># 当数组array的长度为1时，说明只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="comment"># 若存在两个及以上的节点</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 调整为大顶堆，按照从下往上从左往右的顺序进行调整</span></span><br><span class="line">        <span class="comment"># 从最后一个非叶子节点开始想前遍历，直到根节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)//<span class="number">2</span>-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当左孩子大于父节点</span></span><br><span class="line">            <span class="keyword">if</span> array[<span class="number">2</span>*i+<span class="number">1</span>]&gt;array[i]:</span><br><span class="line">                <span class="comment"># 交换位置</span></span><br><span class="line">                array[<span class="number">2</span>*i+<span class="number">1</span>],array[i] = array[i],array[<span class="number">2</span>*i+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 如果右孩子存在且大于父节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span>*i+<span class="number">2</span> &lt;= length-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> array[<span class="number">2</span>*i+<span class="number">2</span>]&gt;array[i]:</span><br><span class="line">                    <span class="comment"># 交换位置</span></span><br><span class="line">                    array[<span class="number">2</span>*i+<span class="number">2</span>],array[i] = array[i],array[<span class="number">2</span>*i+<span class="number">2</span>]</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;此处省略剩余数组重构过程,对结果无影响&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 将堆顶元素与末尾元素进行交换</span></span><br><span class="line">        array[<span class="number">0</span>],array[length-<span class="number">1</span>] = array[length-<span class="number">1</span>],array[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 递归调用heap_sort函数堆前n-1个元素进行堆排序并返回堆排序后的结果</span></span><br><span class="line">        <span class="keyword">return</span> heap_sort(array[<span class="number">0</span>:length-<span class="number">1</span>]) + array[length-<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<blockquote>
<p>归并排序是包含归并思想的排序方法，它是分治法的一个应用。分治法即“分而治之”</p>
</blockquote>
<h3 id="算法思想-5">算法思想</h3>
<p>先将原数组分为子序列，一生二，二生四，四生无穷，然后使每个子序列有序，再将两个有序子序列合并为一个有序序列，最终合一</p>
<h3 id="算法步骤-6">算法步骤</h3>
<ul>
<li>将排序数组一分为二，再将两个子序列一分为二，生成两个新的待排序数组</li>
<li>重复步骤（1），直到待排序数组的长度为1</li>
<li>按原路径将长度为1的两个数合并为一个有序序列，然后一直向前合并，最终得到一个完整的有序序列</li>
</ul>
<h3 id="算法分析-6">算法分析</h3>
<p>归并排序十分高效，它的分与合的结构都是完成二叉树，而分和合的二叉树深度均为<code>log_2(n)</code>，而每次分合的时间复杂度为
<code>O(n)</code>，故</p>
<p><strong>时间复杂度：</strong></p>
<p>始终为 <code>O(n*log_2(n))</code>，不论情况好坏</p>
<h3 id="算法代码-6">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left,right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    两个有序子序列的有序合并：</span></span><br><span class="line"><span class="string">    依次对两个有序列表的最小数进行比较，较小的放入result中</span></span><br><span class="line"><span class="string">    :param left: 左子序列</span></span><br><span class="line"><span class="string">    :param right: 右子序列</span></span><br><span class="line"><span class="string">    :return: 左右子序列所合成的有序序列</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># result: 存好已经排序的数组</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 如果不符合左右子序列长度均大于0,则说明至少其中的一个数组已经无数据了</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(left)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(right)&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 相等的时候优先把左侧的数放进结果列表，以保证其稳定性</span></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># list.pop(0)为移除并返回数组的第一个值</span></span><br><span class="line">            result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># 跳出while循环后,我们便可以把另一个数组尽数加入result后面</span></span><br><span class="line">    result += left</span><br><span class="line">    result += right</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">array</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	无序序列的不断拆分</span></span><br><span class="line"><span class="string">	每次均由中间位置进行拆分,不断自我递归调用，直到子序列长度为1</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果拆分后仅有单个元素，则返回该元素而不拆分</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="comment"># 如果有两个以上元素，则从中间位置开始拆分</span></span><br><span class="line">    middle = <span class="built_in">len</span>(array)//<span class="number">2</span></span><br><span class="line">    <span class="comment"># 拆分后的左侧子串</span></span><br><span class="line">    array_left = array[:middle]</span><br><span class="line">    <span class="comment"># 拆分后的右侧子串</span></span><br><span class="line">    array_right = array[middle:]</span><br><span class="line">    <span class="comment"># 对拆分后的左右子串序列再进行拆分，直到len(arr)=1</span></span><br><span class="line">    left = merge_sort(array_left)</span><br><span class="line">    right = merge_soort(array_right)</span><br><span class="line">    <span class="comment"># 合并已拆分的左右子序列的同时进行排列并返回排列后的结果</span></span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br></pre></td></tr></table></figure>
<h1 id="线性时间非比较类排序">线性时间非比较类排序</h1>
<h2 id="计数排序">计数排序</h2>
<blockquote>
<p>一种非基于比较的排序算法，通过辅助数组来确定各元素的为最终位置。因为在排序过程中不存在元素之间的比较和交换操作，当待排序数组为整数且数组内数据范围较小时，其优势十分明显</p>
</blockquote>
<h3 id="算法思想-6">算法思想</h3>
<p>对待排序数组中的每一个元素分别进行计数，确定整个数组中小于当前元素的个数，计数完成后便可以按照各计数值将各元素直接存放在已排序的数组中</p>
<h3 id="算法步骤-7">算法步骤</h3>
<ul>
<li>根据待排序序列中的最大元素和最小元素确定计数数组c的空间大小</li>
<li>统计待排序序列中的每个元素i出现的次数并存入c[i-1]</li>
<li>对c中的所有值进行累加，后者为其前面所有的值的总和</li>
<li>将每个元素放入已排序序列的第c[i]项，每放入一个元素，c[i]便减1</li>
<li>所有的元素都放入或者c[i]均为0之后,排序结束</li>
</ul>
<h3 id="算法分析-7">算法分析</h3>
<p>我们可以观察到计数排序的弊端,当最大值与最小值间的差值过大,会使开销增大,性能变差.其次当出现浮点数或其他形式时,也会有问题</p>
<p><strong>时间复杂度:</strong></p>
<p>第一个循环用于记录每个元素出现的次数,复杂度为
<code>O(n)</code>第二个循环用于对计数数组进行累加,复杂度为
O(k),k为申请空间的大小(即差值范围),第三个循环用于反向填充已排序的数列,复杂度为<code>O(n)</code>.总结可得,时间复杂度为
<code>O(n+k)</code></p>
<p><strong>空间复杂度:</strong></p>
<p>由于我们额外申请了一个大小为k的计数数组和一个与待排序数组同样大小的排序空间,所以空间复杂度为
<code>O(n+k)</code></p>
<h3 id="算法代码-7">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计数排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 计算序列的最大值和最小值</span></span><br><span class="line">    maximum,minimum = <span class="built_in">max</span>(arr),<span class="built_in">min</span>(arr)</span><br><span class="line">    <span class="comment"># 申请额外的空间作为计数数组,大小为最大值减最小值+1</span></span><br><span class="line">    countArr = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maximum-minimum+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 申请一个存放已排序序列的等长空间</span></span><br><span class="line">    finalArr = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr))]</span><br><span class="line">    <span class="comment"># 统计各元素出现的次数,并将统计结果存入计数数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="comment"># 出现一次就加1</span></span><br><span class="line">        countArr[i-minimum] += <span class="number">1</span> 	<span class="comment"># 注意下标index = data - min</span></span><br><span class="line">    <span class="comment"># 对计数数组进行累加</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(countArr)):</span><br><span class="line">        <span class="comment"># 从第二个位置开始,每个每个位置的值等于其本身加上前者</span></span><br><span class="line">        countArr[i] += countArr[i-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 开始将元素反向填充到最终的数组中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        finalArr[countArr[i-minimum]-<span class="number">1</span>] = i</span><br><span class="line">        <span class="comment"># 填充了一个就减一</span></span><br><span class="line">        countArr[i-minimum] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> finalArr</span><br></pre></td></tr></table></figure>
<h2 id="桶排序">桶排序</h2>
<blockquote>
<p>这是计数排序的改进版本</p>
</blockquote>
<h3 id="算法思想-7">算法思想</h3>
<p>根据元素的特性将集合拆分成为多个值域,我们称之为桶,将同一值域的元素存放在同一个桶内排序使其处于有序状态.如果每个桶是有序的,则由这些桶按顺序构成的集合也必定是有序的</p>
<h3 id="算法步骤-8">算法步骤</h3>
<ul>
<li>根据待排序序列中元素的分布特征和差值范围，确定映射函数与申请桶的个数</li>
<li>遍历序列，将每个记录放到对应的桶中</li>
<li>选取排序算法，对不为空的桶内部进行排序</li>
<li>把已排序的桶中的元素放回已经清空的原序列中</li>
</ul>
<h3 id="算法分析-8">算法分析</h3>
<p>我们可以注意到，桶排序和快速排序与计数排序的相似性。为了加深理解，我们在此进行区分：</p>
<ul>
<li>快速排序是对两个分区的排序，而桶排序是多个分区</li>
<li>快速排序是原地排序方式，即在数组本身内进行排序，而桶排序则是在申请的额外操作空间进行排序</li>
<li>快速排序中的每个区间仍然是快速排序，而桶排序可以自主选择桶内的排序方式</li>
<li>计数排序的申请空间的跨度是从最小元素到最大元素，受待排序序列的范围的影响很大，而桶排序弱化了这种影响，减少了元素大小不连续时计数排序所存在的空间浪费</li>
</ul>
<p>这里对于桶排序要抓住两个关键点：<strong>元素值域的划分</strong>和<strong>排序算法的选择</strong></p>
<p><strong>时间复杂度：</strong></p>
<p>映射过程的排序复杂度为
<code>O(n)</code>桶内排序算法的时间复杂度则和选择的排序复杂度相关</p>
<p><strong>空间复杂度：</strong></p>
<p>由于桶排序需要申请额外的空间进行分桶操作，所以空间复杂度为
<code>O(m+n)</code></p>
<h3 id="算法代码-8">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 桶排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    maximum,minimum = <span class="built_in">max</span>(arr),<span class="built_in">min</span>(arr)</span><br><span class="line">    <span class="comment"># 确定桶的个数</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maximum-minimum)//<span class="number">10</span>+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="comment"># 计算各元素的所属的桶位</span></span><br><span class="line">        index = (i - minimum)//<span class="number">10</span></span><br><span class="line">        <span class="comment"># list.append()---添加元素</span></span><br><span class="line">        buckets[index].append(i)</span><br><span class="line">    <span class="comment"># 将原数组清空</span></span><br><span class="line">    arr.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="comment"># 桶内排序---堆排序(可以用别的替代)</span></span><br><span class="line">        i = heap_sort(i)</span><br><span class="line">        <span class="comment"># 将已排序的桶重新放回已经清空的原数组中</span></span><br><span class="line">        arr.extend(i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h2 id="基数排序">基数排序</h2>
<blockquote>
<p>基数排序是桶排序的扩展，因此又称之为”桶子法”,它是通过键值的部分信息，将要排序的元素分配至”桶”中,以达到排序作用</p>
</blockquote>
<h3 id="算法思想-8">算法思想</h3>
<p>将各元素按位数切割成不同的数字，然后分别根据每个位数的比较结果进行排序</p>
<h3 id="算法步骤-9">算法步骤</h3>
<ul>
<li>确定待排序序列的最大位数</li>
<li>将所有待排序元素统一为最大数位长度(左补0)</li>
<li>从最低位到最高位分别进行排序</li>
<li>当最高位排序完成后，原数组变成有序数列</li>
</ul>
<h3 id="算法分析-9">算法分析</h3>
<p><strong>时间复杂度：</strong></p>
<p>每一轮排序的时间复杂度为
<code>O(n)</code>，而轮数由最大值的位数d决定，因此时间复杂度为
<code>O(d*n)</code></p>
<p><strong>空间复杂度：</strong></p>
<p>需要额外申请空间k，因此空间复杂度为 <code>O(n+k)</code></p>
<h3 id="算法代码-9">算法代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    maximum = <span class="built_in">max</span>(arr)	 <span class="comment"># 确定待排序数组中的最大位数</span></span><br><span class="line">    d = <span class="number">0</span>				<span class="comment"># 用d记录最大位数 </span></span><br><span class="line">    <span class="keyword">while</span> maximum!=<span class="number">0</span>:</span><br><span class="line">        maximum = maximum//<span class="number">10</span></span><br><span class="line">        d += <span class="number">1</span></span><br><span class="line">    <span class="comment"># d轮排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):					</span><br><span class="line">        <span class="comment"># 因为每一位数字都是0~9，所以建十个桶</span></span><br><span class="line">        s = [[] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]		 </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment"># 从个位数开始注意进行分桶操作</span></span><br><span class="line">            s[<span class="built_in">int</span>(j/(<span class="number">10</span>**i))%<span class="number">10</span>].append(j)</span><br><span class="line">        <span class="comment"># 用10个桶回填原数组</span></span><br><span class="line">        arr = [a <span class="keyword">for</span> b <span class="keyword">in</span> s <span class="keyword">for</span> a <span class="keyword">in</span> b]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/09/17-%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83-1/" rel="prev" title="17:算法小练(1)">
      <i class="fa fa-chevron-left"></i> 17:算法小练(1)
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/11/19-%E4%BA%92%E8%81%94%E4%BB%8A%E6%97%A5/" rel="next" title="19:互联今日">
      19:互联今日 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">非线性排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">直接插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">算法排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-3"><span class="nav-number">1.4.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.</span> <span class="nav-text">简单选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-4"><span class="nav-number">1.5.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%99%E4%B8%AA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%88%91%E4%B8%8D%E6%98%AF%E5%A4%AA%E7%90%86%E8%A7%A3"><span class="nav-number">1.6.</span> <span class="nav-text">堆排序（这个和数据结构相关，我不是太理解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-5"><span class="nav-number">1.6.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-5"><span class="nav-number">1.6.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-5"><span class="nav-number">1.7.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-6"><span class="nav-number">1.7.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-6"><span class="nav-number">1.7.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-6"><span class="nav-number">1.7.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%9D%9E%E6%AF%94%E8%BE%83%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">线性时间非比较类排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-6"><span class="nav-number">2.1.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-7"><span class="nav-number">2.1.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-7"><span class="nav-number">2.1.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-7"><span class="nav-number">2.1.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-7"><span class="nav-number">2.2.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-8"><span class="nav-number">2.2.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-8"><span class="nav-number">2.2.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-8"><span class="nav-number">2.2.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-8"><span class="nav-number">2.3.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-9"><span class="nav-number">2.3.2.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-9"><span class="nav-number">2.3.3.</span> <span class="nav-text">算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81-9"><span class="nav-number">2.3.4.</span> <span class="nav-text">算法代码</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ylin"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Ylin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ylin07" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ylin07" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/2504_90550008?spm=1010.2135.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;2504_90550008?spm&#x3D;1010.2135.3001.5343" rel="noopener" target="_blank">Ylin's CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/ylin07" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ylin07" rel="noopener" target="_blank">Ylin's 博客园</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://bluestar-34.github.io/" title="https:&#x2F;&#x2F;bluestar-34.github.io&#x2F;" rel="noopener" target="_blank">Neroblue's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://haoine.github.io/" title="https:&#x2F;&#x2F;haoine.github.io&#x2F;" rel="noopener" target="_blank">Haoine's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://admintor889.github.io/" title="https:&#x2F;&#x2F;admintor889.github.io&#x2F;" rel="noopener" target="_blank">Cnext's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://auberginewly.site/" title="https:&#x2F;&#x2F;auberginewly.site&#x2F;" rel="noopener" target="_blank">auberginewly's Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ylin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">171k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:36</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
